
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1v1 TAYA7 SAYEB</title>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:wght@700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Archivo+Narrow:wght@500;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #000;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100vh;
        }

        /* Dynamic Crosshair - precise dot + sprint circle morph (no glow) */
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 2px;
            height: 2px;
            background: transparent;
            border-radius: 50%;
            pointer-events: none;
            z-index: 100;
            box-shadow: none;
            transform: translate(-50%, -50%);
            --dot-color: #ffffff;
            --circle-border-color: rgba(255, 255, 255, 1);
        }

        /* Circle (shows while sprinting) */
        #crosshair::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 14px;
            height: 14px;
            border: 0.8px solid var(--circle-border-color);
            border-radius: 50%;
            transform: translate(-50%, -50%) scale(0.1);
            opacity: 0;
            transition: opacity 1200ms ease-out, transform 1200ms cubic-bezier(0.34, 1.56, 0.64, 1);
            will-change: opacity, transform;
            box-shadow: none;
        }

        /* Dot (default) */
        #crosshair::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 2px;
            height: 2px;
            background: var(--dot-color);
            border-radius: 50%;
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
            transition: opacity 420ms ease-in-out, transform 420ms ease-in-out;
            will-change: opacity, transform;
        }

        /* Morph state */
        #crosshair.running::before {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            transition: opacity 1200ms ease-out, transform 1200ms cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        #crosshair.running::after {
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.6);
        }

        #hud {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            color: white;
            font-family: 'Rajdhani', 'Roboto', sans-serif;
            padding: 30px;
            z-index: 10;
            pointer-events: none;
        }

        /* === TELEMETRY BAR (Professional Stats Ribbon) === */
        #telemetry-bar {
            position: fixed;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            width: auto;
            max-width: 100%;
            display: flex;
            flex-wrap: nowrap;
            align-items: center;
            justify-content: center;
            gap: 10px;
            pointer-events: none;
            z-index: 9999;
            font-family: 'Rajdhani', 'Consolas', 'Menlo', 'Courier New', monospace;
            font-size: 11px;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.92);
            text-transform: uppercase;
            letter-spacing: 0.08em;
            font-variant-numeric: tabular-nums;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.85);
        }

        #telemetry-bar .module {
            display: flex;
            align-items: center;
            gap: 3px;
            white-space: nowrap;
        }

        #telemetry-bar .label {
            color: rgba(255, 255, 255, 0.45);
            text-shadow: none;
            font-weight: 600;
            font-size: 10px;
            letter-spacing: 0.12em;
        }

        #telemetry-bar .v-fps {
            color: #00ff88;
        }

        #telemetry-bar .v-ms {
            color: #ffff00;
        }

        #telemetry-bar .v-gpu {
            color: #ff00ff;
        }

        #telemetry-bar .v-cpu {
            color: #00ccff;
        }

        #telemetry-bar .v-ram {
            color: #88ff44;
        }

        #telemetry-bar .v-net {
            color: #ffaa00;
        }

        #telemetry-bar .v-score {
            color: #ffdd00;
        }

        #telemetry-bar canvas.sparkline {
            margin-left: 3px;
            vertical-align: middle;
            border-radius: 2px;
            opacity: 0.9;
        }

        #telemetry-bar .v-kills {
            color: #ff6600;
        }

        #telemetry-bar .sep {
            width: 1px;
            height: 10px;
            background: rgba(255, 255, 255, 0.25);
            box-shadow: none;
        }

        #fpsLimiter {
            display: none;
        }

        /* ═══════════════════════════════════════════════════════════
           MICRO FLOAT HUD - Minimal Floating Squad List
           ═══════════════════════════════════════════════════════════ */
        #game-stats-hud {
            position: fixed;
            top: 38px;
            left: 12px;
            z-index: 1000;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            gap: 6px;
            align-items: flex-start;
        }

        .player-row {
            display: flex;
            align-items: flex-end;
            justify-content: flex-start;
            gap: 8px;
            opacity: 0.9;
            height: 30px;
        }

        /* Ping Display */
        .ping-display {
            font-family: 'Roboto Mono', 'Consolas', monospace;
            font-size: 10px;
            color: #bbb;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            min-width: 35px;
            text-align: left;
            padding-bottom: 2px;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .ping-display.p-good {
            color: #3bff8b;
        }

        .ping-display.p-mid {
            color: #ffe600;
        }

        .ping-display.p-bad {
            color: #ff4d4d;
        }

        /* Info Column */
        .info-col {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            justify-content: center;
        }

        .name-row {
            font-family: 'Bebas Neue', 'Impact', sans-serif;
            font-size: 16px;
            color: #fff;
            letter-spacing: 0.5px;
            line-height: 1;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            margin-bottom: 2px;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-rendering: optimizeLegibility;
        }

        .weap-row {
            font-size: 9px;
            color: #ccc;
            text-transform: uppercase;
            font-weight: 700;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            letter-spacing: 0.5px;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Health Rail */
        .hp-rail {
            width: 70px;
            height: 2px;
            background: rgba(0, 0, 0, 0.5);
            position: relative;
            margin-top: 2px;
        }

        .hp-fill {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            background: #fff;
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.4);
            transition: width 0.2s ease-out;
        }

        /* Avatar */
        .avatar-wrap {
            width: 26px;
            height: 26px;
            position: relative;
        }

        .avatar-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            clip-path: circle(50%);
            filter: grayscale(100%) drop-shadow(1px 1px 0px rgba(0, 0, 0, 0.8));
        }

        .rank-num {
            position: absolute;
            bottom: -2px;
            right: -2px;
            background: #fff;
            color: #000;
            font-size: 8px;
            font-weight: 900;
            padding: 1px 3px;
            box-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* My Player Style */
        .player-row.me .name-row {
            color: #FFD700;
        }

        .player-row.me .hp-fill {
            background: #FFD700;
        }

        .player-row.me .ping-display {
            color: #fff;
            opacity: 0.5;
        }

        /* Dead State */
        .player-row.dead {
            opacity: 0.5;
        }

        .player-row.dead .avatar-img {
            filter: grayscale(100%) brightness(0.6) drop-shadow(1px 1px 0px rgba(0, 0, 0, 0.8));
        }

        .player-row.dead .name-row {
            text-decoration: line-through;
            color: #666;
        }

        .player-row.dead .hp-rail {
            display: none;
        }

        .player-row.dead .weap-row {
            color: #ff3333;
        }

        /* ═══════════════════════════════════════════════════════════
           MINECRAFT XP BAR HUD
           ═══════════════════════════════════════════════════════════ */
        :root {
            /* Minecraft XP Bar Scale */
            --mc-s: 2px;
            --mc-b: #000000;

            /* Level Number Green Color */
            --mc-txt: #80ff20;

            /* XP FILLED COLORS (Reached) */
            --mc-fill-top-1: #b5fc2c;
            --mc-fill-top-2: #80ff20;
            --mc-fill-mid-1: #80ff20;
            --mc-fill-mid-2: #5fba18;
            --mc-fill-bot-1: #28540c;
            --mc-fill-bot-2: #1e4009;

            /* XP EMPTY COLORS (Unreached Background) */
            --mc-empty-top-1: #384828;
            --mc-empty-top-2: #24301a;
            --mc-empty-mid-1: #3f522e;
            --mc-empty-mid-2: #202b17;
            --mc-empty-bot-1: #161f0e;
            --mc-empty-bot-2: #0a0e06;

            /* Notch (Divider) Color */
            --mc-notch: rgba(0, 0, 0, 0.45);
        }

        #mcXpHud {
            position: fixed;
            bottom: 32px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 500;
            display: none;
            image-rendering: pixelated;
        }

        #mcXpHud.visible {
            display: block;
        }

        .mc-hud-wrapper {
            position: relative;
            width: calc(182 * var(--mc-s));
            display: flex;
            flex-direction: column;
        }

        /* Minecraft Pixel Level Number - Using Minecraft font style */
        @font-face {
            font-family: 'MinecraftPixel';
            src: url('data:font/woff2;charset=utf-8;base64,') format('woff2');
        }

        .mc-level-num {
            position: absolute;
            left: 50%;
            bottom: calc(10 * var(--mc-s));
            transform: translateX(-50%);
            z-index: 20;
            font-family: 'Press Start 2P', 'Courier New', monospace;
            font-size: calc(5 * var(--mc-s));
            font-weight: normal;
            color: var(--mc-txt);
            text-shadow:
                calc(1 * var(--mc-s)) calc(1 * var(--mc-s)) 0 #000,
                calc(-1 * var(--mc-s)) calc(1 * var(--mc-s)) 0 #000,
                calc(1 * var(--mc-s)) calc(-1 * var(--mc-s)) 0 #000,
                calc(-1 * var(--mc-s)) calc(-1 * var(--mc-s)) 0 #000,
                calc(1 * var(--mc-s)) 0 0 #000,
                calc(-1 * var(--mc-s)) 0 0 #000,
                0 calc(1 * var(--mc-s)) 0 #000,
                0 calc(-1 * var(--mc-s)) 0 #000;
            line-height: 1;
            letter-spacing: 1px;
            -webkit-font-smoothing: none;
            -moz-osx-font-smoothing: unset;
            image-rendering: pixelated;
        }

        /* XP Bar Core (Empty Background) */
        .mc-xp-bar-core {
            position: relative;
            width: calc(180 * var(--mc-s));
            height: calc(5 * var(--mc-s));
            margin: 0 auto;

            box-shadow:
                0 calc(-1 * var(--mc-s)) 0 0 var(--mc-b),
                0 calc(1 * var(--mc-s)) 0 0 var(--mc-b),
                calc(-1 * var(--mc-s)) 0 0 0 var(--mc-b),
                calc(1 * var(--mc-s)) 0 0 0 var(--mc-b);

            background-image:
                repeating-linear-gradient(to right,
                    transparent,
                    transparent calc(8*var(--mc-s)),
                    var(--mc-notch) calc(8*var(--mc-s)),
                    var(--mc-notch) calc(9*var(--mc-s))),
                repeating-linear-gradient(to right, var(--mc-empty-top-1) 0, var(--mc-empty-top-1) var(--mc-s), var(--mc-empty-top-2) var(--mc-s), var(--mc-empty-top-2) calc(2*var(--mc-s)), var(--mc-empty-top-1) calc(2*var(--mc-s)), var(--mc-empty-top-1) calc(3*var(--mc-s)), var(--mc-empty-top-1) calc(3*var(--mc-s)), var(--mc-empty-top-1) calc(4*var(--mc-s)), var(--mc-empty-top-2) calc(4*var(--mc-s)), var(--mc-empty-top-2) calc(5*var(--mc-s)), var(--mc-empty-top-1) calc(5*var(--mc-s)), var(--mc-empty-top-1) calc(6*var(--mc-s))),
                repeating-linear-gradient(to right, var(--mc-empty-mid-1) 0, var(--mc-empty-mid-1) calc(3*var(--mc-s)), var(--mc-empty-mid-2) calc(3*var(--mc-s)), var(--mc-empty-mid-2) calc(4*var(--mc-s)), var(--mc-empty-mid-1) calc(4*var(--mc-s)), var(--mc-empty-mid-1) calc(8*var(--mc-s))),
                repeating-linear-gradient(to right, var(--mc-empty-bot-1) 0, var(--mc-empty-bot-1) calc(2*var(--mc-s)), var(--mc-empty-bot-2) calc(2*var(--mc-s)), var(--mc-empty-bot-2) calc(3*var(--mc-s)), var(--mc-empty-bot-1) calc(3*var(--mc-s)), var(--mc-empty-bot-1) calc(6*var(--mc-s)));

            background-size: 100% 100%, 100% var(--mc-s), 100% calc(2 * var(--mc-s)), 100% calc(2 * var(--mc-s));
            background-repeat: repeat-x;
            background-position: 0 0, 0 0, 0 var(--mc-s), 0 calc(3 * var(--mc-s));
        }

        /* XP Bar Fill (Foreground) */
        .mc-xp-bar-fill {
            width: 0%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
            transition: width 0.3s ease-out;

            background-image:
                repeating-linear-gradient(to right,
                    transparent,
                    transparent calc(8*var(--mc-s)),
                    var(--mc-notch) calc(8*var(--mc-s)),
                    var(--mc-notch) calc(9*var(--mc-s))),
                repeating-linear-gradient(to right, var(--mc-fill-top-1) 0, var(--mc-fill-top-1) var(--mc-s), var(--mc-fill-top-2) var(--mc-s), var(--mc-fill-top-2) calc(2*var(--mc-s)), var(--mc-fill-top-1) calc(2*var(--mc-s)), var(--mc-fill-top-1) calc(3*var(--mc-s)), var(--mc-fill-top-1) calc(3*var(--mc-s)), var(--mc-fill-top-1) calc(4*var(--mc-s)), var(--mc-fill-top-2) calc(4*var(--mc-s)), var(--mc-fill-top-2) calc(5*var(--mc-s)), var(--mc-fill-top-1) calc(5*var(--mc-s)), var(--mc-fill-top-1) calc(6*var(--mc-s))),
                repeating-linear-gradient(to right, var(--mc-fill-mid-1) 0, var(--mc-fill-mid-1) calc(3*var(--mc-s)), var(--mc-fill-mid-2) calc(3*var(--mc-s)), var(--mc-fill-mid-2) calc(4*var(--mc-s)), var(--mc-fill-mid-1) calc(4*var(--mc-s)), var(--mc-fill-mid-1) calc(8*var(--mc-s))),
                repeating-linear-gradient(to right, var(--mc-fill-bot-1) 0, var(--mc-fill-bot-1) calc(2*var(--mc-s)), var(--mc-fill-bot-2) calc(2*var(--mc-s)), var(--mc-fill-bot-2) calc(3*var(--mc-s)), var(--mc-fill-bot-1) calc(3*var(--mc-s)), var(--mc-fill-bot-1) calc(6*var(--mc-s)));

            background-size: 100% 100%, 100% var(--mc-s), 100% calc(2 * var(--mc-s)), 100% calc(2 * var(--mc-s));
            background-repeat: repeat-x;
            background-position: 0 0, 0 0, 0 var(--mc-s), 0 calc(3 * var(--mc-s));

            box-shadow: inset -1px 0 0 rgba(0, 0, 0, 0.2);
        }

        /* Minecraft Level Up Animation */
        @keyframes mcLevelUp {
            0% {
                transform: translateX(-50%) scale(1);
            }

            25% {
                transform: translateX(-50%) scale(1.5);
                text-shadow: 0 0 20px #80ff20, -2px 0 #000, 2px 0 #000, 0 -2px #000, 0 2px #000;
            }

            50% {
                transform: translateX(-50%) scale(1.2);
            }

            100% {
                transform: translateX(-50%) scale(1);
            }
        }

        .mc-level-num.level-up {
            animation: mcLevelUp 0.5s ease-out;
        }

        /* Hide old level display */
        #levelDisplay {
            display: none !important;
        }

        /* ═══════════════════════════════════════════════════════════
           MINIMAL SCOREBOARD (DISABLED - replaced by R6 Topbar)
           ═══════════════════════════════════════════════════════════ */
        #cs2Scoreboard {
            display: none !important;
            visibility: hidden !important;
        }

        .cs2-team {
            display: none;
        }

        .cs2-team.team-left,
        .cs2-team.team-right {
            display: none;
        }

        .cs2-avatar {
            width: 22px;
            height: 22px;
            border-radius: 3px;
            overflow: hidden;
            background: #2a2f35;
        }

        .cs2-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .cs2-name {
            display: none;
        }

        .cs2-score-box {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 8px;
            background: none;
            min-width: auto;
        }

        .cs2-score-box::before {
            display: none;
        }

        .cs2-score {
            font-size: 16px;
            font-weight: 600;
            min-width: 14px;
            text-align: center;
            color: #fff;
        }

        .cs2-score.score-left,
        .cs2-score.score-right {
            color: #fff;
        }

        .cs2-divider {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.4);
            font-weight: 400;
            margin: 0 4px;
        }

        .cs2-round-info {
            display: none;
        }

        /* ═══════════════════════════════════════════════════════════
           R6-STYLE TOP STATS BAR - DISABLED
           ═══════════════════════════════════════════════════════════ */
        #r6Topbar {
            display: none !important;
            visibility: hidden !important;
        }

        .r6-team-block {
            display: flex;
            height: 100%;
            align-items: center;
        }

        .r6-op-card {
            width: 26px;
            height: 28px;
            background-color: #1a1a1a;
            position: relative;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }

        .r6-op-card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        /* Blue Team */
        .r6-blue-team .r6-op-card {
            border-top: 3px solid #2d7bc2;
        }

        .r6-score-box-blue {
            width: 20px;
            height: 100%;
            background: #141414;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #3b8cf5;
            font-size: 14px;
            font-weight: 700;
            border-left: 1px solid #2d7bc2;
            padding: 0 4px;
        }

        /* Orange Team */
        .r6-orange-team .r6-op-card {
            border-top: 2px solid #d4560e;
        }

        .r6-score-box-orange {
            width: 20px;
            height: 100%;
            background: #141414;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #e65a12;
            font-size: 14px;
            font-weight: 700;
            border-right: 1px solid #d4560e;
            padding: 0 4px;
        }

        /* Timer Section */
        .r6-timer-section {
            width: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 1);
            margin: 0 8px;
            padding: 0;
            gap: 0px;
        }

        .r6-time-text {
            font-size: 18px;
            line-height: 1;
            font-weight: 700;
        }

        .r6-time-text.critical {
            color: #e65a12;
            animation: r6TimePulse 0.5s ease-in-out infinite;
        }

        @keyframes r6TimePulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.6;
            }
        }

        .r6-round-text {
            font-size: 7px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            text-shadow: 1px 1px 1px black;
        }

        /* Dead Overlay */
        .r6-op-card.is-dead::after {
            content: "☠";
            position: absolute;
            inset: 0;
            background: rgba(30, 30, 30, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 18px;
            color: rgba(255, 255, 255, 0.5);
        }

        .r6-op-card.is-dead img {
            opacity: 0.3;
        }

        /* HP Bar */
        .r6-hp-container {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: rgba(0, 0, 0, 0.5);
        }

        .r6-hp-fill {
            background: white;
            height: 100%;
            box-shadow: 0 0 2px white;
            transition: width 0.3s ease;
        }

        .r6-hp-fill.critical {
            background: #ff4444;
            box-shadow: 0 0 4px #ff4444;
        }

        .r6-hp-fill.warning {
            background: #ffaa00;
            box-shadow: 0 0 4px #ffaa00;
        }

        /* Level Badge */
        .r6-level-badge {
            position: absolute;
            top: -4px;
            right: -4px;
            min-width: 12px;
            height: 12px;
            background: linear-gradient(135deg, #3b8cf5, #2563eb);
            border-radius: 2px;
            font-size: 7px;
            font-weight: 700;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 2px;
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 5;
        }

        .r6-level-badge.r6-level-enemy {
            background: linear-gradient(135deg, #e65a12, #c2410c);
        }

        /* Level colors by tier */
        .r6-level-badge.level-bronze {
            background: linear-gradient(135deg, #cd7f32, #8b4513);
        }

        .r6-level-badge.level-silver {
            background: linear-gradient(135deg, #c0c0c0, #808080);
        }

        .r6-level-badge.level-gold {
            background: linear-gradient(135deg, #ffd700, #daa520);
        }

        .r6-level-badge.level-platinum {
            background: linear-gradient(135deg, #e5e4e2, #a0a0a0);
        }

        .r6-level-badge.level-diamond {
            background: linear-gradient(135deg, #b9f2ff, #00bfff);
        }

        /* Unknown Player */
        .r6-unknown-op {
            background-color: #444;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            width: 100%;
            color: #888;
            font-size: 20px;
        }

        /* Current Player Highlight */
        .r6-op-card.is-me {
            box-shadow: 0 0 0 2px #3b8cf5;
        }

        .r6-orange-team .r6-op-card.is-me {
            box-shadow: 0 0 0 2px #e65a12;
        }

        /* XP Popup Notification */
        .xp-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Rajdhani', sans-serif;
            font-size: 28px;
            font-weight: 700;
            color: #00ff88;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.8), 0 2px 4px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            z-index: 9999;
            animation: xpPopup 1.5s ease-out forwards;
        }

        @keyframes xpPopup {
            0% {
                opacity: 0;
                transform: translate(-50%, -30%) scale(0.5);
            }

            20% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.2);
            }

            40% {
                transform: translate(-50%, -50%) scale(1);
            }

            100% {
                opacity: 0;
                transform: translate(-50%, -80%) scale(0.8);
            }
        }

        /* Level Up Notification */
        .level-up-popup {
            position: fixed;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Rajdhani', sans-serif;
            text-align: center;
            pointer-events: none;
            z-index: 10000;
            animation: levelUpPopup 3s ease-out forwards;
        }

        .level-up-popup .level-up-title {
            font-size: 48px;
            font-weight: 700;
            color: #ffd700;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.8), 0 0 60px rgba(255, 215, 0, 0.4);
            letter-spacing: 8px;
        }

        .level-up-popup .level-up-number {
            font-size: 72px;
            font-weight: 800;
            color: #00ff88;
            text-shadow: 0 0 40px rgba(0, 255, 136, 0.8);
        }

        @keyframes levelUpPopup {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.3);
            }

            15% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.3);
            }

            30% {
                transform: translate(-50%, -50%) scale(1);
            }

            70% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }

            100% {
                opacity: 0;
                transform: translate(-50%, -70%) scale(0.8);
            }
        }

        /* Level Info Tooltip - Minimal FPS Style */
        #levelTooltip {
            position: fixed;
            display: none;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 12px 16px;
            font-family: 'Rajdhani', sans-serif;
            color: #fff;
            z-index: 10001;
            pointer-events: none;
            min-width: 160px;
            opacity: 0;
            transition: opacity 0.15s ease;
        }

        #levelTooltip.visible {
            display: block;
            opacity: 1;
        }

        #levelTooltip .tooltip-title {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.5);
            font-weight: 600;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #levelTooltip .tooltip-row {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            margin: 4px 0;
            color: rgba(255, 255, 255, 0.6);
        }

        #levelTooltip .tooltip-row span:last-child {
            color: #fff;
            font-weight: 600;
        }

        #levelTooltip .tooltip-progress {
            margin-top: 8px;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            overflow: hidden;
        }

        #levelTooltip .tooltip-progress-bar {
            height: 100%;
            background: rgba(255, 255, 255, 0.7);
            transition: width 0.3s ease;
        }

        .hud-container {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            max-width: 1800px;
            margin: 0 auto;
            gap: 20px;
        }

        .hud-left,
        .hud-right,
        .hud-center {
            flex: 1;
            animation: slideIn 0.5s ease-out;
        }

        .hud-right {
            text-align: right;
            flex: 0;
        }

        .hud-center {
            text-align: center;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(30px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .health-container {
            position: relative;
            width: 150px;
            height: 150px;
        }

        .postal-health-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 89%;
            height: 89%;
            background-image: url('postalheart/background.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 1;
        }

        .postal-heart {
            position: absolute;
            top: 45%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 75%;
            height: 75%;
            background-image: url('postalheart/heart.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 2;
            animation: heartbeat 1s ease-in-out infinite;
            filter: drop-shadow(0 0 8px rgba(255, 100, 50, 0.6));
        }

        .postal-heart.critical {
            animation: heartbeat-critical 0.3s ease-in-out infinite;
            filter: drop-shadow(0 0 15px rgba(255, 0, 0, 0.9)) brightness(1.3);
        }

        .postal-heart.warning {
            animation: heartbeat-warning 0.5s ease-in-out infinite;
            filter: drop-shadow(0 0 10px rgba(255, 150, 0, 0.7));
        }

        .postal-heart.dead {
            animation: none;
            filter: grayscale(100%) brightness(0.5);
            opacity: 0.5;
        }

        @keyframes heartbeat {

            0%,
            100% {
                transform: translate(-50%, -50%) scale(1);
            }

            15% {
                transform: translate(-50%, -50%) scale(1.08);
            }

            30% {
                transform: translate(-50%, -50%) scale(1);
            }

            45% {
                transform: translate(-50%, -50%) scale(1.05);
            }

            60% {
                transform: translate(-50%, -50%) scale(1);
            }
        }

        @keyframes heartbeat-critical {

            0%,
            100% {
                transform: translate(-50%, -50%) scale(1);
            }

            50% {
                transform: translate(-50%, -50%) scale(1.15);
            }
        }

        @keyframes heartbeat-warning {

            0%,
            100% {
                transform: translate(-50%, -50%) scale(1);
            }

            50% {
                transform: translate(-50%, -50%) scale(1.1);
            }
        }

        .postal-health-number {
            position: absolute;
            bottom: 5px;
            right: 8px;
            transform: none;
            font-family: 'Arial Black', 'Impact', sans-serif;
            font-size: 26px;
            font-weight: 900;
            font-style: italic;
            color: #b60e0e;
            text-shadow:
                1px 1px 0 #000,
                -1px -1px 0 #000,
                1px -1px 0 #000,
                -1px 1px 0 #000,
                2px 2px 2px rgba(0, 0, 0, 0.8);
            z-index: 3;
            letter-spacing: 1px;
        }

        .postal-health-number.critical {
            color: #8B0000;
            animation: numberPulse 0.3s ease-in-out infinite;
            text-shadow:
                1px 1px 0 #000,
                -1px -1px 0 #000,
                0 0 10px rgba(139, 0, 0, 0.6);
        }

        .postal-health-number.warning {
            color: #6a0000;
        }

        @keyframes numberPulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }
        }

        .health-bar {
            display: none;
        }

        .health-bar-inner {
            display: none;
        }

        .health-text {
            display: none;
        }

        .health-icon {
            display: none;
        }

        @keyframes iconPulse {

            0%,
            100% {
                transform: translateZ(5px) scale(1);
            }

            50% {
                transform: translateZ(5px) scale(1.2);
            }
        }

        .score-container {
            display: none;
            /* Hidden - using CS2 scoreboard instead */
            font-size: 24px;
            font-weight: 700;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 1), 0 4px 8px rgba(0, 0, 0, 0.8), 0 0 15px rgba(255, 193, 7, 0.6);
            color: #FFC107;
            transform-style: preserve-3d;
            transform: perspective(1000px) rotateX(5deg) translateZ(20px);
        }

        .ammo-container {
            display: none;
        }

        /* Lobby Squad List Styles - Minimal Original */
        #lobbySquadList {
            position: fixed;
            top: 70px;
            right: 40px;
            width: 320px;
            font-family: 'Rajdhani', 'Inter', sans-serif;
            z-index: 1500;
            display: none;
            flex-direction: column;
            gap: 4px;
            pointer-events: auto;

            /* Subtle 3D Tilt Effect - Like BF3 */
            transform: perspective(800px) rotateY(-8deg);
            transform-origin: right center;
            transform-style: preserve-3d;
        }

        .lobby-header {
            font-size: 18px;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.7);
            text-transform: uppercase;
            margin-bottom: 10px;
            padding: 0 12px 10px 12px;
            letter-spacing: 2px;
            border: none;
            border-bottom: 1px solid rgba(255, 255, 255, 0.15);
            display: flex;
            justify-content: space-between;
        }

        .lobby-header span.count {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.3);
            font-weight: 400;
        }

        .lobby-player {
            background: rgba(0, 0, 0, 0.5);
            padding: 12px 14px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-left: 3px solid rgba(255, 255, 255, 0.15);
            transition: all 0.2s ease;
            gap: 12px;
        }

        .lobby-player.is-me {
            border-left-color: rgba(255, 255, 255, 0.5);
            background: rgba(255, 255, 255, 0.05);
        }

        .lobby-player.is-enemy {
            border-left-color: rgba(255, 255, 255, 0.25);
        }

        .lobby-player.is-enemy .player-name {
            color: rgba(255, 255, 255, 0.75);
        }

        /* Profile Picture Styles */
        .player-avatar {
            position: relative;
            width: 42px;
            height: 42px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            overflow: visible;
            flex-shrink: 0;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: rgba(255, 255, 255, 0.3);
        }

        .player-avatar:hover {
            border-color: rgba(255, 255, 255, 0.5);
            transform: scale(1.05);
        }

        .player-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 50%;
        }

        .player-avatar.is-me {
            border-color: rgba(255, 255, 255, 0.5);
        }

        .player-avatar .level-ring {
            position: absolute;
            bottom: -2px;
            right: -2px;
            width: 18px;
            height: 18px;
            background: #000;
            border-radius: 50%;
            border: 2px solid #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 700;
            color: #fff;
        }

        .player-avatar-container {
            position: relative;
        }

        /* Level badge mini overlay */
        .level-badge-mini {
            position: absolute !important;
            bottom: -4px !important;
            right: -4px !important;
            width: 20px !important;
            height: 20px !important;
            background: #000 !important;
            border-radius: 50% !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            font-size: 10px !important;
            font-weight: 700 !important;
            color: #fff !important;
            border: 2px solid #fff !important;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.6) !important;
        }

        .level-badge-mini::before,
        .level-badge-mini::after {
            display: none !important;
        }

        /* Edit icon for own avatar */
        .avatar-edit-icon {
            position: absolute;
            top: -2px;
            right: -2px;
            width: 16px;
            height: 16px;
            background: rgba(255, 255, 255, 0.25);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            color: rgba(255, 255, 255, 0.85);
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .player-avatar:hover .avatar-edit-icon {
            opacity: 1;
        }

        .player-info {
            display: flex;
            flex-direction: column;
            gap: 2px;
            flex: 1;
        }

        .player-name {
            font-weight: 600;
            font-size: 16px;
            color: #ccc;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }

        .player-level {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.6);
            font-weight: 500;
        }

        .lobby-player.is-me .player-name {
            color: rgba(255, 255, 255, 0.95);
            text-shadow: none;
        }

        .player-status-container {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }

        .player-status {
            font-size: 9px;
            font-weight: 700;
            color: #666;
            text-transform: uppercase;
        }

        .lobby-player.is-me .player-status {
            color: #fff;
        }

        .lobby-player.is-enemy .player-status {
            color: #ff3333;
        }

        .player-ping {
            font-size: 9px;
            color: #444;
            font-family: monospace;
        }

        /* Squad List Widget - HIDDEN */
        .squad-list {
            display: none !important;
        }

        .squad-member {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
            transition: opacity 0.2s;
        }

        .squad-member.you {
            color: rgba(255, 255, 255, 0.8);
            font-weight: 600;
        }

        .squad-member.teammate {
            color: rgba(255, 255, 255, 0.5);
        }

        .squad-status-indicator {
            width: 2px;
            height: 12px;
            flex-shrink: 0;
            box-shadow: 0 0 4px currentColor, 0 0 8px currentColor, 0 0 12px currentColor;
            filter: brightness(1.2);
        }

        .squad-status-indicator.healthy {
            background: #22ff55;
            color: #22ff55;
            box-shadow: 0 0 4px #22ff55, 0 0 8px #22ff55, 0 0 12px #22ff55, 0 0 16px rgba(34, 255, 85, 0.5);
        }

        .squad-status-indicator.injured {
            background: #ffeb3b;
            color: #ffeb3b;
            box-shadow: 0 0 4px #ffeb3b, 0 0 8px #ffeb3b, 0 0 12px #ffeb3b, 0 0 16px rgba(255, 235, 59, 0.5);
        }

        .squad-status-indicator.kia {
            background: #ff4444;
            color: #ff4444;
            box-shadow: 0 0 4px #ff4444, 0 0 8px #ff4444, 0 0 12px #ff4444, 0 0 16px rgba(255, 68, 68, 0.5);
        }

        .squad-status-indicator.enemy {
            background: #ff4444;
            color: #ff4444;
            box-shadow: 0 0 4px #ff4444, 0 0 8px #ff4444, 0 0 12px #ff4444, 0 0 16px rgba(255, 68, 68, 0.5);
        }

        .squad-status-indicator.enemy.injured {
            background: #ff8800;
            color: #ff8800;
            box-shadow: 0 0 4px #ff8800, 0 0 8px #ff8800, 0 0 12px #ff8800, 0 0 16px rgba(255, 136, 0, 0.5);
        }

        .squad-member-name {
            flex: 1;
        }

        .squad-member-tag {
            font-size: 8px;
            padding: 2px 4px;
            border-radius: 2px;
            margin-left: 4px;
        }

        .squad-member-tag.weapon {
            background: rgba(234, 179, 8, 0.2);
            color: #eab308;
        }

        .squad-member-tag.kia {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }

        .weapon-name {
            font-size: 10px;
            margin-top: 4px;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: 600;
            color: rgba(200, 200, 255, 0.7);
            text-shadow: 0 2px 6px rgba(0, 0, 0, 1), 0 0 10px rgba(100, 100, 255, 0.5);
            order: 2;
        }

        .ammo-text {
            font-size: 28px;
            font-weight: 700;
            letter-spacing: 2px;
            text-shadow: 0 2px 6px rgba(0, 0, 0, 1), 0 4px 12px rgba(0, 0, 0, 0.8);
            color: rgba(255, 255, 255, 0.95);
            order: 1;
            line-height: 1;
        }

        .ammo-separator {
            font-size: 20px;
            opacity: 0.6;
            margin: 0 4px;
            color: rgba(255, 255, 255, 0.5);
        }

        #reloadIndicator {
            position: fixed;
            bottom: 100px;
            right: 30px;
            color: #ffaa00;
            font-size: 16px;
            font-weight: 700;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 1), 0 0 15px rgba(255, 170, 0, 0.8);
            z-index: 10;
            display: none;
            animation: pulse-reload 0.6s infinite;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        @keyframes pulse-reload {

            0%,
            100% {
                opacity: 1;
                transform: scale(1);
            }

            50% {
                opacity: 0.7;
                transform: scale(1.05);
            }
        }

        /* ═══════════════════════════════════════════════════════════
           SMOOTH KILL FEED (Right Side)
           ═══════════════════════════════════════════════════════════ */
        #killFeed {
            position: fixed;
            top: 100px;
            right: 25px;
            width: 350px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 6px;
            z-index: 1000;
            pointer-events: none;
        }

        .kill-message {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 8px;
            font-family: 'Archivo Narrow', 'Arial Narrow', sans-serif;
            font-size: 13px;
            color: #333;
            font-weight: 500;
            padding: 4px 10px;
            background: none;

            /* Physics-based entrance animation */
            height: 0;
            opacity: 0;
            transform: translateY(20px);
            animation:
                killSpawn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards,
                killFadeout 0.6s ease-in forwards 4s;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .kill-message .k-name {
            font-weight: 800;
            color: #fff;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .kill-message .v-name {
            font-weight: 800;
            color: #aaa;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .kill-message .w-icon {
            font-size: 14px;
            color: #888;
            margin: 0 2px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .kill-message.is-me .k-name {
            border-bottom: 2px solid #FFD700;
            color: #FFD700;
        }

        .kill-message.headshot .w-icon {
            color: #ff4444;
        }

        @keyframes killSpawn {
            to {
                height: 24px;
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes killFadeout {
            to {
                opacity: 0;
                height: 0;
                transform: translateX(30px);
                margin: 0;
                padding: 0;
            }
        }

        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: flex-start;
            z-index: 1000;
            color: white;
            pointer-events: none;
            padding-left: 100px;
            /* Shift content to the right */
        }

        #startScreen>* {
            pointer-events: auto;
        }

        #menuCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 999;
            pointer-events: none;
        }

        .menu-content {
            /* Removed background and borders for clean look */
            background: transparent;
            padding: 0;
            border: none;
            box-shadow: none;
            backdrop-filter: none;

            /* 3D Tilt Effect */
            transform: perspective(1000px) rotateY(15deg) rotateX(5deg);
            transform-origin: left center;

            display: flex;
            flex-direction: column;
            gap: 5px;
            width: 280px;
            margin-top: 10px;
        }

        .menu-content * {
            pointer-events: auto;
        }

        #startScreen h1 {
            font-size: 18px;
            margin-bottom: 2px;
            font-weight: 600;
            letter-spacing: 1.5px;
            color: #ffffff;
            font-family: 'Inter', 'Segoe UI', -apple-system, sans-serif;
            text-transform: uppercase;
            line-height: 1.1;
        }

        #startScreen p {
            font-size: 8px;
            margin-bottom: 10px;
            text-align: left;
            max-width: 100%;
            line-height: 1.3;
            color: rgba(255, 255, 255, 0.65);
            font-weight: 400;
            letter-spacing: 0.3px;
        }

        /* Modern FPS Button Styles */
        .menu-button {
            width: 100%;
            padding: 5px 0;
            padding-left: 6px;
            font-size: 16px;
            font-weight: 700;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.6);
            background: transparent;
            border: none;
            text-align: left;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Rajdhani', 'Segoe UI', sans-serif;
            letter-spacing: 0.8px;
            position: relative;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
            overflow: visible;
        }

        .menu-button::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: 0;
            background: rgba(255, 255, 255, 0.25);
            transition: width 0.2s ease;
            z-index: 1;
        }

        .menu-button:hover::before {
            width: 4px;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
        }

        .menu-button:hover {
            color: #ffffff;
            padding-left: 14px;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
            background: linear-gradient(90deg, rgba(255, 255, 255, 0.1) 0%, transparent 100%);
        }

        .menu-button:active {
            transform: translateX(2px);
        }

        .menu-button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            pointer-events: none;
        }

        /* Specific hover colors for button types */
        .menu-button-primary:hover::before {
            background: rgba(255, 255, 255, 0.25);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
        }

        .menu-button-success:hover::before {
            background: rgba(255, 255, 255, 0.25);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
        }

        .menu-button-danger:hover::before {
            background: rgba(255, 255, 255, 0.25);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
        }

        /* Section Dividers */
        .menu-section-divider {
            text-align: left;
            margin: 8px 0 4px 0;
            color: rgba(255, 255, 255, 0.4);
            font-size: 6px;
            font-weight: 600;
            letter-spacing: 0.8px;
            text-transform: uppercase;
            font-family: 'Inter', 'Segoe UI', -apple-system, sans-serif;
            position: relative;
            padding-left: 6px;
        }

        .menu-section-divider::before {
            content: '';
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 2px;
            height: 8px;
            background: rgba(255, 255, 255, 0.25);
        }

        /* Input Fields */
        .menu-input {
            width: 100%;
            padding: 8px 12px;
            font-size: 10px;
            background: rgba(0, 0, 0, 0.3);
            color: #ffffff;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 1px;
            font-family: 'Inter', 'Segoe UI', -apple-system, sans-serif;
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            letter-spacing: 0.3px;
        }

        .menu-input:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.3);
            background: rgba(0, 0, 0, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.06);
        }

        .menu-input::placeholder {
            color: rgba(255, 255, 255, 0.35);
        }

        .menu-input-readonly {
            background: rgba(0, 0, 0, 0.35);
            border-color: rgba(255, 255, 255, 0.15);
            color: rgba(255, 255, 255, 0.8);
            font-family: 'Courier New', monospace;
            font-weight: 500;
            letter-spacing: 1px;
        }

        /* Button Groups */
        .menu-button-group {
            display: flex;
            flex-direction: column;
            gap: 3px;
            margin: 0;
        }

        /* Map Selector Styles */
        .map-selector {
            margin: 15px 0;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .map-selector-label {
            font-size: 10px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 8px;
            letter-spacing: 1px;
            text-transform: uppercase;
            font-family: 'Rajdhani', sans-serif;
        }

        .map-options {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .map-option {
            width: 100px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }

        .map-option:hover {
            background: rgba(255, 255, 255, 0.06);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .map-option.selected {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.35);
            box-shadow: none;
        }

        .map-option-name {
            font-size: 11px;
            font-weight: 600;
            color: #fff;
            font-family: 'Rajdhani', sans-serif;
            letter-spacing: 1px;
        }

        /* Skin Selector Styles */
        .skin-selector {
            margin: 15px 0;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .skin-selector-label {
            font-size: 10px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 8px;
            letter-spacing: 1px;
            text-transform: uppercase;
            font-family: 'Rajdhani', sans-serif;
        }

        .skin-options {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .skin-option {
            width: 100px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }

        .skin-option:hover {
            background: rgba(255, 255, 255, 0.06);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .skin-option.selected {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.35);
            box-shadow: none;
        }

        .skin-option-icon {
            font-size: 24px;
            margin-bottom: 4px;
        }

        .skin-option-name {
            font-size: 11px;
            font-weight: 600;
            color: #fff;
            font-family: 'Rajdhani', sans-serif;
            letter-spacing: 1px;
        }

        .skin-option-desc {
            font-size: 9px;
            color: rgba(255, 255, 255, 0.5);
            font-family: 'Rajdhani', sans-serif;
        }

        /* ═══════════════════════════════════════════════════════════
           MUSIC PLAYER - Minimal Style
           ═══════════════════════════════════════════════════════════ */
        /* ═══════════════════════════════════════════════════════════
           MUSIC PLAYER - Ultra-Modern Minimal Design
           ═══════════════════════════════════════════════════════════ */
        .music-player {
            position: fixed;
            bottom: 16px;
            right: 16px;
            width: 220px;
            background: linear-gradient(145deg, rgba(18, 18, 24, 0.92) 0%, rgba(8, 8, 12, 0.95) 100%);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 14px;
            z-index: 10000;
            font-family: 'Inter', 'SF Pro Display', -apple-system, sans-serif;
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.45),
                0 0 0 0.5px rgba(255,255,255,0.03) inset,
                0 0 60px rgba(139, 92, 246, 0.08);
            overflow: hidden;
            user-select: none;
            -webkit-backdrop-filter: blur(24px) saturate(180%);
            backdrop-filter: blur(24px) saturate(180%);
            transition: all 0.32s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .music-player:hover {
            box-shadow:
                0 12px 40px rgba(0, 0, 0, 0.5),
                0 0 0 0.5px rgba(255,255,255,0.05) inset,
                0 0 80px rgba(139, 92, 246, 0.12);
            transform: translateY(-2px);
        }
        .music-player::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.12) 50%, transparent 100%);
            pointer-events: none;
        }
        .mp-artwork-section {
            position: relative;
            width: 100%;
            height: 90px;
            overflow: hidden;
            background: linear-gradient(135deg, #0f0f14 0%, #1a1a24 100%);
            transition: height 0.32s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .mp-artwork {
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0.75;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            filter: saturate(1.1);
        }
        .music-player.playing .mp-artwork {
            opacity: 0.95;
            transform: scale(1.03);
            filter: saturate(1.2);
        }
        .music-player.mp-switching .mp-artwork {
            opacity: 0.4;
            transform: scale(1.08);
            filter: blur(3px) saturate(0.8);
        }
        .mp-artwork-overlay {
            position: absolute;
            inset: 0;
            background: linear-gradient(0deg, rgba(8, 8, 12, 0.98) 0%, rgba(8, 8, 12, 0.6) 40%, transparent 80%);
            pointer-events: none;
        }
        .mp-track-info {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 10px 12px;
        }
        .mp-track-title {
            font-size: 12px;
            font-weight: 600;
            color: #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            letter-spacing: 0.3px;
            text-shadow: 0 1px 8px rgba(0,0,0,0.6);
            transition: all 0.25s ease;
            position: absolute;
            bottom: 10px;
            left: 12px;
            right: 12px;
        }
        .music-player.mp-compact .mp-track-title {
            position: static;
            font-size: 10px;
            font-weight: 600;
            text-shadow: none;
            text-align: center;
            margin-bottom: 4px;
            letter-spacing: 0;
            line-height: 1.2;
        }
        .mp-track-title.fading { opacity: 0.2; transform: translateY(-2px); }
        .music-player.mp-switching .mp-track-title { opacity: 0.25; }
        .mp-track-artist {
            font-size: 9px;
            color: rgba(255,255,255,0.4);
            margin-top: 2px;
            letter-spacing: 0.8px;
            text-transform: uppercase;
            font-weight: 500;
        }
        .music-player.mp-compact .mp-track-artist {
            display: none;
        }
        .mp-body {
            padding: 10px 12px 12px;
            background: linear-gradient(180deg, transparent 0%, rgba(139, 92, 246, 0.03) 100%);
            transition: padding 0.32s ease;
        }
        .mp-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        .mp-btn {
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 8px;
            background: rgba(255,255,255,0.04);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.18s cubic-bezier(0.4, 0, 0.2, 1);
            color: rgba(255,255,255,0.5);
            position: relative;
            overflow: hidden;
        }
        .mp-btn::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.2) 0%, rgba(236, 72, 153, 0.2) 100%);
            opacity: 0;
            transition: opacity 0.18s ease;
        }
        .mp-btn:hover {
            background: rgba(255,255,255,0.08);
            color: #fff;
            transform: scale(1.08);
        }
        .mp-btn:hover::before { opacity: 1; }
        .mp-btn:active { transform: scale(0.94); }
        .mp-btn svg { width: 13px; height: 13px; fill: currentColor; position: relative; z-index: 1; }
        .mp-btn.mp-play {
            width: 36px;
            height: 36px;
            background: linear-gradient(135deg, #8b5cf6 0%, #ec4899 50%, #f43f5e 100%);
            color: #fff;
            box-shadow:
                0 4px 16px rgba(139, 92, 246, 0.4),
                0 0 0 1px rgba(255,255,255,0.1) inset;
            border-radius: 10px;
        }
        .mp-btn.mp-play::before { display: none; }
        .mp-btn.mp-play:hover {
            transform: scale(1.1);
            box-shadow:
                0 6px 24px rgba(139, 92, 246, 0.55),
                0 0 0 1px rgba(255,255,255,0.15) inset;
        }
        .mp-btn.mp-play:active { transform: scale(0.96); }
        .mp-btn.mp-play svg { width: 15px; height: 15px; }
        .mp-btn.active {
            color: #a78bfa;
            background: rgba(139, 92, 246, 0.15);
        }
        .mp-btn.small { width: 24px; height: 24px; border-radius: 6px; }
        .mp-btn.small svg { width: 10px; height: 10px; }
        .mp-volume-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
            overflow: hidden;
            transition: all 0.25s ease;
            max-height: 60px;
        }
        .mp-vol-icon {
            color: rgba(255,255,255,0.4);
            display: flex;
            cursor: pointer;
            transition: color 0.15s ease;
        }
        .mp-vol-icon:hover { color: rgba(255,255,255,0.7); }
        .mp-vol-icon svg { width: 12px; height: 12px; fill: currentColor; }
        .mp-vol-icon.muted { color: #ec4899; }
        .mp-vol-slider-wrap {
            flex: 1;
            height: 4px;
            background: rgba(255,255,255,0.08);
            border-radius: 999px;
            position: relative;
            cursor: pointer;
            transition: height 0.15s ease;
        }
        .mp-vol-slider-wrap:hover { height: 6px; }
        .mp-vol-fill {
            height: 100%;
            background: linear-gradient(90deg, #8b5cf6, #ec4899);
            border-radius: 999px;
            width: 5%;
            transition: width 0.08s linear;
            position: relative;
        }
        .mp-vol-fill::after {
            content: '';
            position: absolute;
            right: -4px;
            top: 50%;
            transform: translateY(-50%) scale(0);
            width: 10px;
            height: 10px;
            background: #fff;
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4), 0 0 0 2px rgba(139, 92, 246, 0.3);
            transition: transform 0.15s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .mp-vol-slider-wrap:hover .mp-vol-fill::after { transform: translateY(-50%) scale(1); }
        .mp-vol-pct {
            font-size: 9px;
            color: rgba(255,255,255,0.3);
            width: 24px;
            text-align: right;
            font-family: 'SF Mono', 'Consolas', monospace;
            font-weight: 500;
        }
        .mp-visualizer {
            display: none;
            align-items: flex-end;
            justify-content: center;
            gap: 2px;
            height: 16px;
            margin-top: 10px;
            opacity: 0.3;
            transition: opacity 0.4s ease;
            overflow: hidden;
            max-height: 20px;
        }
        .music-player.playing .mp-visualizer { opacity: 0.9; }
        .mp-viz-bar {
            width: 2px;
            background: linear-gradient(0deg, #8b5cf6, #ec4899, #f43f5e);
            border-radius: 999px;
            transition: height 0.06s ease-out;
        }
        .mp-autoplay-prompt {
            position: absolute;
            inset: 0;
            background: rgba(8, 8, 12, 0.96);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 10px;
            z-index: 10;
            cursor: pointer;
            backdrop-filter: blur(8px);
        }
        .mp-autoplay-prompt:hover .mp-prompt-icon {
            transform: scale(1.12);
            box-shadow: 0 8px 30px rgba(139, 92, 246, 0.5);
        }
        .mp-prompt-icon {
            width: 44px;
            height: 44px;
            background: linear-gradient(135deg, #8b5cf6, #ec4899);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 20px rgba(139, 92, 246, 0.4);
        }
        .mp-prompt-icon svg { width: 18px; height: 18px; fill: #fff; }
        .mp-prompt-text {
            font-size: 10px;
            color: rgba(255,255,255,0.5);
            letter-spacing: 1.5px;
            font-weight: 500;
        }
        .mp-autoplay-prompt.hidden { display: none; }

        /* Progress Row - Hidden by default (expanded mode) */
        .mp-progress-row {
            display: none;
            align-items: center;
            gap: 6px;
            margin-top: 8px;
            position: relative;
            z-index: 1;
        }
        .mp-time {
            font-size: 9px;
            color: rgba(255,255,255,0.35);
            width: 28px;
            text-align: center;
            font-family: 'SF Mono', 'Consolas', monospace;
            font-weight: 500;
            letter-spacing: -0.3px;
        }
        .mp-progress-bar {
            flex: 1;
            height: 3px;
            background: rgba(255,255,255,0.1);
            border-radius: 999px;
            overflow: visible;
            cursor: pointer;
            position: relative;
            transition: all 0.18s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .mp-progress-bar:hover {
            height: 5px;
            background: rgba(255,255,255,0.12);
        }
        .mp-progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #8b5cf6, #ec4899);
            border-radius: 999px;
            position: relative;
            transition: width 0.06s linear;
            box-shadow: 0 0 8px rgba(139, 92, 246, 0.4);
        }
        .mp-progress-fill::after {
            content: '';
            position: absolute;
            right: -5px;
            top: 50%;
            transform: translateY(-50%) scale(0);
            width: 10px;
            height: 10px;
            background: #fff;
            border-radius: 50%;
            box-shadow: 0 1px 6px rgba(0,0,0,0.4), 0 0 0 2px rgba(139, 92, 246, 0.3);
            transition: transform 0.18s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .mp-progress-bar:hover .mp-progress-fill::after {
            transform: translateY(-50%) scale(1);
        }

        /* ═══ COMPACT / MINIMIZED MODE ═══ */
        .music-player.mp-compact {
            width: 152px;
            border-radius: 12px;
        }
        .music-player.mp-compact .mp-artwork-section {
            height: 60px;
            background: transparent;
            padding: 4px 0;
            overflow: visible;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .music-player.mp-compact .mp-artwork {
            display: block;
            width: 48px;
            height: 48px;
            object-fit: cover;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        .music-player.mp-compact .mp-artwork-overlay {
            display: none;
        }
        .music-player.mp-compact .mp-track-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2px;
            margin-bottom: 6px;
            width: 100%;
        }
        .music-player.mp-compact .mp-body {
            padding: 6px 8px 6px;
            background: transparent;
        }
        .music-player.mp-compact .mp-controls {
            gap: 3px;
            justify-content: center;
            margin-bottom: 4px;
        }
        .music-player.mp-compact #mpShuffle,
        .music-player.mp-compact #mpRepeat {
            display: none;
        }
        .music-player.mp-compact #mpPrev,
        .music-player.mp-compact #mpNext {
            display: inline-flex;
        }
        .music-player.mp-compact .mp-btn {
            width: 24px;
            height: 24px;
            border-radius: 6px;
        }
        .music-player.mp-compact .mp-btn svg { width: 11px; height: 11px; }
        .music-player.mp-compact .mp-btn.mp-play {
            width: 32px;
            height: 32px;
            border-radius: 8px;
        }
        .music-player.mp-compact .mp-btn.mp-play svg { width: 13px; height: 13px; }
        .music-player.mp-compact .mp-volume-row,
        .music-player.mp-compact .mp-progress-row {
            opacity: 0;
            max-height: 0;
            margin-top: 0;
            pointer-events: none;
            display: none;
        }
        .music-player.mp-compact .mp-visualizer {
            display: flex;
            margin-top: 2px;
            height: 14px;
            opacity: 0;
            gap: 1.5px;
        }
        .music-player.mp-compact.playing .mp-visualizer { opacity: 0.9; }

        /* Emote Button */
        .emote-button {
            display: none;
            margin-top: 10px;
            padding: 10px 20px;
            background: linear-gradient(135deg, rgba(255, 100, 200, 0.3), rgba(200, 50, 255, 0.3));
            border: 2px solid rgba(255, 100, 200, 0.5);
            border-radius: 8px;
            color: #fff;
            font-size: 14px;
            font-weight: 600;
            font-family: 'Rajdhani', sans-serif;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        .emote-button:hover {
            background: linear-gradient(135deg, rgba(255, 100, 200, 0.5), rgba(200, 50, 255, 0.5));
            border-color: rgba(255, 100, 200, 0.8);
            box-shadow: 0 0 20px rgba(255, 100, 200, 0.4);
            transform: scale(1.05);
        }

        .emote-button.playing {
            background: linear-gradient(135deg, rgba(255, 50, 100, 0.5), rgba(255, 100, 50, 0.5));
            border-color: #ff6464;
            animation: pulse-emote 0.5s ease-in-out infinite;
        }

        @keyframes pulse-emote {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        .emote-button.visible {
            display: inline-block;
        }

        /* Voice Chat / Mic Button */
        #voiceChatContainer {
            position: fixed;
            bottom: 120px;
            left: 20px;
            z-index: 1000;
            display: none;
        }

        #voiceChatContainer.active {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 10px;
        }

        #micButton {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(40, 40, 50, 0.95), rgba(25, 25, 35, 0.98));
            border: 3px solid rgba(100, 100, 120, 0.4);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 6px 25px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        #micButton:hover {
            transform: scale(1.15);
            border-color: rgba(100, 200, 255, 0.7);
            box-shadow: 0 8px 30px rgba(100, 200, 255, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }

        #micButton.muted {
            background: linear-gradient(135deg, rgba(100, 30, 30, 0.95), rgba(70, 15, 15, 0.98));
            border-color: rgba(255, 80, 80, 0.7);
            box-shadow: 0 6px 25px rgba(255, 50, 50, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        #micButton.speaking {
            background: linear-gradient(135deg, rgba(30, 100, 30, 0.95), rgba(15, 70, 15, 0.98));
            border-color: rgba(80, 255, 80, 0.9);
            box-shadow: 0 0 30px rgba(80, 255, 80, 0.5), 0 0 60px rgba(80, 255, 80, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.15);
            animation: pulse-mic 0.8s ease-in-out infinite;
        }

        @keyframes pulse-mic {

            0%,
            100% {
                transform: scale(1);
                box-shadow: 0 0 30px rgba(80, 255, 80, 0.5), 0 0 60px rgba(80, 255, 80, 0.2);
            }

            50% {
                transform: scale(1.08);
                box-shadow: 0 0 40px rgba(80, 255, 80, 0.7), 0 0 80px rgba(80, 255, 80, 0.3);
            }
        }

        #micButton svg {
            width: 28px;
            height: 28px;
            fill: white;
            transition: all 0.3s ease;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }

        #micButton.muted svg {
            fill: rgba(255, 120, 120, 1);
        }

        #micButton.speaking svg {
            fill: rgba(120, 255, 120, 1);
            filter: drop-shadow(0 0 8px rgba(80, 255, 80, 0.8));
        }

        #voiceStatus {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.8);
            font-family: 'Rajdhani', sans-serif;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            padding: 6px 12px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
        }

        #voiceStatus.speaking {
            color: rgba(100, 255, 100, 1);
            background: rgba(30, 80, 30, 0.8);
            border-color: rgba(80, 255, 80, 0.4);
            box-shadow: 0 0 15px rgba(80, 255, 80, 0.3);
        }

        #voiceStatus.muted {
            color: rgba(255, 120, 120, 0.9);
            background: rgba(80, 30, 30, 0.7);
            border-color: rgba(255, 80, 80, 0.3);
        }

        /* Speaking indicator for opponent - Enhanced visibility */
        #opponentSpeaking {
            position: fixed;
            top: 100px;
            right: 30px;
            display: none;
            align-items: center;
            gap: 12px;
            padding: 12px 18px;
            background: linear-gradient(135deg, rgba(30, 90, 30, 0.95), rgba(20, 70, 20, 0.98));
            border: 2px solid rgba(80, 255, 80, 0.6);
            border-radius: 12px;
            z-index: 1000;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4), 0 0 40px rgba(80, 255, 80, 0.3);
            backdrop-filter: blur(10px);
            transform: translateX(120%);
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease;
            opacity: 0;
        }

        #opponentSpeaking.visible {
            display: flex;
            transform: translateX(0);
            opacity: 1;
            animation: speakerPulse 1.5s ease-in-out infinite;
        }

        @keyframes speakerPulse {

            0%,
            100% {
                box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4), 0 0 40px rgba(80, 255, 80, 0.3);
            }

            50% {
                box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4), 0 0 60px rgba(80, 255, 80, 0.5);
            }
        }

        #opponentSpeaking .speaker-icon {
            width: 28px;
            height: 28px;
            fill: rgba(100, 255, 100, 1);
            filter: drop-shadow(0 0 8px rgba(80, 255, 80, 0.8));
            animation: iconPulse 0.6s ease-in-out infinite;
        }

        @keyframes iconPulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.15);
            }
        }

        #opponentSpeaking .speaker-name {
            font-size: 14px;
            color: rgba(255, 255, 255, 1);
            font-family: 'Rajdhani', sans-serif;
            font-weight: 700;
            letter-spacing: 1px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        #opponentSpeaking .voice-distance {
            font-size: 10px;
            color: rgba(180, 255, 180, 0.8);
            font-family: 'Rajdhani', sans-serif;
            margin-left: auto;
            padding-left: 10px;
            border-left: 1px solid rgba(80, 255, 80, 0.3);
        }

        .map-option-desc {
            font-size: 8px;
            color: rgba(255, 255, 255, 0.5);
            margin-top: 4px;
        }

        /* Info Text */
        .menu-info-text {
            font-size: 9px;
            color: rgba(255, 255, 255, 0.45);
            margin-top: 4px;
            letter-spacing: 0.2px;
        }

        .menu-label {
            font-size: 9px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 5px;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            font-family: 'Inter', 'Segoe UI', -apple-system, sans-serif;
        }

        .controls {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid rgba(255, 255, 255, 0.08);
            font-size: 9px;
            text-align: left;
            color: rgba(255, 255, 255, 0.55);
            line-height: 1.4;
            letter-spacing: 0.2px;
            font-family: 'Inter', 'Segoe UI', -apple-system, sans-serif;
        }

        .controls strong {
            display: block;
            font-size: 8px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 5px;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        /* Keep spacing, let .menu-button handle styling */
        #keybindsButton {
            margin-top: 10px;
        }

        /* Simple Options/Keybinds Modal */
        #keybindsModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.75);
            display: none;
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        #keybindsModal.active {
            display: flex;
        }

        .keybinds-container {
            background: rgba(20, 20, 20, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            padding: 20px;
            max-height: 85vh;
            overflow: hidden;
            width: 90%;
            max-width: 480px;
            color: white;
        }

        .keybinds-header {
            margin-bottom: 10px;
        }

        .keybinds-container h2 {
            text-align: left;
            margin: 0;
            padding: 0;
            color: #ffffff;
            font-family: 'Rajdhani', 'Segoe UI', sans-serif;
            font-size: 18px;
            font-weight: 700;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .keybinds-subtitle {
            margin: 6px 0 0;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            letter-spacing: 1px;
            text-transform: uppercase;
            font-weight: 500;
        }

        #keybindsList {
            padding: 10px 0;
            max-height: 55vh;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.3) transparent;
        }

        #keybindsList::-webkit-scrollbar {
            width: 8px;
        }

        #keybindsList::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }

        #keybindsList::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            transition: background 0.2s ease;
        }

        #keybindsList::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        .keybind-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        }

        .keybind-label {
            flex: 1;
            font-family: 'Rajdhani', sans-serif;
            font-weight: 600;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.85);
            letter-spacing: 0.5px;
        }

        .keybind-input {
            background: transparent;
            color: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.25);
            padding: 8px 12px;
            border-radius: 2px;
            cursor: pointer;
            min-width: 90px;
            text-align: center;
            font-family: 'Rajdhani', monospace;
            font-weight: 700;
            font-size: 13px;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .keybind-input:hover {
            border-color: rgba(255, 255, 255, 0.5);
        }

        .keybind-input.listening {
            background: rgba(255, 255, 255, 0.08);
            border-style: dashed;
        }

        .keybinds-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 12px;
        }

        .keybinds-buttons button {
            padding: 10px 16px;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.25);
            border-radius: 2px;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-weight: 700;
            font-size: 14px;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.9);
        }

        .keybinds-buttons button:hover {
            border-color: rgba(255, 255, 255, 0.5);
            color: #fff;
        }

        #gameOver {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(12, 12, 15, 0.98) 0%, rgba(8, 8, 10, 0.99) 100%);
            padding: 48px 56px;
            border-radius: 1px;
            color: white;
            text-align: center;
            z-index: 1000;
            display: none;
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-top: 1px solid rgba(255, 255, 255, 0.12);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
            font-family: 'Inter', 'Segoe UI', -apple-system, sans-serif;
        }

        #gameOver h2 {
            font-size: 32px;
            margin-bottom: 16px;
            font-weight: 600;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: #ffffff;
        }

        #gameOver p {
            font-size: 13px;
            margin-bottom: 24px;
            color: rgba(255, 255, 255, 0.65);
            letter-spacing: 0.5px;
        }

        #gameOver button {
            padding: 14px 32px;
            font-size: 12px;
            font-weight: 500;
            letter-spacing: 1px;
            text-transform: uppercase;
            background: rgba(255, 255, 255, 0.08);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.25);
            border-top: 1px solid rgba(255, 255, 255, 0.25);
            border-radius: 1px;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: 'Inter', 'Segoe UI', -apple-system, sans-serif;
        }

        #gameOver button:hover {
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(255, 255, 255, 0.35);
            transform: translateY(-1px);
        }

        #gameOver button:active {
            transform: translateY(0);
        }

        #hitMarker {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 24px;
            height: 24px;
            pointer-events: none;
            z-index: 101;
            display: none;
            background-image: url('bodyheadshots/hitmark.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        .hit-line {
            display: none;
            /* Hide old hit lines, using image now */
        }

        #damageOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 30%, rgba(255, 0, 0, 0.3) 100%);
            pointer-events: none;
            z-index: 99;
            opacity: 0;
            transition: opacity 0.3s;
        }

        /* ========== BF1-STYLE HIT FEED HUD ========== */
        .bf1-feed-hud {
            position: fixed;
            top: 72%;
            left: 51%;
            display: grid;
            grid-template-columns: auto auto;
            gap: 10px;
            align-items: center;
            transform: scale(0.65);
            transform-origin: top left;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            z-index: 200;
            font-family: 'Rajdhani', 'Jost', sans-serif;
        }

        .bf1-feed-list {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            text-align: right;
            gap: 2px;
        }

        .bf1-feed-item {
            color: rgba(255, 255, 255, 0.95);
            font-weight: 500;
            font-size: 12px;
            letter-spacing: 1px;
            text-transform: uppercase;
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 8px;
            min-width: 120px;
            transform: translateY(8px);
            opacity: 0;
            animation: bf1-item-enter 0.2s cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
        }

        .bf1-feed-val {
            font-weight: 300;
            margin-left: 8px;
            min-width: 25px;
        }

        /* BF1 Event Colors */
        .bf1-feed-item.is-crit { color: #ff3333 !important; }
        .bf1-feed-item.is-kill { color: #d13e3e !important; }
        .bf1-feed-item.is-crit .bf1-feed-val,
        .bf1-feed-item.is-kill .bf1-feed-val { font-weight: 700; }

        @keyframes bf1-item-enter {
            to { transform: translateY(0); opacity: 1; }
        }

        .bf1-feed-total {
            font-weight: 200;
            font-size: 32px;
            color: #ffffff;
            letter-spacing: 0px;
            border-left: 1px solid rgba(255,255,255,0.25);
            padding-left: 12px;
            display: flex;
            align-items: center;
            height: 100%;
        }

        .bf1-feed-avatar {
            width: 32px;
            height: 32px;
            border-radius: 4px;
            object-fit: cover;
            border: 1px solid rgba(255, 255, 255, 0.3);
            flex-shrink: 0;
        }

        /* ========== AI HIT ME BUTTON ========== */
        #aiHitMeBtn {
            position: fixed;
            bottom: 100px;
            right: 20px;
            z-index: 99999;
            background: linear-gradient(135deg, #8B0000 0%, #FF4444 100%);
            border: 2px solid #FF6666;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
            box-shadow: 0 4px 15px rgba(255, 0, 0, 0.3);
            display: none;
        }

        #aiHitMeBtn:hover {
            background: linear-gradient(135deg, #AA0000 0%, #FF6666 100%);
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(255, 0, 0, 0.5);
        }

        #aiHitMeBtn:active {
            transform: scale(0.95);
        }

        #aiHitMeBtn.visible {
            display: block;
        }

        #deathScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: background 0.5s;
        }

        #deathScreen h1 {
            font-size: 72px;
            color: #ff0000;
            text-shadow: 0 0 20px rgba(255, 0, 0, 0.8);
            opacity: 0;
            transition: opacity 0.5s;
        }

        #killerInfo {
            position: fixed;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ff4444;
            border-radius: 10px;
            padding: 15px 30px;
            color: white;
            font-family: 'Arial', sans-serif;
            z-index: 101;
            display: none;
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.5);
            animation: slideUp 0.5s ease-out;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        #killerInfo .killer-name {
            font-size: 24px;
            font-weight: bold;
            color: #ff4444;
            margin-bottom: 10px;
            text-align: center;
        }

        #killerInfo .killer-stats {
            display: flex;
            gap: 30px;
            justify-content: center;
            align-items: center;
        }

        #killerInfo .stat-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #killerInfo .stat-label {
            color: #aaa;
            font-size: 14px;
        }

        #killerInfo .stat-value {
            color: #fff;
            font-size: 18px;
            font-weight: bold;
        }

        #killerInfo .hp-bar {
            width: 100px;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
        }

        #killerInfo .hp-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            transition: width 0.3s;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.6);
        }

        #killerInfo .weapon-icon {
            color: #ffa726;
            font-size: 20px;
        }

        /* Speaker icon overlay */
        .speaker-icon {
            position: fixed;
            width: 80px;
            height: 80px;
            z-index: 120;
            pointer-events: none;
            display: none !important;
            filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.8)) drop-shadow(0 0 20px rgba(255, 255, 0, 0.6));
            transform: scale(1.2);
            animation: speakerPulse 2s ease-in-out infinite alternate;
        }

        @keyframes speakerPulse {
            0% {
                filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.8)) drop-shadow(0 0 20px rgba(255, 255, 0, 0.6));
            }

            100% {
                filter: drop-shadow(0 0 15px rgba(255, 255, 255, 1)) drop-shadow(0 0 25px rgba(255, 255, 0, 0.8));
            }
        }

        /* ==================== LOADING SCREEN STYLES ==================== */
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #0a0a0a;
            z-index: 999999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: 'Rajdhani', 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        #loadingScreen.fade-out {
            animation: loadingFadeOut 0.5s ease-out forwards;
        }

        @keyframes loadingFadeOut {
            0% {
                opacity: 1;
            }

            100% {
                opacity: 0;
                visibility: hidden;
            }
        }

        .loading-bg-lines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            opacity: 0.03;
        }

        .loading-bg-lines::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 200%;
            height: 200%;
            background: repeating-linear-gradient(0deg,
                    transparent,
                    transparent 2px,
                    rgba(255, 255, 255, 0.5) 2px,
                    rgba(255, 255, 255, 0.5) 4px);
            animation: scanlines 8s linear infinite;
        }

        @keyframes scanlines {
            0% {
                transform: translateY(0);
            }

            100% {
                transform: translateY(-50%);
            }
        }

        .loading-content {
            position: relative;
            z-index: 2;
            text-align: center;
            width: 100%;
            max-width: 600px;
            padding: 0 40px;
        }

        .loading-title {
            font-size: 48px;
            font-weight: 700;
            color: #fff;
            letter-spacing: 8px;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .loading-subtitle {
            font-size: 12px;
            color: #666;
            letter-spacing: 4px;
            text-transform: uppercase;
            margin-bottom: 60px;
        }

        .loading-bar-container {
            width: 100%;
            height: 2px;
            background: #1a1a1a;
            position: relative;
            margin-bottom: 20px;
        }

        .loading-bar {
            height: 100%;
            width: 0%;
            background: #fff;
            transition: width 0.1s linear;
            position: relative;
        }

        .loading-bar::after {
            content: '';
            position: absolute;
            right: 0;
            top: -4px;
            width: 2px;
            height: 10px;
            background: #fff;
            box-shadow: 0 0 10px #fff;
        }

        .loading-percent {
            position: absolute;
            right: 0;
            top: -25px;
            font-size: 14px;
            color: #fff;
            font-weight: 600;
            letter-spacing: 2px;
        }

        .loading-status {
            font-size: 11px;
            color: #444;
            letter-spacing: 2px;
            text-transform: uppercase;
            height: 20px;
            margin-bottom: 40px;
        }

        .loading-tips {
            position: absolute;
            bottom: 60px;
            left: 0;
            width: 100%;
            text-align: center;
            padding: 0 40px;
        }

        .loading-tip-label {
            font-size: 10px;
            color: #333;
            letter-spacing: 3px;
            text-transform: uppercase;
            margin-bottom: 10px;
        }

        .loading-tip-text {
            font-size: 13px;
            color: #555;
            max-width: 500px;
            margin: 0 auto;
            line-height: 1.6;
        }

        .loading-corner {
            position: absolute;
            width: 30px;
            height: 30px;
            border-color: #222;
            border-style: solid;
        }

        .loading-corner.tl {
            top: 30px;
            left: 30px;
            border-width: 2px 0 0 2px;
        }

        .loading-corner.tr {
            top: 30px;
            right: 30px;
            border-width: 2px 2px 0 0;
        }

        .loading-corner.bl {
            bottom: 30px;
            left: 30px;
            border-width: 0 0 2px 2px;
        }

        .loading-corner.br {
            bottom: 30px;
            right: 30px;
            border-width: 0 2px 2px 0;
        }

        .loading-version {
            position: absolute;
            bottom: 30px;
            right: 40px;
            font-size: 10px;
            color: #333;
            letter-spacing: 2px;
        }

        .loading-ammo {
            position: absolute;
            bottom: 30px;
            left: 40px;
            font-size: 10px;
            color: #333;
            letter-spacing: 1px;
            font-family: 'Courier New', monospace;
        }
    </style>
</head>

<body>
    <!-- Loading Screen -->
    <div id="loadingScreen">
        <div class="loading-bg-lines"></div>
        <div class="loading-corner tl"></div>
        <div class="loading-corner tr"></div>
        <div class="loading-corner bl"></div>
        <div class="loading-corner br"></div>

        <div class="loading-content">
            <div class="loading-bar-container">
                <div class="loading-bar" id="loadingBar"></div>
                <div class="loading-percent" id="loadingPercent">0%</div>
            </div>

            <div class="loading-status" id="loadingStatus">INITIALIZING...</div>
        </div>

        <div class="loading-tips">
            <div class="loading-tip-label">Intel</div>
            <div class="loading-tip-text" id="loadingTip">Check your corners. The enemy could be anywhere.</div>
        </div>

        <div class="loading-ammo" id="loadingAmmo">30 / 90</div>
        <div class="loading-version">BUILD 2.4.1</div>
    </div>

    <canvas id="menuCanvas"></canvas>

    <!-- Level Info Tooltip (appears on hover) -->
    <div id="levelTooltip">
        <div class="tooltip-title">STATS</div>
        <div class="tooltip-row"><span>Level</span><span id="tooltipCurrentLevel">1</span></div>
        <div class="tooltip-row"><span>XP</span><span id="tooltipXpProgress">0 / 100</span></div>
        <div class="tooltip-row"><span>Next</span><span id="tooltipXpNeeded">100 XP</span></div>
        <div class="tooltip-progress">
            <div class="tooltip-progress-bar" id="tooltipProgressBar" style="width: 0%;"></div>
        </div>
        <div class="tooltip-row"><span>Kills</span><span id="tooltipKills">0</span></div>
        <div class="tooltip-row"><span>Wins</span><span id="tooltipWins">0</span></div>
    </div>

    <!-- Invisible hover area for level ring (positioned by JS) -->
    <div id="levelHoverArea"
        style="position: fixed; width: 60px; height: 60px; border-radius: 50%; cursor: pointer; z-index: 1000; pointer-events: auto; display: none;">
    </div>

    <!-- Fullscreen toggle button (top right corner) -->
    <button id="fullscreenToggle"
        style="position: fixed; top: 15px; right: 15px; z-index: 99999; background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-family: 'Rajdhani', sans-serif; font-size: 14px; transition: all 0.2s; backdrop-filter: blur(5px);"
        onmouseover="this.style.background='rgba(255,255,255,0.2)'"
        onmouseout="this.style.background='rgba(0,0,0,0.5)'">
        <span id="fullscreenToggleText">⛶ Fullscreen</span>
    </button>

    <!-- In-Game Level Display (Old - hidden) -->
    <div id="levelDisplay" style="display: none;">
        <div class="level-badge">
            <span class="level-icon">⭐</span>
            <span class="level-number" id="hudLevelNumber">1</span>
        </div>
        <div class="xp-bar-container">
            <div class="xp-bar" id="hudXpBar" style="width: 0%;"></div>
        </div>
        <span class="xp-text" id="hudXpText">0 / 100 XP</span>
    </div>

    <!-- Minecraft XP Bar HUD -->
    <div id="mcXpHud">
        <div class="mc-hud-wrapper">
            <div class="mc-level-num" id="mcLevelNum">1</div>
            <div class="mc-xp-bar-core">
                <div class="mc-xp-bar-fill" id="mcXpFill"></div>
            </div>
        </div>
    </div>

    <!-- Early fullscreen function definition -->
    <script>
        var wasInFullscreen = false;
        function toggleFullscreen() {
            if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) {
                wasInFullscreen = true;
                var elem = document.documentElement;
                if (elem.requestFullscreen) elem.requestFullscreen();
                else if (elem.webkitRequestFullscreen) elem.webkitRequestFullscreen();
                else if (elem.msRequestFullscreen) elem.msRequestFullscreen();
            } else {
                wasInFullscreen = false;
                if (document.exitFullscreen) document.exitFullscreen();
                else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
                else if (document.msExitFullscreen) document.msExitFullscreen();
            }
        }
        document.getElementById('fullscreenToggle').addEventListener('click', toggleFullscreen);

        // Update button text on fullscreen change
        function updateFullscreenText() {
            var isFS = document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
            var txt = document.getElementById('fullscreenToggleText');
            if (txt) txt.textContent = isFS ? '⛶ Exit' : '⛶ Fullscreen';
            if (isFS) wasInFullscreen = true;
        }
        document.addEventListener('fullscreenchange', updateFullscreenText);
        document.addEventListener('webkitfullscreenchange', updateFullscreenText);
        document.addEventListener('msfullscreenchange', updateFullscreenText);
    </script>

    <div id="startScreen">
        
        <!-- HIDDEN LOGIC BUTTONS (Proxies for existing game logic) -->
        <div style="display: none;">
            <!-- These maintain original IDs so game logic works -->
            <button id="hostButton">LOGIC_HOST</button>
            <button id="joinButton">LOGIC_JOIN</button>
            <button id="host2v2Button">LOGIC_HOST2V2</button>
            <button id="join2v2Button">LOGIC_JOIN2V2</button>
            <button id="startButton">LOGIC_START_AI</button>
            
            <input type="file" id="profilePictureInput" accept="image/*">
        </div>

        <div class="menu-content">
            <div style="margin-bottom: 20px;">
                <input type="text" id="usernameInput" placeholder="SOLDIER NAME" maxlength="12" class="menu-input"
                    style="background: transparent; border: none; border-bottom: 2px solid rgba(255,255,255,0.3); font-size: 18px; padding: 10px 0; width: 100%; color: white; font-family: 'Rajdhani', sans-serif; letter-spacing: 2px;">
            </div>

            <!-- VISIBLE UI BUTTONS WITH INLINE SUBMENUS -->
            <div class="menu-button-group" id="mainMenuButtons">
                
                <!-- PLAY BUTTON WITH MAP SUBMENU -->
                <button class="menu-button" onclick="toggleSubmenu('playSubmenu')">PLAY</button>
                <div id="playSubmenu" class="inline-submenu" style="display: none;">
                    <div class="submenu-label">SELECT MAP:</div>
                    <button class="submenu-btn" onclick="setMapChoice('default')">WAREHOUSE</button>
                    <button class="submenu-btn" onclick="setMapChoice('map1')">ARENA</button>
                    <div class="submenu-label" style="margin-top: 10px;">MODE:</div>
                    <button class="submenu-btn" onclick="launchMode('host')">1v1 HOST</button>
                    <button class="submenu-btn" onclick="launchMode('join')">JOIN 1v1</button>
                    <button class="submenu-btn" onclick="launchMode('host2')">2v2 HOST</button>
                    <button class="submenu-btn" onclick="launchMode('join2')">JOIN 2v2</button>
                    <button class="submenu-btn" onclick="launchMode('ai')">VS AI</button>
                </div>
                
                <!-- LOCKER BUTTON WITH SKIN SUBMENU -->
                <button class="menu-button" onclick="toggleSubmenu('lockerSubmenu')">LOCKER</button>
                <div id="lockerSubmenu" class="inline-submenu" style="display: none;">
                    <div class="submenu-label">SELECT SKIN:</div>
                    <button class="submenu-btn" onclick="pickSkin('soldier')">SOLDIER</button>
                    <button class="submenu-btn" onclick="pickSkin('briefcase')">EXECUTIVE</button>
                    <button class="submenu-btn" onclick="pickSkin('skeleton')">SKELETON</button>
                    <button class="submenu-btn" onclick="pickSkin('zombie')">ZOMBIE</button>
                    <button class="submenu-btn" onclick="playEmote()" style="margin-top: 10px;">DANCE</button>
                </div>
                
                <button id="keybindsButton" onclick="openKeybindsModal()" class="menu-button">OPTIONS</button>
            </div>

            <div id="multiplayerSetup"
                style="display: none; margin-top: 20px; border-left: 2px solid rgba(255,255,255,0.3); padding-left: 20px;">
                <div id="hostInfo" style="display: none;">
                    <div class="menu-label"
                        style="color: rgba(255,255,255,0.6); font-family: 'Rajdhani', sans-serif; font-size: 12px;">SERVER ID</div>
                    <input type="text" id="roomId" readonly class="menu-input menu-input-readonly"
                        style="background: transparent; border: none; font-size: 14px; letter-spacing: 1.5px; color: white; font-family: 'Rajdhani', sans-serif; padding: 5px 0; word-break: break-all;">
                    <button id="startGameButton" class="menu-button" style="margin-top: 10px;">LAUNCH</button>
                </div>
                <div id="joinInfo" style="display: none;">
                    <div class="menu-label"
                        style="color: rgba(255,255,255,0.6); font-family: 'Rajdhani', sans-serif; font-size: 12px;">ENTER SERVER ID
                    </div>
                    <input type="text" id="joinRoomId" placeholder="SERVER ID" class="menu-input"
                        style="background: transparent; border: none; border-bottom: 1px solid rgba(255,255,255,0.3); font-size: 14px; letter-spacing: 1.5px; color: white; margin-bottom: 10px; font-family: 'Rajdhani', sans-serif;">
                    <div class="menu-button-group">
                        <button id="connectButton" class="menu-button">CONNECT</button>
                        <button id="cancelButton" class="menu-button" onclick="showMainMenu()">BACK</button>
                    </div>
                </div>
            </div>

            <!-- Separate Status Display -->
            <div id="waitingText"
                style="display: none; color: rgba(255, 255, 255, 0.6); font-size: 12px; margin-top: 20px; font-family: 'Rajdhani', sans-serif; border-top: 1px solid rgba(255, 255, 255, 0.2); padding-top: 15px;">
                WAITING FOR OPPONENT...</div>

            <div class="controls" style="display: none;">
                <strong>CONTROLS:</strong><br>
                ZQSD - Move | Mouse - Look | Left Click - Shoot | R - Reload<br>
                1, 2, 3 - Switch Weapons | F - Toggle DOF | ESC - Pause<br>
            </div>
            
        </div>

    </div>
    
    <!-- INLINE SUBMENU STYLES -->
    <style>
        #startScreen {
            padding-left: 400px !important;
        }
        
        .inline-submenu {
            padding: 8px 0 8px 15px;
            border-left: 2px solid rgba(255,255,255,0.3);
            margin: 5px 0 10px 10px;
        }
        
        .submenu-label {
            font-family: 'Rajdhani', sans-serif;
            font-size: 11px;
            color: rgba(255,255,255,0.5);
            letter-spacing: 1px;
            margin-bottom: 5px;
        }
        
        .submenu-btn {
            display: block;
            width: 100%;
            text-align: left;
            background: transparent;
            border: none;
            color: rgba(255,255,255,0.8);
            font-family: 'Rajdhani', sans-serif;
            font-size: 14px;
            padding: 6px 0;
            cursor: pointer;
            letter-spacing: 1px;
        }
        .submenu-btn:hover {
            color: #fff;
        }
        .submenu-btn.selected {
            color: #fff;
            text-decoration: underline;
        }
    </style>
    
    <script>
        // INLINE SUBMENU LOGIC
        let selectedMapChoice = 'default';
        
        function toggleSubmenu(id) {
            const el = document.getElementById(id);
            const isOpen = el.style.display !== 'none';
            // Close all submenus first
            document.querySelectorAll('.inline-submenu').forEach(s => s.style.display = 'none');
            // Toggle the clicked one
            if (!isOpen) el.style.display = 'block';
        }
        
        function setMapChoice(mapName) {
            selectedMapChoice = mapName;
            if(window.selectMap) window.selectMap(mapName);
            // Visual feedback
            document.querySelectorAll('#playSubmenu .submenu-btn').forEach(b => b.classList.remove('selected'));
            event.target.classList.add('selected');
        }
        
        function launchMode(mode) {
            // Apply selected map first
            if(window.selectMap) window.selectMap(selectedMapChoice);
            
            if (mode === 'ai') {
                document.getElementById('startButton').click();
            } else if (mode === 'host') {
                document.getElementById('hostButton').click();
            } else if (mode === 'host2') {
                document.getElementById('host2v2Button').click();
            } else if (mode === 'join') {
                document.getElementById('joinButton').click();
            } else if (mode === 'join2') {
                document.getElementById('join2v2Button').click();
            }
        }
        
        function pickSkin(skinName) {
            if(window.selectSkin) window.selectSkin(skinName);
            // Visual feedback
            document.querySelectorAll('#lockerSubmenu .submenu-btn').forEach(b => b.classList.remove('selected'));
            event.target.classList.add('selected');
        }
    </script>

    <!-- MUSIC PLAYER -->
    <div id="musicPlayer" class="music-player">
        <div class="mp-autoplay-prompt" id="mpAutoplayPrompt">
            <div class="mp-prompt-icon"><svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg></div>
            <span class="mp-prompt-text">CLICK TO PLAY</span>
        </div>
        <div class="mp-artwork-section">
            <img class="mp-artwork" id="mpArtwork" src="songs/bigx.jpg" alt="">
            <div class="mp-artwork-overlay"></div>
            <div class="mp-track-info">
                <div class="mp-track-title" id="mpTrackTitle">Loading...</div>
                <div class="mp-track-artist"></div>
            </div>
        </div>
        <div class="mp-body">
            <div class="mp-controls">
                <button class="mp-btn small" id="mpShuffle" title="Shuffle"><svg viewBox="0 0 24 24"><path d="M10.59 9.17L5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4h-5.5zm.33 9.41l-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04-3.13-3.13z"/></svg></button>
                <button class="mp-btn" id="mpPrev" title="Previous"><svg viewBox="0 0 24 24"><path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/></svg></button>
                <button class="mp-btn mp-play" id="mpPlayPause" title="Play"><svg viewBox="0 0 24 24" id="mpPlayIcon"><path d="M8 5v14l11-7z"/></svg></button>
                <button class="mp-btn" id="mpNext" title="Next"><svg viewBox="0 0 24 24"><path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/></svg></button>
                <button class="mp-btn small" id="mpRepeat" title="Repeat"><svg viewBox="0 0 24 24"><path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z"/></svg></button>
            </div>
            <div class="mp-progress-row" id="mpProgressRow">
                <div class="mp-time" id="mpTimeCurrent">0:00</div>
                <div class="mp-progress-bar" id="mpProgressBar"><div class="mp-progress-fill" id="mpProgressFill"></div></div>
                <div class="mp-time" id="mpTimeTotal">0:00</div>
            </div>
            <div class="mp-volume-row">
                <div class="mp-vol-icon" id="mpVolIcon"><svg viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg></div>
                <div class="mp-vol-slider-wrap" id="mpVolSlider"><div class="mp-vol-fill" id="mpVolFill"></div></div>
                <span class="mp-vol-pct" id="mpVolPct">5%</span>
            </div>
            <div class="mp-visualizer" id="mpVisualizer"></div>
        </div>
    </div>

    <!-- TELEMETRY BAR - Professional Stats Ribbon -->
    <div id="telemetry-bar">
        <!-- FRAMERATE -->
        <div class="module">
            <span class="label">D3D12</span>
            <span id="t-fps" class="v-fps">0</span> FPS
        </div>
        <div class="module">
            <span class="label">1%LOW</span>
            <span id="t-1low" class="v-fps">0</span>
        </div>

        <div class="sep"></div>

        <!-- FRAME TIMING -->
        <div class="module">
            <span class="label">FRAME</span>
            <span id="t-ft" class="v-ms">0.0</span> ms
        </div>
        <div class="module">
            <span class="label">DT</span>
            <span id="t-dt" class="v-ms">0.0</span> ms
        </div>

        <div class="sep"></div>

        <!-- GPU USAGE -->
        <div class="module">
            <span class="label">GPU</span>
            <span id="t-gpu" class="v-gpu">0</span>%
            <canvas id="c-gpu" class="sparkline" width="50" height="12"></canvas>
        </div>

        <div class="sep"></div>

        <!-- CPU USAGE -->
        <div class="module">
            <span class="label">CPU</span>
            <span id="t-cpu" class="v-cpu">0</span>%
            <canvas id="c-cpu" class="sparkline" width="50" height="12"></canvas>
        </div>
        <div class="module">
            <span class="label">CORES</span>
            <span id="t-cores" class="v-cpu">0</span>
        </div>

        <div class="sep"></div>

        <!-- RAM USAGE -->
        <div class="module">
            <span class="label">RAM</span>
            <span id="t-ram" class="v-ram">0</span> MB
            <canvas id="c-ram" class="sparkline" width="50" height="12"></canvas>
        </div>
        <div class="module">
            <span class="label">HEAP</span>
            <span id="t-mem">0</span> MB
        </div>

        <div class="sep"></div>

        <!-- RENDER STATS (REAL) -->
        <div class="module">
            <span class="label">TRIS</span>
            <span id="t-tris">0</span>
        </div>
        <div class="module">
            <span class="label">CALLS</span>
            <span id="t-calls">0</span>
        </div>
        <div class="module">
            <span class="label">GEOM</span>
            <span id="t-geom">0</span>
        </div>
        <div class="module">
            <span class="label">TEX</span>
            <span id="t-tex">0</span>
        </div>

        <div class="sep"></div>

        <!-- NETWORK STATS -->
        <div class="module">
            <span class="label">PING</span>
            <span id="t-ping" class="v-net">0</span> ms
            <canvas id="c-ping" class="sparkline" width="50" height="12"></canvas>
        </div>
        <div class="module">
            <span class="label">LOSS</span>
            <span id="t-loss" class="v-net">0</span>%
        </div>
        <div class="module">
            <span class="label">JITTER</span>
            <span id="t-jitter" class="v-net">0</span> ms
        </div>

        <div class="sep"></div>

        <!-- GAME STATS (Score/Kills only) -->
        <div class="module">
            <span class="label">SCORE</span>
            <span id="t-score" class="v-score">0</span>
        </div>
        <div class="module">
            <span class="label">KILLS</span>
            <span id="t-kills" class="v-kills">0</span>
        </div>

        <div class="sep"></div>

        <!-- POSITION -->
        <div class="module">
            <span class="label">POS</span>
            <span id="t-pos" style="color:#aaa">0,0,0</span>
        </div>

        <div class="sep"></div>

        <!-- UPTIME -->
        <div class="module">
            <span class="label">TIME</span>
            <span id="t-uptime" style="color:#888">00:00</span>
        </div>
    </div>

    <!-- Micro Float Game Stats HUD -->
    <div id="game-stats-hud"></div>

    <div id="fpsLimiter">
        <label>FPS Limit:</label>
        <select id="fpsSelect">
            <option value="0" selected>Unlimited</option>
            <option value="30">30 FPS</option>
            <option value="60">60 FPS</option>
            <option value="75">75 FPS</option>
            <option value="120">120 FPS</option>
            <option value="144">144 FPS</option>
            <option value="165">165 FPS</option>
            <option value="240">240 FPS</option>
        </select>
    </div>

    <div id="crosshair"></div>

    <div id="hitMarker"></div>

    <!-- BF1-Style Hit Feed HUD -->
    <div id="bf1HitHud" class="bf1-feed-hud">
        <div class="bf1-feed-list" id="bf1FeedList"></div>
        <div class="bf1-feed-total" id="bf1FeedTotal">+0</div>
    </div>

    <!-- AI Hit Me Button (for testing near-death effect) -->
    <button id="aiHitMeBtn" onclick="window.aiHitPlayer && window.aiHitPlayer()">🎯 AI HIT ME (H)</button>

    <!-- CS2-Style Top Scoreboard (hidden, replaced by R6) -->
    <div id="cs2Scoreboard" style="display: none !important;">
        <div class="cs2-team team-left">
            <div class="cs2-avatar" id="cs2AvatarLeft">
                <img id="cs2AvatarImgLeft" src="" alt="">
            </div>
            <span class="cs2-name" id="cs2NameLeft">PLAYER</span>
        </div>
        <div class="cs2-score-box">
            <span class="cs2-score score-left" id="cs2ScoreLeft">0</span>
            <span class="cs2-divider">:</span>
            <span class="cs2-score score-right" id="cs2ScoreRight">0</span>
            <div class="cs2-round-info">FIRST TO 10</div>
        </div>
        <div class="cs2-team team-right">
            <span class="cs2-name" id="cs2NameRight">ENEMY</span>
            <div class="cs2-avatar" id="cs2AvatarRight">
                <img id="cs2AvatarImgRight" src="" alt="">
            </div>
        </div>
    </div>

    <!-- R6-Style Top Stats Bar -->
    <div id="r6Topbar">
        <!-- BLUE TEAM (Player's Team) -->
        <div class="r6-team-block r6-blue-team" id="r6BlueTeam">
            <div class="r6-op-card is-me" id="r6PlayerCard">
                <img id="r6PlayerAvatar" src="" alt="">
                <div class="r6-level-badge" id="r6PlayerLevel">1</div>
                <div class="r6-hp-container">
                    <div class="r6-hp-fill" id="r6PlayerHp" style="width:100%"></div>
                </div>
            </div>
            <!-- Placeholder slots for future team expansion -->
            <div class="r6-op-card" id="r6BlueSlot2" style="display:none;">
                <div class="r6-unknown-op">?</div>
            </div>
            <div class="r6-op-card" id="r6BlueSlot3" style="display:none;">
                <div class="r6-unknown-op">?</div>
            </div>
            <div class="r6-score-box-blue" id="r6BlueScore">0</div>
        </div>

        <!-- TIMER -->
        <div class="r6-timer-section">
            <div class="r6-time-text" id="r6Timer">3:00</div>
            <div class="r6-round-text" id="r6RoundText">ROUND 1</div>
        </div>

        <!-- ORANGE TEAM (Enemy Team) -->
        <div class="r6-team-block r6-orange-team" id="r6OrangeTeam">
            <div class="r6-score-box-orange" id="r6OrangeScore">0</div>
            <div class="r6-op-card" id="r6EnemyCard">
                <img id="r6EnemyAvatar" src="" alt="">
                <div class="r6-level-badge r6-level-enemy" id="r6EnemyLevel">1</div>
                <div class="r6-hp-container">
                    <div class="r6-hp-fill" id="r6EnemyHp" style="width:100%"></div>
                </div>
            </div>
            <!-- Placeholder slots for future team expansion -->
            <div class="r6-op-card" id="r6OrangeSlot2" style="display:none;">
                <div class="r6-unknown-op">?</div>
            </div>
            <div class="r6-op-card" id="r6OrangeSlot3" style="display:none;">
                <div class="r6-unknown-op">?</div>
            </div>
        </div>
    </div>

    <div id="damageOverlay"></div>

    <!-- Lobby Squad List (shown during matchmaking) - REMOVED -->
    <!-- <div id="lobbySquadList" style="display: none;">
        <div class="lobby-squad-header">⚔ Friends</div>
        <div class="lobby-squad-subheader" id="lobbyStatus">Waiting for players...</div>
        <div id="lobbyPlayerList"></div>
    </div> -->

    <!-- Squad List Widget - REMOVED -->
    <!-- <div id="squad-list" class="squad-list" style="display: none;"></div> -->

    <div id="hud">
        <div class="hud-container">
            <div class="hud-left">
                <div class="health-container">
                    <div class="postal-health-bg"></div>
                    <div id="postal-heart" class="postal-heart"></div>
                    <div id="postal-health-number" class="postal-health-number">100</div>
                </div>
                <div id="connectionStatus" style="display: none; font-size: 14px; margin-top: 5px;">
                    <span id="connectionIcon">🌐</span> <span id="connectionText">Connecting...</span>
                </div>
            </div>
            <div class="hud-center">
                <div class="score-container">
                    <span id="score">0</span>
                    <span>-</span>
                    <span id="enemyScore">0</span>
                </div>
            </div>
            <div class="hud-right">
                <div class="ammo-container">
                    <div id="weaponName" class="weapon-name">AK-47</div>
                    <div class="ammo-text">
                        <span id="currentAmmo">30</span>
                        <span class="ammo-separator">/</span>
                        <span id="reserveAmmo">90</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="reloadIndicator">RELOADING...</div>

    <!-- Voice Chat UI -->
    <div id="voiceChatContainer">
        <button id="micButton" title="Toggle Microphone (V)">
            <svg viewBox="0 0 24 24" id="micIcon">
                <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z" />
                <path
                    d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z" />
            </svg>
        </button>
        <div id="voiceStatus">PUSH V TO TALK</div>
    </div>

    <!-- Opponent Speaking Indicator -->
    <div id="opponentSpeaking">
        <svg class="speaker-icon" viewBox="0 0 24 24">
            <path
                d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z" />
        </svg>
        <span class="speaker-name" id="opponentSpeakerName">Opponent</span>
        <span class="voice-distance" id="voiceDistance">-- m</span>
    </div>

    <div id="killFeed"></div>

    <div id="gameOver">
        <h2 id="gameOverText">VICTORY!</h2>
        <p id="finalScore"></p>
        <button onclick="location.reload()">PLAY AGAIN</button>
    </div>

    <div id="pauseMenu"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); z-index: 10000; align-items: center; justify-content: center; flex-direction: column;">
        <div style="text-align: center; color: white; font-family: 'Inter', 'Segoe UI', -apple-system, sans-serif;">
            <h1
                style="font-size: 42px; margin-bottom: 48px; font-weight: 600; letter-spacing: 4px; text-transform: uppercase; color: #ffffff;">
                PAUSED</h1>
            <div style="display: flex; flex-direction: column; gap: 12px; max-width: 320px; margin: 0 auto;">
                <button id="resumeButton" class="menu-button menu-button-success" style="width: 100%;">
                    RESUME GAME
                </button>
                <button id="exitToMenuButton" class="menu-button menu-button-danger" style="width: 100%;">
                    EXIT TO MENU
                </button>
            </div>
            <p style="margin-top: 24px; font-size: 12px; color: rgba(255,255,255,0.5);">Press F for fullscreen</p>
        </div>
    </div>

    <div id="deathScreen">
        <h1>YOU DIED</h1>
    </div>

    <!-- Killer Info Display -->
    <div id="killerInfo">
        <div class="killer-name" id="killerName">Enemy</div>
        <div class="killer-stats">
            <div class="stat-item">
                <span class="stat-label">HP:</span>
                <div class="hp-bar">
                    <div class="hp-bar-fill" id="killerHpBar" style="width: 100%"></div>
                </div>
                <span class="stat-value" id="killerHpText">100</span>
            </div>
            <div class="stat-item">
                <span class="weapon-icon">🔫</span>
                <span class="stat-value" id="killerWeapon">AK-47</span>
            </div>
        </div>
    </div>

    <!-- Keybinds Modal -->
    <div id="keybindsModal">
        <div class="keybinds-container">
            <div class="keybinds-header">
                <h2>OPTIONS</h2>
                <p class="keybinds-subtitle">KEYBINDS</p>
            </div>
            <div id="keybindsList"></div>
            <div class="keybinds-buttons">
                <button class="reset-btn" onclick="resetKeybinds()">RESET</button>
                <button class="close-btn" onclick="closeKeybindsModal()">CLOSE</button>
            </div>
        </div>
    </div>

    <!-- Speaker icon overlay (hidden by default) -->
    <div id="speakerIconOverlay" class="speaker-icon" style="display:none;">
        <svg width="80" height="80" viewBox="0 0 80 80" fill="none" xmlns="http://www.w3.org/2000/svg">
            <g filter="url(#glow)">
                <path d="M14 50V30h14l14-14v48l-14-14H14z" fill="#fff" stroke="#ffd700" stroke-width="2" />
                <path d="M56 40c0 6-4.4 11-10 12v-4c3.4 0 6-2.6 6-6s-2.6-6-6-6v-4c5.6 0 10 5 10 12z" fill="#ffd700" />
                <path d="M68 40c0 12-8.4 20-14 26l-4-4c7-7 7-17 0-24l4-4c5.6 6 14 14 14 26z" fill="#ffed4e" />
                <path d="M64 40c0 9-6 15-10 20l-3-3c5-5 5-12 0-17l3-3c4 4 10 11 10 20z" fill="#fff59d" />
            </g>
            <defs>
                <filter id="glow" x="-10" y="-10" width="100" height="100" filterUnits="userSpaceOnUse">
                    <feGaussianBlur stdDeviation="3" result="coloredBlur" />
                    <feMerge>
                        <feMergeNode in="coloredBlur" />
                        <feMergeNode in="SourceGraphic" />
                    </feMerge>
                    <feDropShadow dx="0" dy="4" stdDeviation="4" flood-color="#000" flood-opacity="0.4" />
                </filter>
            </defs>
        </svg>
    </div>

    <!-- Weapon Position Selector Panel -->
    <div id="positionSelector"
        style="display: none; position: fixed; top: 20px; right: 20px; width: 340px; background: rgba(0,0,0,0.95); border: 2px solid #0ff; border-radius: 8px; padding: 16px; z-index: 9999; font-family: 'Courier New', monospace; color: #0ff; max-height: 90vh; overflow-y: auto;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
            <h3 style="margin: 0; font-size: 14px; text-transform: uppercase; letter-spacing: 2px;">WEAPON POSITION</h3>
            <button onclick="togglePositionSelector()"
                style="background: #0ff; color: #000; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-weight: bold; font-size: 12px;">CLOSE</button>
        </div>

        <div
            style="margin-bottom: 12px; padding: 10px; background: rgba(0,255,255,0.1); border-radius: 4px; font-size: 11px; line-height: 1.4;">
            <strong>Press 'W' to enable selector</strong><br>
            Then click on camera view to activate.<br>
            Adjust position/rotation/scale below.
        </div>

        <!-- Scale Controls -->
        <div style="margin-bottom: 12px;">
            <label style="display: block; font-size: 11px; margin-bottom: 4px; text-transform: uppercase;">Scale: <span
                    id="scaleValue">1.00</span></label>
            <input type="range" id="scaleInput" min="0.1" max="3" step="0.01" value="1"
                style="width: 100%; cursor: pointer;">
            <input type="number" id="scaleNumber" min="0.1" max="3" step="0.01" value="1"
                style="width: 100%; margin-top: 4px; padding: 4px; background: rgba(0,255,255,0.1); border: 1px solid #0ff; color: #0ff; font-family: inherit;">
        </div>

        <!-- Position X -->
        <div style="margin-bottom: 12px;">
            <label style="display: block; font-size: 11px; margin-bottom: 4px; text-transform: uppercase;">Position X:
                <span id="posXValue">0.13</span></label>
            <input type="range" id="posXInput" min="-1" max="1" step="0.01" value="0.13"
                style="width: 100%; cursor: pointer;">
            <input type="number" id="posXNumber" min="-1" max="1" step="0.01" value="0.13"
                style="width: 100%; margin-top: 4px; padding: 4px; background: rgba(0,255,255,0.1); border: 1px solid #0ff; color: #0ff; font-family: inherit;">
        </div>

        <!-- Position Y -->
        <div style="margin-bottom: 12px;">
            <label style="display: block; font-size: 11px; margin-bottom: 4px; text-transform: uppercase;">Position Y:
                <span id="posYValue">-1.53</span></label>
            <input type="range" id="posYInput" min="-2" max="0" step="0.01" value="-1.53"
                style="width: 100%; cursor: pointer;">
            <input type="number" id="posYNumber" min="-2" max="0" step="0.01" value="-1.53"
                style="width: 100%; margin-top: 4px; padding: 4px; background: rgba(0,255,255,0.1); border: 1px solid #0ff; color: #0ff; font-family: inherit;">
        </div>

        <!-- Position Z -->
        <div style="margin-bottom: 12px;">
            <label style="display: block; font-size: 11px; margin-bottom: 4px; text-transform: uppercase;">Position Z:
                <span id="posZValue">0.03</span></label>
            <input type="range" id="posZInput" min="-1" max="0.5" step="0.01" value="0.03"
                style="width: 100%; cursor: pointer;">
            <input type="number" id="posZNumber" min="-1" max="0.5" step="0.01" value="0.03"
                style="width: 100%; margin-top: 4px; padding: 4px; background: rgba(0,255,255,0.1); border: 1px solid #0ff; color: #0ff; font-family: inherit;">
        </div>

        <!-- Rotation X -->
        <div style="margin-bottom: 12px;">
            <label style="display: block; font-size: 11px; margin-bottom: 4px; text-transform: uppercase;">Rotation X:
                <span id="rotXValue">0.00</span></label>
            <input type="range" id="rotXInput" min="-3.14" max="3.14" step="0.01" value="0"
                style="width: 100%; cursor: pointer;">
            <input type="number" id="rotXNumber" min="-3.14" max="3.14" step="0.01" value="0"
                style="width: 100%; margin-top: 4px; padding: 4px; background: rgba(0,255,255,0.1); border: 1px solid #0ff; color: #0ff; font-family: inherit;">
        </div>

        <!-- Rotation Y -->
        <div style="margin-bottom: 12px;">
            <label style="display: block; font-size: 11px; margin-bottom: 4px; text-transform: uppercase;">Rotation Y:
                <span id="rotYValue">3.10</span></label>
            <input type="range" id="rotYInput" min="-3.14" max="3.14" step="0.01" value="3.1"
                style="width: 100%; cursor: pointer;">
            <input type="number" id="rotYNumber" min="-3.14" max="3.14" step="0.01" value="3.1"
                style="width: 100%; margin-top: 4px; padding: 4px; background: rgba(0,255,255,0.1); border: 1px solid #0ff; color: #0ff; font-family: inherit;">
        </div>

        <!-- Rotation Z -->
        <div style="margin-bottom: 16px;">
            <label style="display: block; font-size: 11px; margin-bottom: 4px; text-transform: uppercase;">Rotation Z:
                <span id="rotZValue">0.00</span></label>
            <input type="range" id="rotZInput" min="-3.14" max="3.14" step="0.01" value="0"
                style="width: 100%; cursor: pointer;">
            <input type="number" id="rotZNumber" min="-3.14" max="3.14" step="0.01" value="0"
                style="width: 100%; margin-top: 4px; padding: 4px; background: rgba(0,255,255,0.1); border: 1px solid #0ff; color: #0ff; font-family: inherit;">
        </div>

        <!-- Output Section -->
        <div
            style="margin-bottom: 12px; padding: 10px; background: rgba(0,255,255,0.05); border: 1px solid rgba(0,255,255,0.3); border-radius: 4px;">
            <label
                style="display: block; font-size: 11px; margin-bottom: 6px; text-transform: uppercase; font-weight: bold;">Configuration</label>
            <textarea id="configOutput" readonly
                style="width: 100%; height: 120px; padding: 8px; background: rgba(0,0,0,0.5); border: 1px solid #0ff; color: #0ff; font-family: 'Courier New', monospace; font-size: 10px; resize: none; border-radius: 4px;"
                spellcheck="false"></textarea>
        </div>

        <button onclick="copyPositionConfig()"
            style="width: 100%; padding: 10px; background: #0ff; color: #000; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; text-transform: uppercase; font-size: 12px; margin-bottom: 8px;">📋
            COPY CONFIG</button>
        <button onclick="resetPositionSelector()"
            style="width: 100%; padding: 10px; background: rgba(0,255,255,0.2); color: #0ff; border: 1px solid #0ff; border-radius: 4px; cursor: pointer; font-weight: bold; text-transform: uppercase; font-size: 12px;">↺
            RESET</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/fflate@0.8.0/umd/index.min.js"></script>
    <script src="loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/FBXLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/MTLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/EXRLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/RGBELoader.js"></script>

    <!-- Import Map for Modern Three.js Modules -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>

    <!-- Loading Screen Controller -->
    <script>
        // ==================== LOADING SCREEN SYSTEM ====================
        const LoadingScreen = {
            element: null,
            bar: null,
            percent: null,
            status: null,
            tip: null,
            ammo: null,
            progress: 0,
            targetProgress: 0,
            isComplete: false,
            initialized: false,

            // Asset tracking
            totalAssets: 0,
            loadedAssets: 0,
            assetList: [],

            tips: [
                "Check your corners. The enemy could be anywhere.",
                "Reload behind cover. Getting caught mid-reload is fatal.",
                "Headshots deal 2x damage. Aim high.",
                "Use SHIFT to sprint. Speed is survival.",
                "Press R to reload manually. Don't wait for empty.",
                "Communicate with your team. Intel wins matches.",
                "Control the center. Map control is key.",
                "Sound gives away position. Move smart.",
                "Pre-aim common angles. Reaction time matters.",
                "Trade kills when possible. Never die for nothing."
            ],

            init() {
                if (this.initialized) return;
                this.initialized = true;

                this.element = document.getElementById('loadingScreen');
                this.bar = document.getElementById('loadingBar');
                this.percent = document.getElementById('loadingPercent');
                this.status = document.getElementById('loadingStatus');
                this.tip = document.getElementById('loadingTip');
                this.ammo = document.getElementById('loadingAmmo');

                if (!this.element) {
                    console.warn('Loading screen elements not found');
                    return;
                }

                // Set random tip
                this.tip.textContent = this.tips[Math.floor(Math.random() * this.tips.length)];

                // Cycle tips every 4 seconds
                setInterval(() => {
                    if (!this.isComplete && this.tip) {
                        this.tip.textContent = this.tips[Math.floor(Math.random() * this.tips.length)];
                    }
                }, 4000);

                // Animate ammo counter
                this.animateAmmo();

                // Start smooth progress animation
                this.animateProgress();

                console.log('✅ Loading screen initialized');
            },

            animateAmmo() {
                let ammoCount = 30;
                const interval = setInterval(() => {
                    if (this.isComplete || !this.ammo) {
                        clearInterval(interval);
                        return;
                    }
                    ammoCount = Math.max(0, ammoCount - Math.floor(Math.random() * 3));
                    if (ammoCount <= 0) ammoCount = 30;
                    this.ammo.textContent = ammoCount + ' / 90';
                }, 200);
            },

            animateProgress() {
                const animate = () => {
                    if (!this.bar || !this.percent) return;

                    if (this.progress < this.targetProgress) {
                        this.progress += (this.targetProgress - this.progress) * 0.08;
                        if (this.targetProgress - this.progress < 0.5) {
                            this.progress = this.targetProgress;
                        }
                    }

                    const displayProgress = Math.min(100, Math.round(this.progress));
                    this.bar.style.width = displayProgress + '%';
                    this.percent.textContent = displayProgress + '%';

                    if (!this.isComplete) {
                        requestAnimationFrame(animate);
                    }
                };
                animate();
            },

            // Register an asset to be loaded
            registerAsset(name) {
                this.assetList.push({ name, loaded: false });
                this.totalAssets = this.assetList.length;
            },

            // Mark asset as loaded and update progress
            assetLoaded(name) {
                const asset = this.assetList.find(a => a.name === name);
                if (asset && !asset.loaded) {
                    asset.loaded = true;
                    this.loadedAssets++;
                    this.updateProgress();
                }
            },

            updateProgress() {
                if (this.totalAssets > 0) {
                    this.targetProgress = (this.loadedAssets / this.totalAssets) * 100;
                }
            },

            setProgress(percent, statusText) {
                if (!this.initialized) this.init();
                this.targetProgress = Math.min(100, percent);
                if (statusText && this.status) {
                    this.status.textContent = statusText;
                }
            },

            setStatus(text) {
                if (this.status) {
                    this.status.textContent = text;
                }
            },

            complete() {
                if (!this.initialized) this.init();
                this.isComplete = true;
                this.targetProgress = 100;
                this.progress = 100;
                if (this.bar) this.bar.style.width = '100%';
                if (this.percent) this.percent.textContent = '100%';
                if (this.status) this.status.textContent = 'READY';

                console.log('✅ Loading complete! (' + this.loadedAssets + '/' + this.totalAssets + ' assets)');

                setTimeout(() => {
                    if (this.element) {
                        this.element.classList.add('fade-out');
                        setTimeout(() => {
                            this.element.style.display = 'none';
                        }, 500);
                    }
                }, 400);
            }
        };

        // Make globally accessible immediately
        window.LoadingScreen = LoadingScreen;

        // Initialize as soon as DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => LoadingScreen.init());
        } else {
            LoadingScreen.init();
        }
    </script>

    <script>
        // Wait for Three.js to load (but don't initialize game yet)
        window.addEventListener('load', function () {
            if (typeof THREE === 'undefined') {
                // Fallback if CDN fails
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
                document.head.appendChild(script);
                // Don't auto-initialize, wait for user to choose mode
            } else {
                console.log('Three.js loaded, waiting for user to choose game mode...');
                // Don't auto-initialize, wait for user to choose mode
            }
        });

        // ==================== MUSIC PLAYER SYSTEM ====================
        const MusicPlayer = {
            playlist: [
                { title: 'Big X', src: 'songs/bigx.mp3', art: 'songs/bigx.jpg' },
                { title: '4 Raws', src: 'songs/4 Raws (mp3cut.net).mp3', art: 'songs/esdeekid.webp' },
                { title: '4 Da Gang', src: 'songs/42 Dugg, Roddy Ricch - 4 Da Gang (Official Music Video) (mp3cut.net).mp3', art: 'songs/4dagang.webp' },
                { title: 'Save That Shit', src: 'songs/Chief Keef- Save That Shit (Back From The Dead).mp3', art: 'songs/savethatshit.jpg' },
                { title: 'Century', src: 'songs/EsDeeKid - Century (mp3cut.net).mp3', art: 'songs/esdeekid.webp' },
                { title: 'Glokk40Spaz', src: 'songs/glokk40spaz.mp3', art: 'songs/glokk40spaz.jpg' },
                { title: 'I Dont Like', src: 'songs/I Dont Like (mp3cut.net).mp3', art: 'songs/chiefkeef.jpg' },
                { title: 'SS', src: 'songs/Ken Carson - ss (Official Audio).mp3', art: 'songs/ss-kencarson.jpg' },
                { title: 'Need It', src: 'songs/Migos - Need It (Official Video) ft. YoungBoy Never Broke Again.mp3', art: 'songs/Migos-Need-It-ft.-YoungBoy-Never-Broke-Again-screenshot-2020-billboard-1548-1598022475.webp' },
                { title: 'Osamason', src: 'songs/osamason.mp3', art: 'songs/osamason.jpg' },
                { title: 'One Call', src: 'songs/Rich Amiri - One Call (Official Music Video) (mp3cut.net).mp3', art: 'songs/onecall.png' },
                { title: 'Next Up', src: 'songs/Sada Baby - Next Up (feat (mp3cut.net).mp3', art: 'songs/sadababy.jpg' },
                { title: 'Slend', src: 'songs/slend.mp3', art: 'songs/slenderman.jpg' },
                { title: 'Take Over The World', src: 'songs/TAKE OVER THE WORLD (FREESTYLE).mp3', art: 'songs/takeovertheworld(freestyle).jpg' },
                { title: 'Tay-K', src: 'songs/tayk.mp3', art: 'songs/tayk.jpg' }
                ,{ title: 'Turks', src: 'songs/NAV & Gunna - Turks feat. Travis Scott (Official Audio).mp3', art: 'songs/turks.jpg' }
                ,{ title: 'Bounce Out With That', src: 'songs/YBN Nahmir - Bounce Out With That (Directed by Cole Bennett).mp3', art: 'songs/ybnnahmir.jpg' }
            ],
            currentIndex: 0,
            audio: null,
            isPlaying: false,
            isMuted: false,
            shuffle: false,
            repeat: false,
            volume: 0.05,
            fadeDuration: 300,
            crossfadeDuration: 600,
            compactDelayMs: 4000,
            hasUserInteracted: false,
            vizBars: [],
            audioContext: null,
            analyser: null,
            _mediaSource: null,
            _vizRunning: false,
            _vizFallbackRunning: false,
            _compactTimer: null,
            _progressRaf: null,
            _globalUnmuteHandler: null,
            _gameStarted: false,
            _trackToken: 0,
            _activeTrackToken: 0,

            init() {
                this.audio = new Audio();
                this.audio.preload = 'auto';
                this._musicStarted = false;
                this._gameStarted = false;

                this.els = {
                    player: document.getElementById('musicPlayer'),
                    prompt: document.getElementById('mpAutoplayPrompt'),
                    artwork: document.getElementById('mpArtwork'),
                    title: document.getElementById('mpTrackTitle'),
                    playBtn: document.getElementById('mpPlayPause'),
                    playIcon: document.getElementById('mpPlayIcon'),
                    prevBtn: document.getElementById('mpPrev'),
                    nextBtn: document.getElementById('mpNext'),
                    shuffleBtn: document.getElementById('mpShuffle'),
                    repeatBtn: document.getElementById('mpRepeat'),
                    volIcon: document.getElementById('mpVolIcon'),
                    volSlider: document.getElementById('mpVolSlider'),
                    volFill: document.getElementById('mpVolFill'),
                    volPct: document.getElementById('mpVolPct'),
                    visualizer: document.getElementById('mpVisualizer'),
                    progressRow: document.getElementById('mpProgressRow'),
                    progressBar: document.getElementById('mpProgressBar'),
                    progressFill: document.getElementById('mpProgressFill'),
                    timeCurrent: document.getElementById('mpTimeCurrent'),
                    timeTotal: document.getElementById('mpTimeTotal')
                };

                // Hide prompt immediately
                this.els.prompt.classList.add('hidden');
                this.els.prompt.style.display = 'none';

                // Create visualizer bars
                for (let i = 0; i < 20; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'mp-viz-bar';
                    bar.style.height = '3px';
                    this.els.visualizer.appendChild(bar);
                    this.vizBars.push(bar);
                }

                // Event listeners
                this.els.prompt.onclick = () => this.onUserInteract();
                this.els.playBtn.onclick = () => this.togglePlay();
                this.els.prevBtn.onclick = () => this.prev();
                this.els.nextBtn.onclick = () => this.next();
                this.els.shuffleBtn.onclick = () => this.toggleShuffle();
                this.els.repeatBtn.onclick = () => this.toggleRepeat();
                this.els.volIcon.onclick = () => this.toggleMute();
                this.els.volSlider.onclick = (e) => this.onVolSliderClick(e);
                this.els.progressBar.onclick = (e) => this.onProgressBarClick(e);

                this.audio.onended = () => {
                    if (this.repeat) {
                        this.audio.currentTime = 0;
                        this.audio.play();
                    } else {
                        this.next();
                    }
                };

                this.audio.addEventListener('loadedmetadata', () => {
                    this._updateProgressUI();
                });
                this.audio.addEventListener('play', () => {
                    this._onTrackPlaybackStarted();
                });
                this.audio.addEventListener('playing', () => {
                    // Defensive: restart visualizer if it stopped
                    if (!this._vizRunning && !this._vizFallbackRunning) {
                        this.startVisualizer();
                    }
                });
                this.audio.addEventListener('pause', () => {
                    this._stopProgressLoop();
                });
                this.audio.addEventListener('ended', () => {
                    this._stopProgressLoop();
                });

                // Random track on load
                this.currentIndex = Math.floor(Math.random() * this.playlist.length);
                this.loadTrack(this.currentIndex);
                this.updateVolumeUI();
                
                // SIMPLE & AGGRESSIVE: Set up click-to-unmute FIRST, then try autoplay
                this._setupGlobalUnmute();
                this._tryAutoplay();
            },

            _setupGlobalUnmute() {
                // This runs on EVERY click until music is playing with sound
                const handler = () => {
                    if (this._gameStarted) return;
                    if (this._musicStarted) return;

                    // Mark a real user gesture happened
                    this.hasUserInteracted = true;
                    this.els.prompt.classList.add('hidden');

                    // If autoplay started muted, some browsers stay silent until a pause->play cycle.
                    const wasPlaying = !this.audio.paused;
                    const currentTime = this.audio.currentTime;
                    if (wasPlaying) {
                        try { this.audio.pause(); } catch (_) {}
                        try { this.audio.currentTime = currentTime; } catch (_) {}
                    }

                    // Respect the UI mute state (usually false by default)
                    this.audio.muted = !!this.isMuted;
                    this.audio.volume = 0;

                    this.audio.play().then(() => {
                        this._musicStarted = true;
                        this.isPlaying = true;
                        this.els.player.classList.add('playing');
                        this.updatePlayIcon();
                        this.startVisualizer();
                        this._onTrackPlaybackStarted();
                        this.animateVolume(0, this.effectiveVolume(), this.fadeDuration);
                    }).catch(() => {
                        // Will try again on next click
                    });
                };

                this._globalUnmuteHandler = handler;

                // Attach to document with capture to catch ALL clicks
                document.addEventListener('click', handler, true);
                document.addEventListener('mousedown', handler, true);
                document.addEventListener('keydown', handler, true);
                document.addEventListener('touchstart', handler, true);
            },

            _tryAutoplay() {
                if (this._gameStarted) return;
                // Try unmuted first
                this.audio.muted = !!this.isMuted;
                this.audio.volume = 0;
                
                this.audio.play().then(() => {
                    this._musicStarted = true;
                    this.hasUserInteracted = true;
                    this.isPlaying = true;
                    this.els.player.classList.add('playing');
                    this.updatePlayIcon();
                    this.startVisualizer();
                    this._onTrackPlaybackStarted();
                    this.animateVolume(0, this.effectiveVolume(), this.fadeDuration);
                }).catch(() => {
                    // Unmuted failed, try muted (just to show visualizer)
                    this.audio.muted = true;
                    this.audio.play().then(() => {
                        this.isPlaying = true;
                        this.els.player.classList.add('playing');
                        this.updatePlayIcon();
                        this.startVisualizer();
                        this._onTrackPlaybackStarted();
                        // Sound will start on first click via _setupGlobalUnmute
                    }).catch(() => {});
                });
            },

            _setCompact(isCompact) {
                if (!this.els || !this.els.player) return;
                this.els.player.classList.toggle('mp-compact', !!isCompact);
            },

            _clearAutoCompactTimer() {
                if (this._compactTimer) {
                    clearTimeout(this._compactTimer);
                    this._compactTimer = null;
                }
            },

            _formatTime(seconds) {
                if (!Number.isFinite(seconds) || seconds <= 0) return '0:00';
                const whole = Math.floor(seconds);
                const m = Math.floor(whole / 60);
                const s = whole % 60;
                return m + ':' + (s < 10 ? '0' + s : s);
            },

            _updateProgressUI() {
                if (!this.els || !this.els.progressFill || !this.els.timeCurrent || !this.els.timeTotal) return;
                const dur = this.audio && Number.isFinite(this.audio.duration) ? this.audio.duration : 0;
                const cur = this.audio && Number.isFinite(this.audio.currentTime) ? this.audio.currentTime : 0;
                const pct = dur > 0 ? Math.max(0, Math.min(1, cur / dur)) : 0;
                this.els.progressFill.style.width = (pct * 100).toFixed(3) + '%';
                this.els.timeCurrent.textContent = this._formatTime(cur);
                this.els.timeTotal.textContent = this._formatTime(dur);
            },

            _startProgressLoop() {
                if (this._progressRaf) return;
                const tick = () => {
                    this._progressRaf = null;
                    if (this._gameStarted) return;
                    if (!this.audio || this.audio.paused) return;
                    this._updateProgressUI();
                    this._progressRaf = requestAnimationFrame(tick);
                };
                this._progressRaf = requestAnimationFrame(tick);
            },

            _stopProgressLoop() {
                if (this._progressRaf) {
                    cancelAnimationFrame(this._progressRaf);
                    this._progressRaf = null;
                }
            },

            _onTrackPlaybackStarted() {
                if (this._gameStarted) return;
                if (!this.els || !this.els.player || this.els.player.style.display === 'none') return;

                // Clear any switching animation state once playback is live
                this.els.player.classList.remove('mp-switching');

                const token = this._activeTrackToken;
                this._setCompact(false);
                this._clearAutoCompactTimer();
                this._startProgressLoop();

                this._compactTimer = setTimeout(() => {
                    if (this._gameStarted) return;
                    if (this._activeTrackToken !== token) return;
                    if (!this.audio || this.audio.paused) return;
                    this._setCompact(true);
                }, this.compactDelayMs);
            },

            handleGameStart() {
                if (this._gameStarted) return;
                this._gameStarted = true;
                this._clearAutoCompactTimer();
                this._stopProgressLoop();
                this.stopVisualizer();

                try { this.audio.pause(); } catch (_) {}
                try { this.audio.currentTime = 0; } catch (_) {}

                this.isPlaying = false;
                if (this.els && this.els.player) {
                    this.els.player.classList.remove('playing');
                    this.els.player.style.display = 'none';
                }
                if (this.els && this.els.playIcon) this.updatePlayIcon();

                const handler = this._globalUnmuteHandler;
                if (handler) {
                    document.removeEventListener('click', handler, true);
                    document.removeEventListener('mousedown', handler, true);
                    document.removeEventListener('keydown', handler, true);
                    document.removeEventListener('touchstart', handler, true);
                }
            },

            onUserInteract() {
                this.hasUserInteracted = true;
                this.els.prompt.classList.add('hidden');
                this.play();
            },

            loadTrack(i) {
                if (i < 0 || i >= this.playlist.length) return;
                this.currentIndex = i;
                this._trackToken++;
                this._activeTrackToken = this._trackToken;
                const track = this.playlist[i];
                this.audio.src = encodeURI(track.src);
                this.els.title.textContent = track.title;
                if (track.art) this.els.artwork.src = encodeURI(track.art);
                this._updateProgressUI();
            },

            updatePlayIcon() {
                const path = this.isPlaying
                    ? 'M6 19h4V5H6v14zm8-14v14h4V5h-4z'
                    : 'M8 5v14l11-7z';
                this.els.playIcon.innerHTML = '<path d="' + path + '"/>';
            },

            togglePlay() {
                if (!this.hasUserInteracted) {
                    this.onUserInteract();
                    return;
                }
                this.isPlaying ? this.pause() : this.play();
            },

            play() {
                if (!this.hasUserInteracted) {
                    this.els.prompt.classList.remove('hidden');
                    return;
                }
                this.fadeIn();
            },

            pause() {
                this.audio.muted = !!this.isMuted;
                this.fadeOut(() => {
                    this.audio.pause();
                });
            },

            stop() {
                return new Promise(resolve => {
                    this.fadeOut(() => {
                        this.audio.pause();
                        this.audio.currentTime = 0;
                        resolve();
                    });
                });
            },

            fadeIn() {
                this.audio.volume = 0;
                this.audio.play().then(() => {
                    this.isPlaying = true;
                    this.els.player.classList.add('playing');
                    this.updatePlayIcon();
                    this.startVisualizer();
                    this._onTrackPlaybackStarted();
                    this.animateVolume(0, this.effectiveVolume(), this.fadeDuration);
                }).catch(e => {
                    console.log('Playback failed:', e);
                    this.isPlaying = false;
                    this.els.player.classList.remove('playing');
                    this.updatePlayIcon();
                });
            },

            fadeOut(callback) {
                const startVol = this.audio.volume;
                this.animateVolume(startVol, 0, this.fadeDuration, () => {
                    this.isPlaying = false;
                    this.els.player.classList.remove('playing');
                    this.updatePlayIcon();
                    // Don't stop visualizer - it will auto-flatten bars when audio.paused is true
                    if (callback) callback();
                });
            },

            animateVolume(from, to, duration, callback) {
                if (this._gameStarted) {
                    this.audio.volume = Math.max(0, Math.min(1, to));
                    if (callback) callback();
                    return;
                }
                const startTime = performance.now();
                const animate = (now) => {
                    const elapsed = now - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const eased = progress * (2 - progress);
                    // Clamp volume to valid [0, 1] range to prevent IndexSizeError
                    this.audio.volume = Math.max(0, Math.min(1, from + (to - from) * eased));
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        if (callback) callback();
                    }
                };
                requestAnimationFrame(animate);
            },

            prev() {
                const wasPlaying = this.isPlaying;
                const newIdx = (this.currentIndex - 1 + this.playlist.length) % this.playlist.length;
                this.crossfadeTo(newIdx, wasPlaying);
            },

            next() {
                const wasPlaying = this.isPlaying;
                let newIdx;
                if (this.shuffle) {
                    do {
                        newIdx = Math.floor(Math.random() * this.playlist.length);
                    } while (newIdx === this.currentIndex && this.playlist.length > 1);
                } else {
                    newIdx = (this.currentIndex + 1) % this.playlist.length;
                }
                this.crossfadeTo(newIdx, wasPlaying);
            },

            crossfadeTo(newIdx, autoPlay) {
                // Fade out current
                if (this.els && this.els.player) this.els.player.classList.add('mp-switching');
                this.els.title.classList.add('fading');
                const startVol = this.audio.volume;
                this.animateVolume(startVol, 0, this.crossfadeDuration / 2, () => {
                    this.loadTrack(newIdx);
                    this.els.title.classList.remove('fading');
                    if (autoPlay && this.hasUserInteracted) {
                        this.audio.muted = !!this.isMuted;
                        this.audio.volume = 0;
                        this.audio.play().then(() => {
                            this.isPlaying = true;
                            this.els.player.classList.add('playing');
                            this.updatePlayIcon();
                            this.startVisualizer();
                            this._onTrackPlaybackStarted();
                            this.animateVolume(0, this.effectiveVolume(), this.crossfadeDuration / 2);
                        }).catch(() => {});
                    }
                });
            },

            toggleShuffle() {
                this.shuffle = !this.shuffle;
                this.els.shuffleBtn.classList.toggle('active', this.shuffle);
            },

            toggleRepeat() {
                this.repeat = !this.repeat;
                this.els.repeatBtn.classList.toggle('active', this.repeat);
            },

            toggleMute() {
                this.isMuted = !this.isMuted;
                this.audio.volume = this.effectiveVolume();
                this.updateVolumeUI();
            },

            effectiveVolume() {
                return this.isMuted ? 0 : this.volume;
            },

            onVolSliderClick(e) {
                const rect = this.els.volSlider.getBoundingClientRect();
                const pct = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
                this.volume = pct;
                this.isMuted = false;
                if (this.isPlaying) this.audio.volume = this.volume;
                this.updateVolumeUI();
            },

            onProgressBarClick(e) {
                if (!this.audio || !Number.isFinite(this.audio.duration) || this.audio.duration <= 0) return;
                const rect = this.els.progressBar.getBoundingClientRect();
                const pct = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
                this.audio.currentTime = pct * this.audio.duration;
                this._updateProgressUI();
            },

            updateVolumeUI() {
                const pct = Math.round(this.volume * 100);
                this.els.volFill.style.width = pct + '%';
                this.els.volPct.textContent = pct + '%';
                this.els.volIcon.classList.toggle('muted', this.isMuted);
                // Update icon
                let iconPath;
                if (this.isMuted || this.volume === 0) {
                    iconPath = 'M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z';
                } else if (this.volume < 0.5) {
                    iconPath = 'M18.5 12c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM5 9v6h4l5 5V4L9 9H5z';
                } else {
                    iconPath = 'M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z';
                }
                this.els.volIcon.innerHTML = '<svg viewBox="0 0 24 24"><path d="' + iconPath + '"/></svg>';
            },

            startVisualizer() {
                // Don't start if already running
                if (this._vizRunning) return;
                this._vizRunning = true;

                // Initialize Web Audio API once
                if (!this.audioContext) {
                    try {
                        const AudioContext = window.AudioContext || window.webkitAudioContext;
                        this.audioContext = new AudioContext();
                        this.analyser = this.audioContext.createAnalyser();
                        this.analyser.fftSize = 256;
                        this._mediaSource = this.audioContext.createMediaElementAudioSource(this.audio);
                        this._mediaSource.connect(this.analyser);
                        this.analyser.connect(this.audioContext.destination);
                    } catch (e) {
                        console.log('Web Audio API not supported, using fallback');
                        this._startVisualizerFallback();
                        return;
                    }
                }

                // Resume context if suspended
                if (this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }

                const dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                const self = this;

                function animateViz() {
                    if (!self._vizRunning) return;
                    requestAnimationFrame(animateViz);

                    // Resume context if it got suspended
                    if (self.audioContext && self.audioContext.state === 'suspended') {
                        self.audioContext.resume();
                    }

                    // If audio is paused, flatten bars but keep loop running
                    if (!self.audio || self.audio.paused) {
                        self.vizBars.forEach(bar => bar.style.height = '3px');
                        return;
                    }

                    self.analyser.getByteFrequencyData(dataArray);

                    self.vizBars.forEach((bar, index) => {
                        const dataIndex = Math.floor((index / self.vizBars.length) * dataArray.length);
                        const value = dataArray[dataIndex] || 0;
                        const normalized = (value / 255) * 11 + 3;
                        bar.style.height = normalized + 'px';
                    });
                }

                animateViz();
            },

            _startVisualizerFallback() {
                if (this._vizFallbackRunning) return;
                this._vizFallbackRunning = true;
                const self = this;
                
                function fallbackLoop() {
                    if (!self._vizFallbackRunning) return;
                    setTimeout(fallbackLoop, 100);
                    
                    if (!self.audio || self.audio.paused) {
                        self.vizBars.forEach(bar => bar.style.height = '3px');
                        return;
                    }
                    self.vizBars.forEach(bar => {
                        bar.style.height = (3 + Math.random() * 11) + 'px';
                    });
                }
                fallbackLoop();
            },

            stopVisualizer() {
                this._vizRunning = false;
                this._vizFallbackRunning = false;
                this.vizBars.forEach(bar => bar.style.height = '3px');
            }
        };

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => MusicPlayer.init());
        } else {
            MusicPlayer.init();
        }
        window.MusicPlayer = MusicPlayer;

        // ==================== MULTIPLAYER SYSTEM (WebRTC + Socket.IO Fallback) ====================
        let socket = null;
        let peer = null;
        let peerConnection = null;
        let dataChannel = null;
        let isMultiplayer = false;
        window.isMultiplayer = false; // Expose globally for emote system
        let isHost = false;
        let otherPlayer = null;
        let myPlayerId = null;

        // ==================== TELEMETRY SYSTEM ====================
        let fpsLimit = 0; // Default: Unlimited
        let lastFrameTime = performance.now();
        let frameCount = 0;
        let fpsUpdateTime = performance.now();
        let currentFPS = 0;
        let frameTimes = [];

        // Sparkline graph drawing function
        function drawSparkline(canvas, dataArray, color, maxValue) {
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            // IMPORTANT: Don't derive CSS size from the canvas width/height attributes.
            // Setting canvas.width/height mutates those attributes, which can cause exponential growth
            // when combined with DPR scaling (especially on laptop/high-DPI displays).
            if (!canvas.dataset.cssw || !canvas.dataset.cssh) {
                const attrW = parseInt(canvas.getAttribute('width') || '', 10);
                const attrH = parseInt(canvas.getAttribute('height') || '', 10);
                if (attrW) canvas.dataset.cssw = String(attrW);
                if (attrH) canvas.dataset.cssh = String(attrH);
            }

            // Keep sparklines crisp on high-DPI displays
            const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
            const cssW = (canvas.dataset.cssw ? parseInt(canvas.dataset.cssw, 10) : 0) || canvas.clientWidth || 50;
            const cssH = (canvas.dataset.cssh ? parseInt(canvas.dataset.cssh, 10) : 0) || canvas.clientHeight || 12;
            const backingW = Math.floor(cssW * dpr);
            const backingH = Math.floor(cssH * dpr);
            if (canvas.width !== backingW || canvas.height !== backingH) {
                canvas.width = backingW;
                canvas.height = backingH;
                canvas.style.width = cssW + 'px';
                canvas.style.height = cssH + 'px';
            }

            // Draw in CSS pixels
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            ctx.clearRect(0, 0, cssW, cssH);

            if (!dataArray || dataArray.length < 2) return;

            // Line
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let i = 0; i < dataArray.length; i++) {
                const x = (i / (dataArray.length - 1)) * cssW;
                const normalized = Math.min(1, Math.max(0, dataArray[i] / maxValue));
                const y = cssH - (normalized * cssH);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Subtle fill (no opaque blocks)
            ctx.lineTo(cssW, cssH);
            ctx.lineTo(0, cssH);
            ctx.closePath();
            ctx.save();
            ctx.globalAlpha = 0.14;
            ctx.fillStyle = color;
            ctx.fill();
            ctx.restore();
        }

        function updateTelemetrySystem(currentTime, activeRenderer, activeCamera) {
            frameCount++;

            // Track frame times for 1% low calculation & Cache Elements
            if (!window.telemetryData) {
                window.telemetryData = {
                    // PERF: Use fixed-size array with circular index instead of push/shift
                    frameTimes: new Array(100).fill(16.67),
                    frameTimeIndex: 0,
                    frameTimeCount: 0,
                    fpsHistory: [],
                    startTime: performance.now(),
                    lastFrameStart: performance.now(),
                    // Graph histories
                    gpuHistory: new Array(50).fill(0),
                    cpuHistory: new Array(50).fill(0),
                    ramHistory: new Array(50).fill(0),
                    pingHistory: new Array(50).fill(0),
                    // Network tracking
                    lastPingSent: 0,
                    lastPingReceived: 0,
                    pingRTT: 0,
                    pingSamples: [],
                    packetsSent: 0,
                    packetsReceived: 0,
                    // PERF: Cache DOM elements once
                    elements: {
                        fps: document.getElementById('t-fps'),
                        low1: document.getElementById('t-1low'),
                        ft: document.getElementById('t-ft'),
                        dt: document.getElementById('t-dt'),
                        gpu: document.getElementById('t-gpu'),
                        cpu: document.getElementById('t-cpu'),
                        cores: document.getElementById('t-cores'),
                        ram: document.getElementById('t-ram'),
                        tris: document.getElementById('t-tris'),
                        calls: document.getElementById('t-calls'),
                        geom: document.getElementById('t-geom'),
                        tex: document.getElementById('t-tex'),
                        mem: document.getElementById('t-mem'),
                        ping: document.getElementById('t-ping'),
                        loss: document.getElementById('t-loss'),
                        jitter: document.getElementById('t-jitter'),
                        score: document.getElementById('t-score'),
                        kills: document.getElementById('t-kills'),
                        pos: document.getElementById('t-pos'),
                        uptime: document.getElementById('t-uptime'),
                        // Canvas elements for graphs
                        cGPU: document.getElementById('c-gpu'),
                        cCPU: document.getElementById('c-cpu'),
                        cRAM: document.getElementById('c-ram'),
                        cPing: document.getElementById('c-ping')
                    }
                };

                // Get system info
                if (navigator.hardwareConcurrency) {
                    const coresEl = document.getElementById('t-cores');
                    if (coresEl) coresEl.textContent = navigator.hardwareConcurrency;
                }

                // Set default to unlimited
                const fpsSelect = document.getElementById('fpsSelect');
                if (fpsSelect) {
                    fpsSelect.value = '0';
                    fpsSelect.addEventListener('change', (e) => {
                        fpsLimit = parseInt(e.target.value);
                        console.log('FPS Limit set to:', fpsLimit === 0 ? 'Unlimited' : fpsLimit);
                    });
                }
            }

            // REAL delta time measurement
            const frameStart = performance.now();
            const realDeltaMs = frameStart - window.telemetryData.lastFrameStart;
            window.telemetryData.lastFrameStart = frameStart;
            // PERF: Circular buffer - O(1) instead of O(n) for shift
            window.telemetryData.frameTimes[window.telemetryData.frameTimeIndex] = realDeltaMs;
            window.telemetryData.frameTimeIndex = (window.telemetryData.frameTimeIndex + 1) % 100;
            if (window.telemetryData.frameTimeCount < 100) window.telemetryData.frameTimeCount++;

            // PERF: Cache telemetry bar reference and use simple style check instead of getClientRects
            if (!window.telemetryData.telemetryBar) {
                window.telemetryData.telemetryBar = document.getElementById('telemetry-bar');
            }
            const telemetryBar = window.telemetryData.telemetryBar;
            const telemetryVisible = telemetryBar && telemetryBar.style.display !== 'none';

            if (currentTime - fpsUpdateTime >= 200) { // 5x per second for responsiveness
                const els = window.telemetryData.elements; // Use cached elements
                currentFPS = Math.round((frameCount * 1000) / (currentTime - fpsUpdateTime));
                
                // PERF: Skip all DOM updates if telemetry is hidden
                if (telemetryVisible) {
                    const frameTime = realDeltaMs.toFixed(1);

                    // Calculate 1% low (worst 1% of frame times) - PERF: Use max finding instead of full sort
                    const frameTimes = window.telemetryData.frameTimes;
                    let maxFrameTime = 0;
                    for (let i = 0; i < frameTimes.length; i++) {
                        if (frameTimes[i] > maxFrameTime) maxFrameTime = frameTimes[i];
                    }
                    const onePercentLow = Math.round(1000 / maxFrameTime);

                    // === FPS DISPLAY ===
                    if (els.fps) {
                        els.fps.textContent = currentFPS;
                        els.fps.style.color = currentFPS < 30 ? '#ff4444' : currentFPS < 60 ? '#ffaa00' : '#00ff88';
                    }

                    // 1% Low FPS
                    if (els.low1) {
                        els.low1.textContent = onePercentLow;
                        els.low1.style.color = onePercentLow < 20 ? '#ff4444' : onePercentLow < 40 ? '#ffaa00' : '#00ff88';
                    }

                    // Frame time (average)
                    if (els.ft) els.ft.textContent = (1000 / currentFPS).toFixed(1);

                    // Delta time (actual last frame)
                    if (els.dt) els.dt.textContent = frameTime;

                    // === REAL RENDERER INFO ===
                    if (activeRenderer && activeRenderer.info) {
                        const renderInfo = activeRenderer.info;

                        // Triangles
                        if (els.tris) {
                            const tris = renderInfo.render.triangles;
                            els.tris.textContent = tris > 1000000 ? (tris / 1000000).toFixed(1) + 'M' : (tris / 1000).toFixed(1) + 'K';
                        }

                        // Draw Calls
                        if (els.calls) els.calls.textContent = renderInfo.render.calls;

                        // Geometries (REAL from renderer.info.memory)
                        if (els.geom) els.geom.textContent = renderInfo.memory.geometries;

                        // Textures (REAL from renderer.info.memory)
                        if (els.tex) els.tex.textContent = renderInfo.memory.textures;
                    }

                    // === GPU USAGE (Inferred from frame time) ===
                    if (els.gpu) {
                        // GPU load estimation: higher frame times = higher GPU load
                        // Normalize against target (16.67ms for 60fps)
                        const targetFrameTime = 16.67;
                        const gpuLoad = Math.min(100, Math.max(0, (parseFloat(frameTime) / targetFrameTime) * 100));
                        els.gpu.textContent = Math.round(gpuLoad);
                        els.gpu.style.color = gpuLoad > 90 ? '#ff4444' : gpuLoad > 70 ? '#ffaa00' : '#ff00ff';

                        // Update GPU graph
                        window.telemetryData.gpuHistory.push(gpuLoad);
                        window.telemetryData.gpuHistory.shift();
                        drawSparkline(els.cGPU, window.telemetryData.gpuHistory, '#ff00ff', 100);
                    }

                    // === CPU USAGE (Inferred from script execution time) ===
                    if (els.cpu) {
                        // Estimate CPU load from time between frames
                        const cpuLoad = Math.min(100, Math.max(0, (realDeltaMs / 16.67) * 100));
                        els.cpu.textContent = Math.round(cpuLoad);
                        els.cpu.style.color = cpuLoad > 90 ? '#ff4444' : cpuLoad > 70 ? '#ffaa00' : '#00ccff';

                        // Update CPU graph
                        window.telemetryData.cpuHistory.push(cpuLoad);
                        window.telemetryData.cpuHistory.shift();
                        drawSparkline(els.cCPU, window.telemetryData.cpuHistory, '#00ccff', 100);
                    }

                    // === RAM USAGE (REAL from performance.memory) ===
                    if (els.ram && performance.memory) {
                        const totalHeap = Math.floor(performance.memory.totalJSHeapSize / 1048576);
                        const usedHeap = Math.floor(performance.memory.usedJSHeapSize / 1048576);
                        const heapLimit = Math.floor(performance.memory.jsHeapSizeLimit / 1048576);

                        els.ram.textContent = usedHeap;
                        els.ram.style.color = (usedHeap / heapLimit > 0.8) ? '#ff4444' : (usedHeap / heapLimit > 0.6) ? '#ffaa00' : '#88ff44';

                        // Update RAM graph (as percentage of limit)
                        const ramPercent = (usedHeap / heapLimit) * 100;
                        window.telemetryData.ramHistory.push(ramPercent);
                        window.telemetryData.ramHistory.shift();
                        drawSparkline(els.cRAM, window.telemetryData.ramHistory, '#88ff44', 100);
                    }

                    // === MEMORY (REAL when available) ===
                    if (els.mem) {
                        if (performance.memory) {
                            els.mem.textContent = Math.floor(performance.memory.usedJSHeapSize / 1048576);
                        } else {
                            els.mem.textContent = 'N/A';
                        }
                    }

                    // === NETWORK STATS (REAL for multiplayer) ===
                    if (els.ping) {
                        if (isMultiplayer && window.telemetryData.pingRTT > 0) {
                            const ping = Math.round(window.telemetryData.pingRTT);
                            els.ping.textContent = ping;
                            const netColor = ping > 150 ? '#ff4444' : ping > 80 ? '#ffaa00' : '#00ff88';
                            els.ping.style.color = netColor;

                            // Update ping graph
                            window.telemetryData.pingHistory.push(ping);
                            window.telemetryData.pingHistory.shift();
                            drawSparkline(els.cPing, window.telemetryData.pingHistory, netColor, 200);
                        } else {
                            els.ping.textContent = isMultiplayer ? '...' : '0';
                        }
                    }

                    // Packet Loss
                    if (els.loss) {
                        if (isMultiplayer && window.telemetryData.packetsSent > 0) {
                            const loss = ((window.telemetryData.packetsSent - window.telemetryData.packetsReceived) / window.telemetryData.packetsSent) * 100;
                            els.loss.textContent = Math.max(0, loss).toFixed(1);
                        } else {
                            els.loss.textContent = '0.0';
                        }
                    }

                    // Jitter (variance in ping)
                    if (els.jitter) {
                        if (isMultiplayer && window.telemetryData.pingSamples.length > 5) {
                            const samples = window.telemetryData.pingSamples;
                            const avg = samples.reduce((a, b) => a + b, 0) / samples.length;
                            const variance = samples.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / samples.length;
                            const jitter = Math.sqrt(variance);
                            els.jitter.textContent = Math.round(jitter);
                        } else {
                            els.jitter.textContent = '0';
                        }
                    }

                    // === GAME STATS ===
                    if (els.score) els.score.textContent = (window.gameState ? window.gameState.score : 0);
                    if (els.kills) els.kills.textContent = (window.gameState ? window.gameState.kills : 0);
                    // === PLAYER POSITION (REAL) ===
                    if (els.pos && activeCamera) {
                        els.pos.textContent = Math.floor(activeCamera.position.x) + ',' + Math.floor(activeCamera.position.y) + ',' + Math.floor(activeCamera.position.z);
                    }

                    // === UPTIME ===
                    if (els.uptime) {
                        const elapsed = (performance.now() - window.telemetryData.startTime) / 1000;
                        const mins = Math.floor(elapsed / 60);
                        const secs = Math.floor(elapsed % 60);
                        els.uptime.textContent = mins.toString().padStart(2, '0') + ':' + secs.toString().padStart(2, '0');
                    }
                } // PERF: End of telemetryVisible block

                frameCount = 0;
                fpsUpdateTime = currentTime;
            }
        }

        // ==================== VOICE CHAT SYSTEM ====================
        let localStream = null;
        let remoteAudio = null;
        let voiceConnection = null;
        let isMicMuted = true;
        let isPushToTalk = true;
        let isVoiceChatEnabled = false;
        let mediaCall = null;
        let voiceGainNode = null;
        let voiceAudioContext = null;
        let opponentIsSpeaking = false;
        let voiceAnalyser = null;
        let voiceDataArray = null;
        let voiceDetectionInterval = null;
        let lastSpeakingState = false;
        let remoteVoiceAnalyser = null;
        let remoteVoiceDataArray = null;

        // Voice Chat Functions
        const VoiceChat = {
            // Initialize voice chat system
            async init() {
                console.log('🎤 Initializing voice chat system...');

                // Create audio context for distance-based volume (will resume on user interaction)
                try {
                    voiceAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                    console.log('🎤 Voice AudioContext created, state:', voiceAudioContext.state);
                } catch (e) {
                    console.warn('⚠️ AudioContext not available for voice distance');
                }

                // Create remote audio element for opponent's voice
                remoteAudio = document.createElement('audio');
                remoteAudio.autoplay = true;
                remoteAudio.playsInline = true;
                remoteAudio.id = 'remoteAudio';
                // Ensure audio can play
                remoteAudio.muted = false;
                remoteAudio.volume = 1.0;
                document.body.appendChild(remoteAudio);

                // Setup UI
                this.setupUI();

                console.log('✅ Voice chat system initialized');
            },

            // Bind UI + push-to-talk handlers
            setupUI() {
                if (this._uiBound) {
                    this.updateUI();
                    return;
                }
                this._uiBound = true;

                const micButton = document.getElementById('micButton');
                if (micButton) {
                    micButton.addEventListener('click', async () => {
                        // Click counts as user gesture; request mic if needed
                        if (!isVoiceChatEnabled) {
                            const ok = await this.startVoice();
                            if (!ok) return;
                        }
                        this.toggleMic();
                    });
                }

                const isTyping = () => {
                    const el = document.activeElement;
                    if (!el) return false;
                    const tag = (el.tagName || '').toUpperCase();
                    return tag === 'INPUT' || tag === 'TEXTAREA' || el.isContentEditable;
                };

                document.addEventListener('keydown', async (e) => {
                    if (e.code !== 'KeyV' || e.repeat) return;
                    if (isTyping()) return;

                    // Ensure mic permission on first use
                    if (!isVoiceChatEnabled) {
                        const ok = await this.startVoice();
                        if (!ok) return;
                    }

                    // Push-to-talk: hold V to talk
                    if (isPushToTalk) {
                        this.unmute();
                    } else {
                        // Toggle mode: pressing V toggles
                        this.toggleMic();
                    }
                });

                document.addEventListener('keyup', (e) => {
                    if (e.code !== 'KeyV') return;
                    if (isPushToTalk) {
                        this.mute();
                    }
                });

                this.updateUI();
            },

            // Resume audio context (call after user interaction)
            async resumeAudioContext() {
                if (voiceAudioContext && voiceAudioContext.state === 'suspended') {
                    try {
                        await voiceAudioContext.resume();
                        console.log('🎤 Voice AudioContext resumed, state:', voiceAudioContext.state);
                    } catch (e) {
                        console.warn('⚠️ Failed to resume Voice AudioContext:', e);
                    }
                }
            },

            // Request microphone access and start streaming
            async startVoice() {
                try {
                    console.log('🎤 Requesting microphone access...');

                    // Resume audio context first (needs user interaction)
                    await this.resumeAudioContext();

                    localStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true,
                            sampleRate: 48000
                        },
                        video: false
                    });

                    console.log('✅ Microphone access granted, tracks:', localStream.getAudioTracks().length);

                    // Log audio track info
                    localStream.getAudioTracks().forEach((track, i) => {
                        console.log(`🎤 Audio track ${i}: ${track.label}, enabled: ${track.enabled}, muted: ${track.muted}`);
                    });

                    isVoiceChatEnabled = true;

                    // Setup voice activity detection for local mic
                    this.setupVoiceActivityDetection(localStream);

                    // Start muted by default
                    this.mute();

                    // Show voice chat UI
                    const voiceContainer = document.getElementById('voiceChatContainer');
                    if (voiceContainer) {
                        voiceContainer.classList.add('active');
                    }

                    return true;
                } catch (err) {
                    console.error('❌ Microphone access denied:', err);
                    isVoiceChatEnabled = false;
                    return false;
                }
            },

            // Setup voice activity detection to know when user is actually speaking
            setupVoiceActivityDetection(stream) {
                try {
                    if (!voiceAudioContext) {
                        voiceAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }

                    // Ensure audio context is running
                    if (voiceAudioContext.state === 'suspended') {
                        voiceAudioContext.resume();
                    }

                    console.log('🎤 Setting up VAD, AudioContext state:', voiceAudioContext.state);

                    const source = voiceAudioContext.createMediaStreamSource(stream);
                    voiceAnalyser = voiceAudioContext.createAnalyser();
                    voiceAnalyser.fftSize = 512;
                    voiceAnalyser.smoothingTimeConstant = 0.4;

                    source.connect(voiceAnalyser);
                    voiceDataArray = new Uint8Array(voiceAnalyser.frequencyBinCount);

                    console.log('🎤 Voice activity detection setup complete, analyser bins:', voiceAnalyser.frequencyBinCount);

                    // Start monitoring voice activity
                    this.startVoiceActivityMonitoring();
                } catch (e) {
                    console.warn('⚠️ Could not setup voice activity detection:', e);
                }
            },

            // Monitor local microphone for voice activity
            startVoiceActivityMonitoring() {
                if (voiceDetectionInterval) {
                    clearInterval(voiceDetectionInterval);
                }

                const SPEAKING_THRESHOLD = 15; // Lower threshold for better detection
                const SMOOTHING_FRAMES = 2; // Fewer frames for faster response
                let speakingFrameCount = 0;
                let silentFrameCount = 0;
                let debugCounter = 0;

                voiceDetectionInterval = setInterval(() => {
                    if (!voiceAnalyser || !voiceDataArray || isMicMuted) {
                        // If muted, ensure we show as not speaking
                        if (lastSpeakingState) {
                            lastSpeakingState = false;
                            this.updateLocalSpeakingUI(false);
                        }
                        return;
                    }

                    // Make sure AudioContext is running
                    if (voiceAudioContext && voiceAudioContext.state === 'suspended') {
                        voiceAudioContext.resume();
                    }

                    voiceAnalyser.getByteFrequencyData(voiceDataArray);

                    // Calculate average volume level
                    let sum = 0;
                    let max = 0;
                    for (let i = 0; i < voiceDataArray.length; i++) {
                        sum += voiceDataArray[i];
                        if (voiceDataArray[i] > max) max = voiceDataArray[i];
                    }
                    const avgVolume = sum / voiceDataArray.length;

                    // PERF: Debug logging disabled for performance (uncomment for debugging)
                    // debugCounter++;
                    // if (debugCounter % 20 === 0) {
                    //     console.log(`🎤 VAD: avg=${avgVolume.toFixed(1)}, max=${max}, threshold=${SPEAKING_THRESHOLD}, muted=${isMicMuted}`);
                    // }

                    // Detect speaking state with smoothing
                    if (avgVolume > SPEAKING_THRESHOLD) {
                        speakingFrameCount++;
                        silentFrameCount = 0;

                        if (speakingFrameCount >= SMOOTHING_FRAMES && !lastSpeakingState) {
                            // PERF: console.log disabled for performance
                            // console.log('🎤 Speaking detected! avgVolume:', avgVolume);
                            lastSpeakingState = true;
                            this.updateLocalSpeakingUI(true);
                            // Send speaking status to other player
                            if (window.sendToOther && window.isMultiplayer) {
                                window.sendToOther({ type: 'voiceStatus', speaking: true, volume: avgVolume });
                            }
                        }
                    } else {
                        silentFrameCount++;
                        speakingFrameCount = 0;

                        if (silentFrameCount >= SMOOTHING_FRAMES * 3 && lastSpeakingState) {
                            // PERF: console.log disabled for performance
                            // console.log('🎤 Stopped speaking');
                            lastSpeakingState = false;
                            this.updateLocalSpeakingUI(false);
                            // Send stopped speaking status
                            if (window.sendToOther && window.isMultiplayer) {
                                window.sendToOther({ type: 'voiceStatus', speaking: false });
                            }
                        }
                    }
                }, 50); // Check every 50ms for responsive detection
            },

            // Update local UI based on actual speaking state
            updateLocalSpeakingUI(isSpeaking) {
                const micButton = document.getElementById('micButton');
                const voiceStatus = document.getElementById('voiceStatus');

                if (micButton) {
                    if (isSpeaking && !isMicMuted) {
                        micButton.classList.add('speaking');
                        micButton.classList.remove('muted');
                    } else if (isMicMuted) {
                        micButton.classList.add('muted');
                        micButton.classList.remove('speaking');
                    } else {
                        micButton.classList.remove('speaking', 'muted');
                    }
                }

                if (voiceStatus && !isMicMuted) {
                    if (isSpeaking) {
                        voiceStatus.classList.add('speaking');
                        voiceStatus.textContent = '🔴 SPEAKING';
                    } else {
                        voiceStatus.classList.remove('speaking');
                        voiceStatus.textContent = '🟢 LIVE (LISTENING)';
                    }
                }
            },

            // Setup distance-based audio processing with realistic physics
            setupDistanceAudio(stream) {
                console.log('🔊 Setting up realistic distance audio...');

                if (!voiceAudioContext) {
                    try {
                        voiceAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                    } catch (e) {
                        console.warn('⚠️ Could not create AudioContext');
                        remoteAudio.srcObject = stream;
                        this.tryPlayRemoteAudio();
                        return;
                    }
                }

                if (voiceAudioContext.state === 'suspended') {
                    voiceAudioContext.resume();
                }

                try {
                    const source = voiceAudioContext.createMediaStreamSource(stream);

                    // Analyser for voice activity detection
                    remoteVoiceAnalyser = voiceAudioContext.createAnalyser();
                    remoteVoiceAnalyser.fftSize = 512;
                    remoteVoiceAnalyser.smoothingTimeConstant = 0.4;
                    remoteVoiceDataArray = new Uint8Array(remoteVoiceAnalyser.frequencyBinCount);

                    // === REALISTIC AUDIO CHAIN ===

                    // 1. PRE-EMPHASIS: Boost presence frequencies for clarity at close range
                    this.voicePresenceFilter = voiceAudioContext.createBiquadFilter();
                    this.voicePresenceFilter.type = 'peaking';
                    this.voicePresenceFilter.frequency.value = 3000; // Voice presence frequency
                    this.voicePresenceFilter.Q.value = 1.0;
                    this.voicePresenceFilter.gain.value = 3; // Boost for clarity

                    // 2. AIR ABSORPTION: High frequencies absorbed by air over distance
                    this.voiceAirAbsorption = voiceAudioContext.createBiquadFilter();
                    this.voiceAirAbsorption.type = 'lowpass';
                    this.voiceAirAbsorption.frequency.value = 12000; // Full bandwidth close
                    this.voiceAirAbsorption.Q.value = 0.5;

                    // 3. DISTANCE ROLLOFF: Second low-pass for additional muffling
                    this.voiceLowPassFilter = voiceAudioContext.createBiquadFilter();
                    this.voiceLowPassFilter.type = 'lowpass';
                    this.voiceLowPassFilter.frequency.value = 10000;
                    this.voiceLowPassFilter.Q.value = 0.7;

                    // 4. HIGH-PASS: Remove rumble, increases with distance (thinner sound)
                    this.voiceHighPassFilter = voiceAudioContext.createBiquadFilter();
                    this.voiceHighPassFilter.type = 'highpass';
                    this.voiceHighPassFilter.frequency.value = 80;
                    this.voiceHighPassFilter.Q.value = 0.5;

                    // 5. MAIN GAIN: Volume based on inverse-square law
                    voiceGainNode = voiceAudioContext.createGain();
                    voiceGainNode.gain.value = 1.0;

                    // 6. EARLY REFLECTIONS: Short delay simulating nearby surfaces
                    this.earlyReflection1 = voiceAudioContext.createDelay(0.1);
                    this.earlyReflection1.delayTime.value = 0.015; // 15ms
                    this.earlyReflection1Gain = voiceAudioContext.createGain();
                    this.earlyReflection1Gain.gain.value = 0;

                    this.earlyReflection2 = voiceAudioContext.createDelay(0.1);
                    this.earlyReflection2.delayTime.value = 0.025; // 25ms
                    this.earlyReflection2Gain = voiceAudioContext.createGain();
                    this.earlyReflection2Gain.gain.value = 0;

                    // 7. LATE REVERB: Longer delay for outdoor/room ambience
                    this.lateReverb = voiceAudioContext.createDelay(0.5);
                    this.lateReverb.delayTime.value = 0.08; // 80ms
                    this.lateReverbGain = voiceAudioContext.createGain();
                    this.lateReverbGain.gain.value = 0;

                    // Filter for reverb (darker reverb tail)
                    this.reverbFilter = voiceAudioContext.createBiquadFilter();
                    this.reverbFilter.type = 'lowpass';
                    this.reverbFilter.frequency.value = 2000;
                    this.reverbFilter.Q.value = 0.5;

                    // 8. OUTPUT COMPRESSOR: Keeps levels consistent
                    this.voiceCompressor = voiceAudioContext.createDynamicsCompressor();
                    this.voiceCompressor.threshold.value = -24;
                    this.voiceCompressor.knee.value = 12;
                    this.voiceCompressor.ratio.value = 4;
                    this.voiceCompressor.attack.value = 0.003;
                    this.voiceCompressor.release.value = 0.25;

                    const destination = voiceAudioContext.destination;

                    // === AUDIO ROUTING ===
                    // Main chain: source -> analyser -> presence -> airAbsorb -> lowpass -> highpass -> gain -> compressor -> out
                    source.connect(remoteVoiceAnalyser);
                    remoteVoiceAnalyser.connect(this.voicePresenceFilter);
                    this.voicePresenceFilter.connect(this.voiceAirAbsorption);
                    this.voiceAirAbsorption.connect(this.voiceLowPassFilter);
                    this.voiceLowPassFilter.connect(this.voiceHighPassFilter);
                    this.voiceHighPassFilter.connect(voiceGainNode);
                    voiceGainNode.connect(this.voiceCompressor);
                    this.voiceCompressor.connect(destination);

                    // Early reflections (from main gain)
                    voiceGainNode.connect(this.earlyReflection1);
                    this.earlyReflection1.connect(this.earlyReflection1Gain);
                    this.earlyReflection1Gain.connect(this.voiceCompressor);

                    voiceGainNode.connect(this.earlyReflection2);
                    this.earlyReflection2.connect(this.earlyReflection2Gain);
                    this.earlyReflection2Gain.connect(this.voiceCompressor);

                    // Late reverb (filtered for darker tail)
                    voiceGainNode.connect(this.reverbFilter);
                    this.reverbFilter.connect(this.lateReverb);
                    this.lateReverb.connect(this.lateReverbGain);
                    this.lateReverbGain.connect(this.voiceCompressor);

                    // Mute HTML audio element
                    remoteAudio.srcObject = stream;
                    remoteAudio.muted = true;

                    this.startRemoteVoiceMonitoring();
                    console.log('✅ Realistic distance audio processing enabled');
                } catch (e) {
                    console.warn('⚠️ Audio setup failed:', e);
                    remoteAudio.srcObject = stream;
                    this.tryPlayRemoteAudio();
                }
            },

            // Try to play remote audio (handle autoplay restrictions)
            tryPlayRemoteAudio() {
                if (remoteAudio && remoteAudio.srcObject) {
                    remoteAudio.play().then(() => {
                        console.log('🔊 Remote audio playing');
                    }).catch(e => {
                        console.warn('⚠️ Could not autoplay remote audio:', e);
                        // Will play when user interacts
                    });
                }
            },

            // Monitor remote audio stream for actual speaking activity
            startRemoteVoiceMonitoring() {
                console.log('🔊 Starting remote voice monitoring');
                const SPEAKING_THRESHOLD = 10; // Even lower threshold for remote audio
                let remoteDebugCounter = 0;
                let lastRemoteSpeaking = false;

                let remoteMonitorInterval = setInterval(() => {
                    if (!remoteVoiceAnalyser || !remoteVoiceDataArray) {
                        return;
                    }

                    // Make sure AudioContext is running
                    if (voiceAudioContext && voiceAudioContext.state === 'suspended') {
                        voiceAudioContext.resume();
                    }

                    remoteVoiceAnalyser.getByteFrequencyData(remoteVoiceDataArray);

                    // Calculate average volume
                    let sum = 0;
                    let max = 0;
                    for (let i = 0; i < remoteVoiceDataArray.length; i++) {
                        sum += remoteVoiceDataArray[i];
                        if (remoteVoiceDataArray[i] > max) max = remoteVoiceDataArray[i];
                    }
                    const avgVolume = sum / remoteVoiceDataArray.length;

                    // Debug logging every second
                    remoteDebugCounter++;
                    if (remoteDebugCounter % 20 === 0) {
                        console.log(`🔊 Remote VAD: avg=${avgVolume.toFixed(1)}, max=${max}, threshold=${SPEAKING_THRESHOLD}`);
                    }

                    // Update opponent speaking indicator based on actual audio
                    const indicator = document.getElementById('opponentSpeaking');
                    const nameEl = document.getElementById('opponentSpeakerName');

                    if (avgVolume > SPEAKING_THRESHOLD) {
                        if (!lastRemoteSpeaking) {
                            console.log('🔊 Remote speaking detected! avgVolume:', avgVolume);
                            lastRemoteSpeaking = true;
                            opponentIsSpeaking = true;
                            if (indicator) {
                                indicator.classList.add('visible');
                            }
                            // Set opponent name
                            if (nameEl && window.gameState && window.gameState.otherPlayerUsername) {
                                nameEl.textContent = window.gameState.otherPlayerUsername;
                            }
                        }
                        // Update the volume indicator visually
                        if (indicator) {
                            const intensity = Math.min(1, avgVolume / 80);
                            indicator.style.boxShadow = `0 8px 30px rgba(0, 0, 0, 0.4), 0 0 ${40 + intensity * 40}px rgba(80, 255, 80, ${0.3 + intensity * 0.4})`;
                        }
                    } else {
                        if (lastRemoteSpeaking) {
                            console.log('🔊 Remote stopped speaking');
                            lastRemoteSpeaking = false;
                            opponentIsSpeaking = false;
                            if (indicator) {
                                indicator.classList.remove('visible');
                            }
                        }
                    }

                    // Update distance display continuously
                    this.updateVoiceDistance();
                }, 50);

                // Store interval for cleanup
                this._remoteMonitorInterval = remoteMonitorInterval;
                console.log('🔊 Remote voice monitoring started');
            },

            // Update voice volume based on distance to opponent - REALISTIC PHYSICS
            updateVoiceDistance() {
                // Get opponent position from window-exposed variable
                let opponentPos = null;
                if (window.otherPlayer && window.otherPlayer.position) {
                    opponentPos = window.otherPlayer.position;
                }

                // Get camera/player position from window-exposed variable
                let playerPos = null;
                if (window.camera && window.camera.position) {
                    playerPos = window.camera.position;
                }

                // Calculate distance if we have both positions
                let distance = 0;
                if (opponentPos && playerPos) {
                    distance = playerPos.distanceTo(opponentPos);
                }

                // Apply realistic physics-based audio effects
                if (voiceAudioContext && distance > 0) {
                    const currentTime = voiceAudioContext.currentTime;

                    // === REALISTIC AUDIO PHYSICS CONSTANTS ===
                    const REFERENCE_DISTANCE = 1;      // 1 meter = full volume
                    const MAX_DISTANCE = 80;           // Beyond this, barely audible
                    const ROLLOFF_FACTOR = 1.2;        // How quickly sound drops (1 = realistic, higher = faster)
                    const AIR_ABSORPTION_COEFF = 0.002; // dB per meter per kHz (air absorbs high freq)
                    const SPEED_OF_SOUND = 343;        // meters per second

                    // Clamp distance
                    const clampedDistance = Math.max(REFERENCE_DISTANCE, Math.min(distance, MAX_DISTANCE));

                    // === 1. INVERSE-SQUARE LAW VOLUME ===
                    // Sound intensity decreases with square of distance
                    // Formula: 1 / (1 + rolloff * (distance - 1))
                    const distanceRatio = clampedDistance / REFERENCE_DISTANCE;
                    let volume = 1 / Math.pow(distanceRatio, ROLLOFF_FACTOR);

                    // Apply additional atmospheric attenuation (exponential decay)
                    const atmosphericLoss = Math.exp(-0.01 * clampedDistance);
                    volume *= atmosphericLoss;

                    // Ensure minimum audible volume
                    volume = Math.max(0.02, Math.min(1.0, volume));

                    if (voiceGainNode) {
                        voiceGainNode.gain.setTargetAtTime(volume, currentTime, 0.08);
                    }

                    // === 2. AIR ABSORPTION (High frequencies absorbed first) ===
                    // Low-pass filter simulates air absorption: -6dB per doubling of distance above 2kHz
                    // Close: 12kHz, Far: 400Hz (very muffled)
                    if (this.voiceLowPassFilter) {
                        // Logarithmic curve for natural rolloff
                        const distanceFactor = Math.log10(clampedDistance + 1) / Math.log10(MAX_DISTANCE + 1);
                        const lowPassFreq = 12000 * Math.pow(0.033, distanceFactor); // 12000Hz -> 400Hz
                        const clampedLPF = Math.max(400, Math.min(12000, lowPassFreq));
                        this.voiceLowPassFilter.frequency.setTargetAtTime(clampedLPF, currentTime, 0.12);

                        // Reduce Q at distance for softer rolloff (more natural)
                        const lpfQ = 0.7 - distanceFactor * 0.4; // 0.7 -> 0.3
                        this.voiceLowPassFilter.Q.setTargetAtTime(Math.max(0.3, lpfQ), currentTime, 0.1);
                    }

                    // === 3. BASS REDUCTION AT DISTANCE ===
                    // Actually bass travels further, but with distance the overall
                    // perception is "thinner" due to relative frequency balance
                    if (this.voiceHighPassFilter) {
                        // Subtle high-pass increase at distance
                        const distanceFactor = Math.pow(clampedDistance / MAX_DISTANCE, 0.5);
                        const highPassFreq = 60 + distanceFactor * 180; // 60Hz -> 240Hz
                        this.voiceHighPassFilter.frequency.setTargetAtTime(highPassFreq, currentTime, 0.12);
                    }

                    // === 4. AIR ABSORPTION FILTER ===
                    // High frequencies absorbed more over distance
                    if (this.voiceAirAbsorption) {
                        const distanceFactor = Math.pow(clampedDistance / MAX_DISTANCE, 0.8);
                        // 12kHz close, 2kHz far (air absorbs highs)
                        const airAbsorbFreq = 12000 - distanceFactor * 10000;
                        this.voiceAirAbsorption.frequency.setTargetAtTime(Math.max(2000, airAbsorbFreq), currentTime, 0.12);
                    }

                    // === 5. PRESENCE/CLARITY REDUCTION ===
                    // Voice clarity (2-4kHz) reduces with distance
                    if (this.voicePresenceFilter) {
                        const distanceFactor = Math.pow(clampedDistance / MAX_DISTANCE, 0.7);
                        // Boost presence close (+3dB), reduce at distance (-6dB)
                        const presenceGain = 3 - distanceFactor * 9;
                        this.voicePresenceFilter.gain.setTargetAtTime(presenceGain, currentTime, 0.15);
                    }

                    // === 6. EARLY REFLECTIONS (room/terrain bounce) ===
                    // Increase reflection level with distance
                    if (this.earlyReflection1Gain && this.earlyReflection2Gain) {
                        const distanceFactor = Math.pow(clampedDistance / MAX_DISTANCE, 0.5);
                        // 0% reflection close, up to 15% far
                        const reflectMix = distanceFactor * 0.15;
                        this.earlyReflection1Gain.gain.setTargetAtTime(reflectMix, currentTime, 0.15);
                        this.earlyReflection2Gain.gain.setTargetAtTime(reflectMix * 0.7, currentTime, 0.15);

                        // Increase delay times slightly with distance
                        if (this.earlyReflection1 && this.earlyReflection2) {
                            const baseDelay1 = 0.015 + distanceFactor * 0.02; // 15ms -> 35ms
                            const baseDelay2 = 0.025 + distanceFactor * 0.03; // 25ms -> 55ms
                            this.earlyReflection1.delayTime.setTargetAtTime(baseDelay1, currentTime, 0.1);
                            this.earlyReflection2.delayTime.setTargetAtTime(baseDelay2, currentTime, 0.1);
                        }
                    }

                    // === 7. LATE REVERB (outdoor ambience) ===
                    // More reverb at distance simulates outdoor sound dispersion
                    if (this.lateReverbGain && this.lateReverb) {
                        const distanceFactor = Math.pow(clampedDistance / MAX_DISTANCE, 0.6);
                        // 0% reverb close, up to 25% reverb far
                        const reverbMix = distanceFactor * 0.25;
                        this.lateReverbGain.gain.setTargetAtTime(reverbMix, currentTime, 0.2);

                        // Increase reverb delay with distance
                        const reverbDelay = 0.08 + distanceFactor * 0.12; // 80ms -> 200ms
                        this.lateReverb.delayTime.setTargetAtTime(reverbDelay, currentTime, 0.15);

                        // Darken reverb tail at distance
                        if (this.reverbFilter) {
                            const reverbCutoff = 2000 - distanceFactor * 1200; // 2kHz -> 800Hz
                            this.reverbFilter.frequency.setTargetAtTime(Math.max(800, reverbCutoff), currentTime, 0.15);
                        }
                    }

                    // === 8. DYNAMIC COMPRESSION ===
                    // At distance, compress more to simulate outdoor dynamics
                    if (this.voiceCompressor) {
                        const distanceFactor = clampedDistance / MAX_DISTANCE;
                        // Compress harder at distance
                        const ratio = 4 + distanceFactor * 8; // 4:1 -> 12:1
                        const threshold = -20 - distanceFactor * 10; // -20dB -> -30dB
                        this.voiceCompressor.ratio.setTargetAtTime(ratio, currentTime, 0.1);
                        this.voiceCompressor.threshold.setTargetAtTime(threshold, currentTime, 0.1);
                    }

                    // Debug log occasionally
                    if (Math.random() < 0.02) {
                        const lpf = this.voiceLowPassFilter ? this.voiceLowPassFilter.frequency.value.toFixed(0) : 'N/A';
                        console.log(`🔊 Voice Physics: ${distance.toFixed(1)}m | vol=${(volume * 100).toFixed(0)}% | lpf=${lpf}Hz | delay=${(clampedDistance / SPEED_OF_SOUND * 1000).toFixed(0)}ms`);
                    }
                }

                // Always update distance display if the indicator is visible
                const distanceEl = document.getElementById('voiceDistance');
                const indicator = document.getElementById('opponentSpeaking');

                if (distanceEl) {
                    if (distance > 0) {
                        distanceEl.textContent = `${Math.round(distance)}m`;
                        // Color based on distance
                        if (distance < 15) {
                            distanceEl.style.color = 'rgba(100, 255, 100, 1)';
                        } else if (distance < 30) {
                            distanceEl.style.color = 'rgba(255, 255, 100, 1)';
                        } else {
                            distanceEl.style.color = 'rgba(255, 150, 100, 0.8)';
                        }
                    } else {
                        // If we can't calculate distance, show a dash
                        distanceEl.textContent = '-- m';
                        distanceEl.style.color = 'rgba(180, 255, 180, 0.8)';
                    }
                }

                return distance;
            },

            // Call the other player (for host)
            callPeer(peerId) {
                if (!peer) {
                    console.warn('⚠️ Cannot call - peer not ready');
                    return;
                }
                if (!localStream) {
                    console.warn('⚠️ Cannot call - localStream not ready, tracks:', localStream?.getAudioTracks?.()?.length);
                    return;
                }

                console.log('📞 Calling peer:', peerId);
                console.log('📞 Local stream tracks:', localStream.getAudioTracks().length);
                localStream.getAudioTracks().forEach((t, i) => {
                    console.log(`📞 Track ${i}: enabled=${t.enabled}, muted=${t.muted}, readyState=${t.readyState}`);
                });

                mediaCall = peer.call(peerId, localStream);

                if (mediaCall) {
                    console.log('📞 Call initiated, waiting for stream...');
                    mediaCall.on('stream', (remoteStream) => {
                        console.log('🔊 Received remote audio stream from call');
                        console.log('🔊 Remote stream tracks:', remoteStream.getAudioTracks().length);
                        this.setupDistanceAudio(remoteStream);
                    });

                    mediaCall.on('close', () => {
                        console.log('📞 Call ended');
                    });

                    mediaCall.on('error', (err) => {
                        console.error('❌ Call error:', err);
                    });
                } else {
                    console.error('❌ peer.call returned null');
                }
            },

            // Answer incoming call (for joining player)
            answerCall(call) {
                if (!localStream) {
                    console.warn('⚠️ Cannot answer - stream not ready, will wait for it');
                    // Try to start voice first, then answer
                    this.startVoice().then(() => {
                        if (localStream) {
                            this._doAnswerCall(call);
                        } else {
                            console.error('❌ Still no localStream after startVoice');
                        }
                    });
                    return;
                }

                this._doAnswerCall(call);
            },

            // Actually answer the call
            _doAnswerCall(call) {
                console.log('📞 Answering call with localStream...');
                console.log('📞 Local stream tracks:', localStream.getAudioTracks().length);
                localStream.getAudioTracks().forEach((t, i) => {
                    console.log(`📞 Track ${i}: enabled=${t.enabled}, muted=${t.muted}, readyState=${t.readyState}`);
                });

                call.answer(localStream);

                call.on('stream', (remoteStream) => {
                    console.log('🔊 Received remote audio stream from answer');
                    console.log('🔊 Remote stream tracks:', remoteStream.getAudioTracks().length);
                    this.setupDistanceAudio(remoteStream);
                });

                call.on('close', () => {
                    console.log('📞 Call ended');
                });

                call.on('error', (err) => {
                    console.error('❌ Call error:', err);
                });

                mediaCall = call;
            },

            // Toggle microphone mute
            toggleMic() {
                if (isMicMuted) {
                    this.unmute();
                    isPushToTalk = false; // Switch to toggle mode
                } else {
                    this.mute();
                    isPushToTalk = true; // Back to push-to-talk
                }
            },

            // Mute microphone
            mute() {
                if (localStream) {
                    localStream.getAudioTracks().forEach(track => {
                        track.enabled = false;
                    });
                }
                isMicMuted = true;
                lastSpeakingState = false;
                this.updateUI();

                // Notify opponent we stopped speaking (only send once)
                if (window.sendToOther && window.isMultiplayer) {
                    window.sendToOther({ type: 'voiceStatus', speaking: false });
                }
            },

            // Unmute microphone
            unmute() {
                console.log('🎤 Unmuting microphone...');

                // Resume audio context if suspended
                if (voiceAudioContext && voiceAudioContext.state === 'suspended') {
                    voiceAudioContext.resume().then(() => {
                        console.log('🎤 AudioContext resumed on unmute');
                    });
                }

                if (localStream) {
                    localStream.getAudioTracks().forEach(track => {
                        track.enabled = true;
                        console.log('🎤 Track enabled:', track.label);
                    });
                } else {
                    console.warn('⚠️ No localStream to unmute');
                }
                isMicMuted = false;
                this.updateUI();
                console.log('🎤 Microphone unmuted, VAD should start detecting');
            },

            // Update UI based on state
            updateUI() {
                const micButton = document.getElementById('micButton');
                const voiceStatus = document.getElementById('voiceStatus');

                if (micButton) {
                    micButton.classList.remove('muted', 'speaking');
                    if (isMicMuted) {
                        micButton.classList.add('muted');
                    } else {
                        // Don't add speaking class here - let voice activity detection handle it
                    }
                }

                if (voiceStatus) {
                    voiceStatus.classList.remove('muted', 'speaking');
                    if (isMicMuted) {
                        voiceStatus.classList.add('muted');
                        voiceStatus.textContent = isPushToTalk ? 'PUSH V TO TALK' : 'MUTED';
                    } else {
                        // Show ready state, voice detection will update when speaking
                        voiceStatus.textContent = '🟢 LIVE';
                    }
                }
            },

            // Show opponent speaking indicator
            showOpponentSpeaking(speaking, name) {
                const indicator = document.getElementById('opponentSpeaking');
                const nameEl = document.getElementById('opponentSpeakerName');

                opponentIsSpeaking = speaking;

                if (indicator) {
                    if (speaking) {
                        indicator.classList.add('visible');
                        if (nameEl && name) {
                            nameEl.textContent = name;
                        }
                        // Start distance updates
                        this.updateVoiceDistance();
                    } else {
                        indicator.classList.remove('visible');
                    }
                }
            },

            // Stop voice chat
            stop() {
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    localStream = null;
                }

                if (mediaCall) {
                    mediaCall.close();
                    mediaCall = null;
                }

                // Clear voice detection intervals
                if (voiceDetectionInterval) {
                    clearInterval(voiceDetectionInterval);
                    voiceDetectionInterval = null;
                }
                if (this._remoteMonitorInterval) {
                    clearInterval(this._remoteMonitorInterval);
                    this._remoteMonitorInterval = null;
                }

                isVoiceChatEnabled = false;
                isMicMuted = true;
                opponentIsSpeaking = false;
                lastSpeakingState = false;

                const voiceContainer = document.getElementById('voiceChatContainer');
                if (voiceContainer) {
                    voiceContainer.classList.remove('active');
                }

                console.log('🎤 Voice chat stopped');
            }
        };

        // Update voice distance in animation loop (will be called from animate())
        window.updateVoiceDistance = function () {
            if (window.VoiceChat) {
                window.VoiceChat.updateVoiceDistance();
            }
        };

        // Debug function to test voice chat manually
        window.testVoiceChat = async function () {
            console.log('=== VOICE CHAT DEBUG ===');
            console.log('VoiceChat object:', !!VoiceChat);
            console.log('localStream:', !!localStream);
            console.log('voiceAudioContext:', voiceAudioContext?.state);
            console.log('voiceAnalyser:', !!voiceAnalyser);
            console.log('remoteVoiceAnalyser:', !!remoteVoiceAnalyser);
            console.log('voiceGainNode:', !!voiceGainNode);
            console.log('mediaCall:', !!mediaCall);
            console.log('isMicMuted:', isMicMuted);
            console.log('isVoiceChatEnabled:', isVoiceChatEnabled);
            console.log('opponentIsSpeaking:', opponentIsSpeaking);

            if (localStream) {
                console.log('Local tracks:', localStream.getAudioTracks().length);
                localStream.getAudioTracks().forEach((t, i) => {
                    console.log(`  Track ${i}: enabled=${t.enabled}, muted=${t.muted}, state=${t.readyState}`);
                });
            }

            // Test mic if available
            if (voiceAnalyser && voiceDataArray) {
                voiceAnalyser.getByteFrequencyData(voiceDataArray);
                let sum = 0, max = 0;
                for (let i = 0; i < voiceDataArray.length; i++) {
                    sum += voiceDataArray[i];
                    if (voiceDataArray[i] > max) max = voiceDataArray[i];
                }
                console.log('Current mic level:', (sum / voiceDataArray.length).toFixed(1), 'max:', max);
            }

            console.log('=== END DEBUG ===');
        };

        // Initialize voice chat on load
        window.VoiceChat = VoiceChat;
        document.addEventListener('DOMContentLoaded', () => {
            VoiceChat.init();
        });
        let otherPlayerId = null;
        let currentRoomId = null;
        let useWebRTC = true; // Use WebRTC by default (no server needed!)
        let gameMode = '1v1'; // '1v1' or '2v2'
        window.gameMode = '1v1'; // Expose globally for lobby squad list
        let myTeam = 1; // 1 or 2
        window.myTeam = 1; // Expose globally for lobby squad list

        // Initialize minimal gameState early for lobby name sync (full state set in initGame)
        var gameState = {
            playerUsername: '',
            otherPlayerUsername: '',
            otherPlayerLevel: 1,
            otherPlayerAvatar: null,
            otherPlayerSkin: 'soldier',
            started: false
        };
        window.gameState = gameState; // Expose early for menu scene
        let otherPlayers = []; // Array for 2v2 mode (up to 3 other players)
        let playerConnections = new Map(); // Map of playerId -> connection/dataChannel for 2v2
        let roomPlayers = []; // All players in the room
        window.roomPlayers = roomPlayers; // Expose globally
        let squadData = new Map(); // Map of playerId -> { health, weapon, isDying, username }
        window.squadData = squadData; // Expose globally

        // ==================== MAP SELECTION SYSTEM ====================
        let selectedMap = 'default'; // 'default' or 'map1'
        let loadedMapMesh = null; // Store the loaded map mesh for cleanup

        // Map selection function
        function selectMap(mapName) {
            selectedMap = mapName;
            console.log('🗺️ Map selected:', mapName);

            // Update UI
            document.querySelectorAll('.map-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            const selectedOption = document.querySelector(`.map-option[data-map="${mapName}"]`);
            if (selectedOption) {
                selectedOption.classList.add('selected');
            }
        }

        // Expose to window for onclick
        window.selectMap = selectMap;

        // ==================== SKIN SELECTION SYSTEM ====================
        let selectedSkin = 'soldier'; // 'soldier' or 'briefcase'
        let menuCharacterObject = null; // Store reference to menu character
        let menuCharacterMixer = null; // Store animation mixer

        // Skin configuration
        const SKIN_CONFIG = {
            soldier: {
                fbx: './RifleIdle.fbx',
                texture: './T_PostalDude.png',
                scale: 0.012,
                name: 'Soldier',
                // Nametag settings (relative to head bone)
                nametagScale: { x: 65, y: 16, z: 1 },
                nametagPos: { x: 0, y: 15, z: 0 },
                // Opponent nametag (slightly higher)
                opponentNametagPos: { x: 0, y: 25, z: 0 }
            },
            briefcase: {
                fbx: './Standing W_Briefcase Idle.fbx',
                // Multiple textures for different mesh parts
                textures: {
                    body: './pyramid/body_diff.png',
                    hands: './pyramid/hands_diff.png',
                    helmet: './pyramid/hemlet_diff.png'
                },
                scale: 1.09,
                name: 'Pyramid Head',
                // Nametag settings - scaled to match emote nametag size
                nametagScale: { x: 0.6, y: 0.14, z: 1 },
                nametagPos: { x: 0, y: 0.002, z: 0 },
                // Opponent nametag (slightly higher)
                opponentNametagPos: { x: 0, y: 0.4, z: 0 },
                // Emote configuration
                emote: {
                    fbx: './pyramidemote/dance.fbx',
                    music: './pyramidemote/emote.mp3'
                }
            },
            skeleton: {
                fbx: './skeleton/idle.fbx',  // Animation file
                modelFbx: './skeleton/spookyskele1_%230000_fbx.fbx',  // Model with geometry (# encoded as %23)
                scale: 0.0119,  // Matched to soldier height
                name: 'Skeleton',
                preserveMaterials: true,  // Keep original FBX materials
                // Nametag settings
                nametagScale: { x: 65, y: 16, z: 1 },
                nametagPos: { x: 0, y: 15, z: 0 },
                opponentNametagPos: { x: 0, y: 25, z: 0 },
                // Comprehensive animation library
                animations: {
                    // Idle animations
                    idle: './skeleton/idle.fbx',
                    idleAiming: './skeleton/idle aiming.fbx',
                    idleCrouching: './skeleton/idle crouching.fbx',
                    idleCrouchingAiming: './skeleton/idle crouching aiming.fbx',

                    // Walking animations
                    walkForward: './skeleton/walk forward.fbx',
                    walkBackward: './skeleton/walk backward.fbx',
                    walkLeft: './skeleton/walk left.fbx',
                    walkRight: './skeleton/walk right.fbx',
                    walkForwardLeft: './skeleton/walk forward left.fbx',
                    walkForwardRight: './skeleton/walk forward right.fbx',
                    walkBackwardLeft: './skeleton/walk backward left.fbx',
                    walkBackwardRight: './skeleton/walk backward right.fbx',

                    // Crouching walk animations
                    walkCrouchingForward: './skeleton/walk crouching forward.fbx',
                    walkCrouchingBackward: './skeleton/walk crouching backward.fbx',
                    walkCrouchingLeft: './skeleton/walk crouching left.fbx',
                    walkCrouchingRight: './skeleton/walk crouching right.fbx',
                    walkCrouchingForwardLeft: './skeleton/walk crouching forward left.fbx',
                    walkCrouchingForwardRight: './skeleton/walk crouching forward right.fbx',
                    walkCrouchingBackwardLeft: './skeleton/walk crouching backward left.fbx',
                    walkCrouchingBackwardRight: './skeleton/walk crouching backward right.fbx',

                    // Running animations
                    runForward: './skeleton/run Forward.fbx',
                    runBackward: './skeleton/run backward.fbx',
                    runLeft: './skeleton/run left.fbx',
                    runRight: './skeleton/run right.fbx',
                    runForwardLeft: './skeleton/run forward left.fbx',
                    runForwardRight: './skeleton/run forward right.fbx',
                    runBackwardLeft: './skeleton/run backward left.fbx',
                    runBackwardRight: './skeleton/run backward right.fbx',

                    // Sprint animations
                    sprintForward: './skeleton/sprint forward.fbx',
                    sprintBackward: './skeleton/sprint backward.fbx',
                    sprintLeft: './skeleton/sprint left.fbx',
                    sprintRight: './skeleton/sprint right.fbx',
                    sprintForwardLeft: './skeleton/sprint forward left.fbx',
                    sprintForwardRight: './skeleton/sprint forward right.fbx',
                    sprintBackwardLeft: './skeleton/sprint backward left.fbx',
                    sprintBackwardRight: './skeleton/sprint backward right.fbx',

                    // Jump animations
                    jumpUp: './skeleton/jump up.fbx',
                    jumpLoop: './skeleton/jump loop.fbx',
                    jumpDown: './skeleton/jump down.fbx',

                    // Turn animations
                    turn90Left: './skeleton/turn 90 left.fbx',
                    turn90Right: './skeleton/turn 90 right.fbx',
                    crouchingTurn90Left: './skeleton/crouching turn 90 left.fbx',
                    crouchingTurn90Right: './skeleton/crouching turn 90 right.fbx',

                    // Death animations
                    deathFront: './skeleton/death from the front.fbx',
                    deathBack: './skeleton/death from the back.fbx',
                    deathRight: './skeleton/death from right.fbx',
                    deathFrontHeadshot: './skeleton/death from front headshot.fbx',
                    deathBackHeadshot: './skeleton/death from back headshot.fbx',
                    deathCrouchingHeadshot: './skeleton/death crouching headshot front.fbx'
                }
            },
            zombie: {
                fbx: './zombieskin/zombie-crouch-idle.glb',
                scale: 0.37,
                name: 'Zombie',
                nametagScale: { x: 65, y: 16, z: 1 },
                nametagPos: { x: 0, y: 15, z: 0 },
                opponentNametagPos: { x: 0, y: 25, z: 0 },
                opponentNametagPos: { x: 0, y: 2.0, z: 0 },
                format: 'glb',
                animationName: 'Idle Crouching Aiming',
                preserveMaterials: true
            }
        };

        // =============================================
        // ANIMATION RETARGETING HELPER
        // =============================================
        // For Mixamo animations on Mixamo models, bones should match directly.
        // This function only does light retargeting if needed.
        function retargetAnimationClip(clip, targetModel) {
            // Get all bone names from the target model
            const targetBoneNames = new Set();
            const targetBoneMap = {};

            targetModel.traverse((child) => {
                if (child.isBone) {
                    targetBoneNames.add(child.name);
                    // Also map cleaned versions
                    const cleaned = child.name.replace(/^mixamorig:?/, '').replace(/^mixamorig\d+:?/, '');
                    targetBoneMap[cleaned] = child.name;
                    targetBoneMap[child.name] = child.name;
                }
            });

            // Check how many tracks already match
            let directMatchCount = 0;
            clip.tracks.forEach(track => {
                const boneName = track.name.split('.')[0];
                if (targetBoneNames.has(boneName)) {
                    directMatchCount++;
                }
            });

            // If 80%+ match directly, no retargeting needed!
            if (directMatchCount >= clip.tracks.length * 0.8) {
                console.log('💀 Animation bones match directly (' + directMatchCount + '/' + clip.tracks.length + '), no retargeting needed');
                return clip;
            }

            console.log('💀 Need retargeting: only ' + directMatchCount + '/' + clip.tracks.length + ' direct matches');

            // Retarget tracks
            const newTracks = [];
            clip.tracks.forEach((track) => {
                const parts = track.name.split('.');
                const boneName = parts[0];
                const property = parts.slice(1).join('.');

                // Try to find matching bone
                let targetBone = null;

                // Direct match
                if (targetBoneNames.has(boneName)) {
                    targetBone = boneName;
                } else {
                    // Try cleaned name
                    const cleaned = boneName.replace(/^mixamorig:?/, '').replace(/^mixamorig\d+:?/, '');
                    if (targetBoneMap[cleaned]) {
                        targetBone = targetBoneMap[cleaned];
                    }
                }

                if (targetBone) {
                    const newTrack = track.clone();
                    newTrack.name = targetBone + '.' + property;
                    newTracks.push(newTrack);
                }
            });

            if (newTracks.length === 0) {
                console.warn('💀 Retargeting failed, returning original clip');
                return clip;
            }

            console.log('💀 Retargeted ' + newTracks.length + ' tracks');
            return new THREE.AnimationClip(clip.name, clip.duration, newTracks);
        }

        // =============================================
        // ANIMATION SANITIZER - Remove scale tracks AND root motion
        // =============================================
        // Mixamo animations downloaded WITHOUT "In Place" have root motion baked in.
        // This removes the position tracks from the root/hip bone to make them "in place"
        function sanitizeAnimationClip(clip) {
            const cleanTracks = [];
            let removedScaleTracks = 0;
            let removedRootMotion = 0;

            for (let i = 0; i < clip.tracks.length; i++) {
                const track = clip.tracks[i];
                const trackName = track.name.toLowerCase();

                // Remove scale tracks (Mixamo scale bugs)
                if (track.name.includes('.scale')) {
                    removedScaleTracks++;
                    continue;
                }

                // Remove root motion (position tracks on hip/root bone)
                // This makes animations "in place" even if downloaded without that option
                const isRootBone = trackName.includes('hips') ||
                    trackName.includes('root') ||
                    trackName.includes('pelvis') ||
                    trackName.includes('mixamorig:hips') ||
                    trackName.includes('mixamorigHips');

                const isPositionTrack = track.name.includes('.position');

                if (isRootBone && isPositionTrack) {
                    // Keep only Y position (vertical movement for jumps/crouching)
                    // But zero out X and Z to remove horizontal sliding
                    if (track.name.endsWith('.position')) {
                        // This is a Vector3 position track - we need to zero X and Z
                        const values = track.values;
                        for (let j = 0; j < values.length; j += 3) {
                            values[j] = 0;     // Zero X (left/right)
                            // values[j + 1] stays (Y - up/down for crouching/jumping)
                            values[j + 2] = 0; // Zero Z (forward/backward)
                        }
                        cleanTracks.push(track);
                        removedRootMotion++;
                    }
                } else {
                    cleanTracks.push(track);
                }
            }

            if (removedScaleTracks > 0 || removedRootMotion > 0) {
                console.log('💀 Sanitized clip: removed', removedScaleTracks, 'scale tracks,', removedRootMotion, 'root motion tracks zeroed');
            }

            clip.tracks = cleanTracks;
            return clip;
        }

        // =============================================
        // SKELETON ANIMATION SYSTEM
        // =============================================
        const SkeletonAnimationSystem = {
            // Animation cache - stores loaded animation clips
            animationCache: new Map(),

            // Mixer reference for each skeleton instance
            mixers: new Map(),

            // Model references for retargeting
            models: new Map(),

            // Retargeted clips cache
            retargetedClips: new Map(),

            // Current animation state for each skeleton
            currentStates: new Map(),

            // Crossfade duration - balanced for responsive yet smooth transitions
            CROSSFADE_DURATION: 0.2,

            // Load all skeleton animations
            async loadAnimations() {
                if (this.animationsLoaded) return;
                console.log('💀 Loading skeleton animations...');

                const skinConfig = SKIN_CONFIG.skeleton;
                if (!skinConfig || !skinConfig.animations) {
                    console.warn('💀 Skeleton animations config not found');
                    return;
                }

                const loader = new THREE.FBXLoader();
                const loadPromises = [];

                for (const [animName, animPath] of Object.entries(skinConfig.animations)) {
                    const promise = new Promise((resolve) => {
                        loader.load(animPath, (object) => {
                            if (object.animations && object.animations.length > 0) {
                                let clip = object.animations[0];

                                // Sanitize clip - remove scale tracks that cause deformation
                                clip = sanitizeAnimationClip(clip);

                                clip.name = animName;
                                this.animationCache.set(animName, clip);
                                console.log(`💀 Loaded animation: ${animName}`);
                            }
                            resolve();
                        }, undefined, (error) => {
                            console.warn(`💀 Failed to load animation ${animName}:`, error);
                            resolve();
                        });
                    });
                    loadPromises.push(promise);
                }

                await Promise.all(loadPromises);
                this.animationsLoaded = true;
                console.log(`💀 Loaded ${this.animationCache.size} skeleton animations`);
            },

            // Create a mixer for a skeleton model
            createMixer(skeletonId, model) {
                const mixer = new THREE.AnimationMixer(model);
                this.mixers.set(skeletonId, mixer);

                // Store model reference for retargeting
                this.models.set(skeletonId, model);

                this.currentStates.set(skeletonId, {
                    animation: null,
                    action: null,
                    isCrouching: false,
                    isAiming: false,
                    isSprinting: false,
                    isJumping: false,
                    isDead: false,
                    velocity: { x: 0, z: 0 }
                });

                // Start with idle animation
                this.playAnimation(skeletonId, 'idle');

                return mixer;
            },

            // Get animation name based on movement state
            getAnimationForState(state) {
                const { velocity, isCrouching, isSprinting, isJumping, isDead, isAiming, jumpPhase } = state;

                // Death takes priority
                if (isDead) {
                    return state.deathType || 'deathFront';
                }

                // Jump takes priority over movement - use proper jump phase
                if (isJumping) {
                    if (jumpPhase === 'up') return 'jumpUp';
                    if (jumpPhase === 'down') return 'jumpDown';
                    return 'jumpLoop'; // Default to loop (in air)
                }

                const speed = Math.sqrt(velocity.x * velocity.x + velocity.z * velocity.z);
                const isMoving = speed > 0.5; // Slightly higher threshold

                // Not moving - idle animations
                if (!isMoving) {
                    if (isCrouching && isAiming) return 'idleCrouchingAiming';
                    if (isCrouching) return 'idleCrouching';
                    if (isAiming) return 'idleAiming';
                    return 'idle';
                }

                // Determine movement direction from velocity
                let direction = '';
                const absX = Math.abs(velocity.x);
                const absZ = Math.abs(velocity.z);

                // Forward/backward (Z axis - negative is forward in Three.js)
                if (velocity.z < -0.5) direction = 'Forward';
                else if (velocity.z > 0.5) direction = 'Backward';

                // Strafe component (X axis)
                if (velocity.x < -0.5) direction += 'Left';
                else if (velocity.x > 0.5) direction += 'Right';

                // Pure strafe if no forward/backward
                if (!direction) {
                    if (velocity.x < -0.5) direction = 'Left';
                    else if (velocity.x > 0.5) direction = 'Right';
                    else direction = 'Forward'; // Fallback
                }

                // Determine animation prefix based on speed and state
                let prefix = 'walk';
                if (isSprinting && speed > 10) {
                    prefix = 'sprint';
                } else if (isCrouching) {
                    prefix = 'walkCrouching';
                } else if (speed > 6) {
                    prefix = 'run';
                }

                const animName = prefix + direction;
                return animName;
            },

            // Play a specific animation with crossfade
            playAnimation(skeletonId, animName, options = {}) {
                const mixer = this.mixers.get(skeletonId);
                const state = this.currentStates.get(skeletonId);

                if (!mixer || !state) {
                    console.warn('💀 No mixer found for skeleton:', skeletonId);
                    return;
                }

                // Don't replay same animation (unless speed changed significantly)
                if (state.animation === animName && !options.force) {
                    // Just update speed if animation is same
                    if (state.action && options.speed !== undefined) {
                        state.action.timeScale = options.speed;
                    }
                    return;
                }

                let clip = this.animationCache.get(animName);
                if (!clip) {
                    // Fallback to idle if animation not found
                    if (animName !== 'idle') {
                        console.warn(`💀 Animation not found: ${animName}, falling back to idle`);
                        this.playAnimation(skeletonId, 'idle');
                    }
                    return;
                }

                // Retarget clip to model if needed (only once per clip+model combo)
                const model = this.models.get(skeletonId);
                if (model) {
                    const retargetKey = animName + '_' + skeletonId;
                    if (!this.retargetedClips.has(retargetKey)) {
                        const retargeted = retargetAnimationClip(clip, model);
                        this.retargetedClips.set(retargetKey, retargeted);
                    }
                    clip = this.retargetedClips.get(retargetKey);
                }

                // Get or create action for this clip
                const newAction = mixer.clipAction(clip);

                // Configure action
                const isOneShot = options.loop === false || animName.startsWith('death');
                if (isOneShot) {
                    newAction.setLoop(THREE.LoopOnce);
                    newAction.clampWhenFinished = true;
                } else {
                    newAction.setLoop(THREE.LoopRepeat);
                }

                // Set animation speed to match movement (prevents skating)
                newAction.timeScale = options.speed || 1.0;

                // Properly crossfade from previous animation
                const fadeTime = options.crossfade || this.CROSSFADE_DURATION;

                if (state.action && state.action !== newAction) {
                    // Crossfade: fade out old, fade in new
                    state.action.fadeOut(fadeTime);
                    newAction.reset();
                    newAction.fadeIn(fadeTime);
                    newAction.play();
                } else {
                    // First animation or same action
                    newAction.reset();
                    newAction.fadeIn(fadeTime);
                    newAction.play();
                }

                state.animation = animName;
                state.action = newAction;
            },

            // Update animation based on movement state
            updateState(skeletonId, newState) {
                const state = this.currentStates.get(skeletonId);
                if (!state) return;

                // Don't update if animations aren't loaded yet
                if (!this.animationsLoaded || this.animationCache.size === 0) {
                    return;
                }

                // Update state
                Object.assign(state, newState);

                // Determine correct animation
                const animName = this.getAnimationForState(state);

                // Calculate animation speed multiplier based on actual velocity
                // REDUCED SPEEDS to prevent overly fast animations
                const speed = Math.sqrt(state.velocity.x * state.velocity.x + state.velocity.z * state.velocity.z);
                let animSpeed = 0.6; // Base slower speed

                if (animName.startsWith('death')) {
                    // Death animations - normal speed, let them play naturally
                    animSpeed = 1.0;
                } else if (animName.startsWith('walk')) {
                    // Walk animations - slower for natural movement
                    animSpeed = Math.max(0.4, Math.min(0.8, speed / 6));
                } else if (animName.startsWith('run')) {
                    // Run animations - moderate speed
                    animSpeed = Math.max(0.5, Math.min(0.9, speed / 10));
                } else if (animName.startsWith('sprint')) {
                    // Sprint animations - slightly faster but still controlled
                    animSpeed = Math.max(0.6, Math.min(1.0, speed / 14));
                } else if (animName === 'idle') {
                    // Idle animation - nice slow pace
                    animSpeed = 0.5;
                } else if (animName.startsWith('jump')) {
                    // Jump animations - normal speed
                    animSpeed = 1.0;
                }

                this.playAnimation(skeletonId, animName, { speed: animSpeed });
            },

            // Update all mixers
            update(deltaTime) {
                this.mixers.forEach((mixer) => {
                    mixer.update(deltaTime);
                });
            },

            // Clean up a skeleton instance
            dispose(skeletonId) {
                const mixer = this.mixers.get(skeletonId);
                if (mixer) {
                    mixer.stopAllAction();
                }
                this.mixers.delete(skeletonId);
                this.currentStates.delete(skeletonId);
            }
        };

        // Expose animation system globally
        window.SkeletonAnimationSystem = SkeletonAnimationSystem;

        // Emote system
        let isEmoting = false;
        let emoteAudio = null;
        let originalAnimation = null;
        let emoteMixer = null;

        function playEmote() {
            // Debug: log current state
            console.log('💃 playEmote called');
            console.log('💃 window.selectedSkin:', window.selectedSkin);
            console.log('💃 local selectedSkin:', selectedSkin);
            console.log('💃 isEmoting:', isEmoting);

            if (isEmoting) {
                stopEmote();
                return;
            }

            const currentSkin = window.selectedSkin || 'soldier';
            const skinConfig = SKIN_CONFIG[currentSkin];

            console.log('💃 currentSkin resolved to:', currentSkin);
            console.log('💃 skinConfig:', skinConfig);
            console.log('💃 skinConfig.emote:', skinConfig?.emote);

            if (!skinConfig || !skinConfig.emote) {
                console.log('💃 ❌ No emote available for skin:', currentSkin);
                console.log('💃 Available skins:', Object.keys(SKIN_CONFIG));
                console.log('💃 SKIN_CONFIG:', SKIN_CONFIG);
                return;
            }

            console.log('💃 Playing emote for:', currentSkin);
            isEmoting = true;

            // Play emote music
            if (skinConfig.emote.music) {
                emoteAudio = new Audio(skinConfig.emote.music);
                const emoteRouted = ensureMediaElementThroughTrauma(emoteAudio);
                if (emoteRouted && emoteRouted.gainNode) {
                    emoteRouted.gainNode.gain.value = 0.5;
                    emoteAudio.volume = 1;
                } else {
                    emoteAudio.volume = 0.5;
                }
                emoteAudio.play().catch(e => console.log('Audio play failed:', e));
                emoteAudio.onended = () => {
                    stopEmote();
                };
            }

            // Notify menu scene to play emote animation
            if (window.playMenuEmote) {
                window.playMenuEmote(skinConfig.emote.fbx);
            }

            // Send emote to other player in multiplayer
            if (window.sendToOther && window.isMultiplayer) {
                console.log('📤 Sending emote to opponent, skin:', currentSkin);
                window.sendToOther({ type: 'emote', skin: currentSkin });
            }

            // Update button state
            const emoteButton = document.getElementById('emoteButton');
            if (emoteButton) {
                emoteButton.classList.add('playing');
                emoteButton.innerHTML = '⏹️ STOP (E)';
            }
        }

        function stopEmote() {
            if (!isEmoting) return;

            console.log('💃 Stopping emote');
            isEmoting = false;

            if (emoteAudio) {
                emoteAudio.pause();
                emoteAudio.currentTime = 0;
                emoteAudio = null;
            }

            // Notify menu scene to stop emote
            if (window.stopMenuEmote) {
                window.stopMenuEmote();
            }

            // Send stop signal to other player
            if (window.sendToOther && window.isMultiplayer) {
                console.log('📤 Sending emoteStop to opponent');
                window.sendToOther({ type: 'emoteStop' });
            }

            // Update button state
            const emoteButton = document.getElementById('emoteButton');
            if (emoteButton) {
                emoteButton.classList.remove('playing');
                emoteButton.innerHTML = '💃 DANCE (E)';
            }
        }

        window.playEmote = playEmote;
        window.stopEmote = stopEmote;

        // Skin selection function
        function selectSkin(skinName) {
            console.log('👤 selectSkin called with:', skinName);
            console.log('👤 SKIN_CONFIG[skinName]:', SKIN_CONFIG[skinName]);
            console.log('👤 Has emote:', !!(SKIN_CONFIG[skinName]?.emote));

            if (!SKIN_CONFIG[skinName]) {
                console.warn('Unknown skin:', skinName);
                return;
            }

            // Stop any playing emote when switching skins
            if (window.stopEmote) {
                window.stopEmote();
            }

            selectedSkin = skinName;
            window.selectedSkin = skinName; // Sync to global so playEmote() can access it
            console.log('👤 Skin selected:', skinName, '| window.selectedSkin =', window.selectedSkin);

            // Save to localStorage
            try {
                localStorage.setItem('taya7_selected_skin', skinName);
            } catch (e) { }

            // Update UI
            document.querySelectorAll('.skin-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            const selectedOption = document.querySelector(`.skin-option[data-skin="${skinName}"]`);
            if (selectedOption) {
                selectedOption.classList.add('selected');
            }

            // Show/hide emote button based on skin
            const emoteButton = document.getElementById('emoteButton');
            if (emoteButton) {
                const skinConfig = SKIN_CONFIG[skinName];
                if (skinConfig && skinConfig.emote) {
                    emoteButton.classList.add('visible');
                } else {
                    emoteButton.classList.remove('visible');
                }
            }

            // Update menu character if it exists
            if (window.updateMenuCharacterSkin) {
                window.updateMenuCharacterSkin(skinName);
            }

            // Broadcast skin change to other players in lobby
            if (window.isMultiplayer && window.sendToOther) {
                console.log('📡 Broadcasting skin change:', skinName);
                window.sendToOther({ type: 'skinChange', skin: skinName });
            }
        }

        // Load saved skin preference
        try {
            const savedSkin = localStorage.getItem('taya7_selected_skin');
            if (savedSkin && SKIN_CONFIG[savedSkin]) {
                selectedSkin = savedSkin;
                window.selectedSkin = savedSkin; // CRITICAL: Sync to global so playEmote() works!
                // Update UI on page load
                document.addEventListener('DOMContentLoaded', () => {
                    document.querySelectorAll('.skin-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    const selectedOption = document.querySelector(`.skin-option[data-skin="${savedSkin}"]`);
                    if (selectedOption) {
                        selectedOption.classList.add('selected');
                    }
                    // Show emote button if skin has emote
                    const emoteButton = document.getElementById('emoteButton');
                    const skinConfig = SKIN_CONFIG[savedSkin];
                    if (emoteButton && skinConfig && skinConfig.emote) {
                        emoteButton.classList.add('visible');
                    }
                });
            }
        } catch (e) { }

        // Keyboard listener for emote (E key) - only in menu/lobby
        document.addEventListener('keydown', (e) => {
            if (e.code === 'KeyE' && !e.ctrlKey && !e.shiftKey && !e.altKey) {
                // Only trigger emote if in menu (not in game)
                const menuContainer = document.getElementById('menuContainer');
                if (menuContainer && menuContainer.style.display !== 'none') {
                    // Check if any input is focused
                    const activeElement = document.activeElement;
                    if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
                        return; // Don't trigger emote while typing
                    }
                    if (window.playEmote) {
                        window.playEmote();
                    }
                }
            }
        });

        // Expose to window for onclick
        window.selectSkin = selectSkin;
        window.SKIN_CONFIG = SKIN_CONFIG;
        window.selectedSkin = selectedSkin;

        // Socket.IO server URLs (required for 2v2 mode, fallback for 1v1)
        // IMPORTANT: For 2v2 mode, you MUST have a server running!
        // Option 1: Start local server: Run "node server.js" in terminal
        // Option 2: Use a remote server: Add your server URL here
        const SERVER_URLS = [
            'http://localhost:3000',  // Local server (run: node server.js)
            // Add your remote server URL here if you have one:
            // 'https://your-server.railway.app',
            // 'https://your-server.glitch.me',
        ];

        let currentServerIndex = 0;
        let connectionQuality = 'unknown'; // 'good', 'medium', 'poor', 'unknown'

        // ✅ WebRTC MULTIPLAYER - NO SERVER NEEDED!
        // The game now uses WebRTC (PeerJS) for peer-to-peer connections.
        // This means:
        // - ✅ No server setup required!
        // - ✅ Works from anywhere in the world!
        // - ✅ Free to use (uses public PeerJS signaling server)
        // - ✅ Direct connection between players (low latency)
        // 
        // Socket.IO is kept as a fallback option if WebRTC fails.

        // ==================== LEVEL & XP SYSTEM ====================
        const LevelSystem = {
            // XP required for each level - VERY HARD TO LEVEL UP!
            // Takes 20-30+ matches to level up at higher levels
            getXPForLevel: function (level) {
                if (level <= 1) return 1000;     // Level 1->2: 1000 XP (~5 matches)
                if (level <= 5) return 1500;     // Level 2-5: 1500 XP each (~7-8 matches)
                if (level <= 10) return 2500;    // Level 6-10: 2500 XP each (~12 matches)
                if (level <= 15) return 3500;    // Level 11-15: 3500 XP each (~17 matches)
                if (level <= 20) return 4500;    // Level 16-20: 4500 XP each (~22 matches)
                if (level <= 25) return 5500;    // Level 21-25: 5500 XP each (~27 matches)
                if (level <= 30) return 6500;    // Level 26-30: 6500 XP each (~32 matches)
                // Post-30: Extremely hard grind
                return 7500;                     // 30+: 7500 XP each (~37 matches per level!)
            },

            // XP rewards - reduced for harder progression
            XP_REWARDS: {
                KILL: 20,           // Per kill XP
                HEADSHOT: 10,       // Bonus for headshot kills
                WIN: 150,           // Match win bonus
                LOSE: 80,           // Match loss XP
                MATCH_COMPLETE: 30  // Base XP for completing a match
            },

            // Player progression data
            data: {
                level: 1,
                currentXP: 0,
                totalXP: 0,
                totalKills: 0,
                totalDeaths: 0,
                totalWins: 0,
                totalLosses: 0,
                matchesPlayed: 0
            },

            // Load from localStorage
            load: function () {
                try {
                    const saved = localStorage.getItem('taya7_player_data');
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        this.data = { ...this.data, ...parsed };
                        console.log('📊 Player data loaded:', this.data);
                    }
                } catch (e) {
                    console.warn('Failed to load player data:', e);
                }
                this.updateUI();
            },

            // Save to localStorage
            save: function () {
                try {
                    localStorage.setItem('taya7_player_data', JSON.stringify(this.data));
                    console.log('💾 Player data saved');
                } catch (e) {
                    console.warn('Failed to save player data:', e);
                }
            },

            // Add XP and handle level ups
            addXP: function (amount, reason = '') {
                if (amount <= 0) return;

                this.data.currentXP += amount;
                this.data.totalXP += amount;

                // Show XP popup
                this.showXPPopup(amount, reason);

                // Check for level up
                let xpNeeded = this.getXPForLevel(this.data.level);
                while (this.data.currentXP >= xpNeeded) {
                    this.data.currentXP -= xpNeeded;
                    this.data.level++;
                    this.showLevelUpPopup(this.data.level);
                    xpNeeded = this.getXPForLevel(this.data.level);
                }

                this.updateUI();
                this.save();
            },

            // Record a kill
            recordKill: function (isHeadshot = false) {
                this.data.totalKills++;
                let xp = this.XP_REWARDS.KILL;
                let reason = '+KILL';
                if (isHeadshot) {
                    xp += this.XP_REWARDS.HEADSHOT;
                    reason = '+HEADSHOT';
                }
                this.addXP(xp, reason);
            },

            // Record a death
            recordDeath: function () {
                this.data.totalDeaths++;
                this.save();
                this.updateUI();
            },

            // Record match end
            recordMatchEnd: function (won) {
                this.data.matchesPlayed++;
                if (won) {
                    this.data.totalWins++;
                    this.addXP(this.XP_REWARDS.WIN, '+VICTORY');
                } else {
                    this.data.totalLosses++;
                    this.addXP(this.XP_REWARDS.LOSE, '+MATCH');
                }
            },

            // Update all UI elements
            updateUI: function () {
                const xpNeeded = this.getXPForLevel(this.data.level);
                const xpPercent = (this.data.currentXP / xpNeeded) * 100;

                // Old HUD elements (kept for compatibility)
                const hudLevel = document.getElementById('hudLevelNumber');
                const hudXpBar = document.getElementById('hudXpBar');
                const hudXpText = document.getElementById('hudXpText');

                if (hudLevel) hudLevel.textContent = this.data.level;
                if (hudXpBar) hudXpBar.style.width = xpPercent + '%';
                if (hudXpText) hudXpText.textContent = `${this.data.currentXP} / ${xpNeeded} XP`;

                // Minecraft XP Bar HUD
                const mcLevelNum = document.getElementById('mcLevelNum');
                const mcXpFill = document.getElementById('mcXpFill');

                if (mcLevelNum) mcLevelNum.textContent = this.data.level;
                if (mcXpFill) mcXpFill.style.width = xpPercent + '%';

                // Update menu 3D nametag if it exists
                if (window.updateMenuNametag) {
                    window.updateMenuNametag();
                }
            },

            // Show XP gain popup
            showXPPopup: function (amount, reason) {
                const popup = document.createElement('div');
                popup.className = 'xp-popup';
                popup.textContent = `+${amount} XP ${reason}`;
                document.body.appendChild(popup);

                setTimeout(() => popup.remove(), 1500);
            },

            // Show level up popup
            showLevelUpPopup: function (newLevel) {
                const popup = document.createElement('div');
                popup.className = 'level-up-popup';
                popup.innerHTML = `
                    <div class="level-up-title">LEVEL UP!</div>
                    <div class="level-up-number">${newLevel}</div>
                `;
                document.body.appendChild(popup);

                // Animate Minecraft level number
                const mcLevelNum = document.getElementById('mcLevelNum');
                if (mcLevelNum) {
                    mcLevelNum.classList.add('level-up');
                    setTimeout(() => mcLevelNum.classList.remove('level-up'), 500);
                }

                // Play Minecraft XP level up sound
                if (window.mcLevelUpSoundMedia) {
                    try {
                        window.mcLevelUpSoundMedia.play(0.5);
                    } catch (e) {
                        console.warn('Could not play level up sound (media):', e);
                    }
                } else if (window.mcLevelUpSoundBuffer && typeof ensureAudioContext === 'function') {
                    try {
                        const ctx = ensureAudioContext();
                        if (ctx) {
                            const source = ctx.createBufferSource();
                            source.buffer = window.mcLevelUpSoundBuffer;
                            const gainNode = ctx.createGain();
                            gainNode.gain.value = 0.5;
                            source.connect(gainNode);
                            gainNode.connect(ctx.destination);
                            source.start(0);
                        }
                    } catch (e) {
                        console.warn('Could not play level up sound:', e);
                    }
                } else if (typeof ensureAudioContext === 'function') {
                    // Fallback: Create synthesized level up sound
                    try {
                        const ctx = ensureAudioContext();
                        if (ctx) {
                            const osc1 = ctx.createOscillator();
                            const osc2 = ctx.createOscillator();
                            const gain = ctx.createGain();

                            osc1.connect(gain);
                            osc2.connect(gain);
                            gain.connect(ctx.destination);

                            osc1.frequency.setValueAtTime(523, ctx.currentTime);
                            osc1.frequency.setValueAtTime(659, ctx.currentTime + 0.1);
                            osc1.frequency.setValueAtTime(784, ctx.currentTime + 0.2);

                            osc2.frequency.setValueAtTime(784, ctx.currentTime);
                            osc2.frequency.setValueAtTime(988, ctx.currentTime + 0.1);
                            osc2.frequency.setValueAtTime(1047, ctx.currentTime + 0.2);

                            gain.gain.setValueAtTime(0.2, ctx.currentTime);
                            gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.5);

                            osc1.start(ctx.currentTime);
                            osc2.start(ctx.currentTime);
                            osc1.stop(ctx.currentTime + 0.5);
                            osc2.stop(ctx.currentTime + 0.5);
                        }
                    } catch (e) { }
                }

                setTimeout(() => popup.remove(), 3000);
            },

            // Get K/D ratio
            getKDRatio: function () {
                if (this.data.totalDeaths === 0) return this.data.totalKills.toFixed(2);
                return (this.data.totalKills / this.data.totalDeaths).toFixed(2);
            },

            // Get win rate
            getWinRate: function () {
                if (this.data.matchesPlayed === 0) return '0%';
                return ((this.data.totalWins / this.data.matchesPlayed) * 100).toFixed(1) + '%';
            }
        };

        // Expose LevelSystem globally
        window.LevelSystem = LevelSystem;

        // Load player data on page load
        LevelSystem.load();

        // ==================== PROFILE PICTURE SYSTEM ====================
        const ProfilePicture = {
            STORAGE_KEY: 'taya7_profile_picture',
            DEFAULT_AVATAR: null, // Will use initials

            // Load from localStorage
            load: function () {
                try {
                    const saved = localStorage.getItem(this.STORAGE_KEY);
                    if (saved) {
                        this.current = saved;
                        console.log('🖼️ Profile picture loaded');
                    }
                } catch (e) {
                    console.warn('Failed to load profile picture:', e);
                }
                return this.current;
            },

            // Save to localStorage  
            save: function (dataUrl) {
                try {
                    // Compress image if too large (localStorage limit ~5MB)
                    if (dataUrl && dataUrl.length > 500000) {
                        console.warn('Profile picture too large, compressing...');
                        this.compressAndSave(dataUrl);
                        return;
                    }
                    localStorage.setItem(this.STORAGE_KEY, dataUrl);
                    this.current = dataUrl;
                    console.log('💾 Profile picture saved');

                    // Update squad list if visible
                    if (typeof updateSquadListPanel === 'function') {
                        updateSquadListPanel();
                    }
                } catch (e) {
                    console.warn('Failed to save profile picture:', e);
                }
            },

            // Compress image before saving
            compressAndSave: function (dataUrl) {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const size = 100; // Small avatar size
                    canvas.width = size;
                    canvas.height = size;
                    const ctx = canvas.getContext('2d');

                    // Draw centered and cropped
                    const minDim = Math.min(img.width, img.height);
                    const sx = (img.width - minDim) / 2;
                    const sy = (img.height - minDim) / 2;
                    ctx.drawImage(img, sx, sy, minDim, minDim, 0, 0, size, size);

                    const compressed = canvas.toDataURL('image/jpeg', 0.7);
                    this.save(compressed);
                };
                img.src = dataUrl;
            },

            // Get current profile picture
            get: function () {
                return this.current || this.load();
            },

            // Clear profile picture
            clear: function () {
                localStorage.removeItem(this.STORAGE_KEY);
                this.current = null;
            },

            // Generate initials avatar
            getInitialsAvatar: function (name) {
                const canvas = document.createElement('canvas');
                canvas.width = 100;
                canvas.height = 100;
                const ctx = canvas.getContext('2d');

                // Background gradient
                const gradient = ctx.createLinearGradient(0, 0, 100, 100);
                gradient.addColorStop(0, '#ff6b35');
                gradient.addColorStop(1, '#f7931e');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(50, 50, 50, 0, Math.PI * 2);
                ctx.fill();

                // Text
                ctx.fillStyle = 'white';
                ctx.font = 'bold 40px Rajdhani, sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const initials = name.substring(0, 2).toUpperCase();
                ctx.fillText(initials, 50, 52);

                return canvas.toDataURL('image/png');
            },

            current: null
        };

        // Expose ProfilePicture globally
        window.ProfilePicture = ProfilePicture;

        // Load profile picture on page load
        ProfilePicture.load();

        // Setup profile picture input handler
        document.addEventListener('DOMContentLoaded', function () {
            const profileInput = document.getElementById('profilePictureInput');
            if (profileInput) {
                profileInput.addEventListener('change', function (e) {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = function (event) {
                            ProfilePicture.save(event.target.result);
                        };
                        reader.readAsDataURL(file);
                    }
                });
            }
        });

        // Position interpolation variables (declared early for use in createOtherPlayerMesh)
        let targetOtherPlayerPosition = new THREE.Vector3(0, 1.7, 20);
        let targetOtherPlayerRotation = new THREE.Euler(0, 0, 0);
        let lastPositionUpdateTime = 0;

        // Smooth interpolation system for opponent movement
        let previousOtherPlayerPosition = new THREE.Vector3(0, 1.7, 20);
        let otherPlayerVelocity = new THREE.Vector3(0, 0, 0);
        let interpolationStartPos = new THREE.Vector3(0, 1.7, 20);
        let interpolationProgress = 1.0; // 0 to 1, how far along the interpolation we are
        const INTERPOLATION_DURATION = 0.04; // 40ms - matches ~30fps network rate for smooth movement

        // Create other player mesh for 2v2 (with playerId and team)
        function createOtherPlayerMesh2v2(playerId, team, spawnIndex = 0) {
            const playerGroup = new THREE.Group();
            playerGroup.isDying = false;
            playerGroup.deathTimer = 0;
            playerGroup.playerId = playerId;
            playerGroup.team = team;

            // Body color based on team
            const bodyColor = team === myTeam ? 0x00ff00 : 0xff0000; // Green for teammate, red for enemy

            // Body (using CylinderGeometry for r128 compatibility)
            const bodyGeo = new THREE.CylinderGeometry(0.4, 0.4, 1.8, 8);
            const bodyMat = new THREE.MeshStandardMaterial({ color: bodyColor });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.9; // Center the cylinder
            playerGroup.add(body);

            playerGroup.visible = true;

            // Spawn position based on team and spawn index
            let spawnX = 0, spawnZ = 0;
            if (team === 1) {
                // Team 1 spawns on player side (z = -20)
                spawnX = spawnIndex === 0 ? -5 : 5;
                spawnZ = -20;
            } else {
                // Team 2 spawns on enemy side (z = 20)
                spawnX = spawnIndex === 0 ? -5 : 5;
                spawnZ = 20;
            }

            playerGroup.position.set(spawnX, 1.7, spawnZ);
            playerGroup.rotation.set(0, 0, 0);
            playerGroup.quaternion.set(0, 0, 0, 1);
            playerGroup.castShadow = true;
            playerGroup.receiveShadow = true;

            // Username sprite above head - DISABLED for cleaner gameplay
            // const squadInfo = squadData.get(playerId);
            // const displayUsername = squadInfo?.username || `Player ${playerId ? playerId.substring(0, 4) : '???'}`;
            // const playerLevel = squadInfo?.level || 1;
            // const playerXpProgress = squadInfo?.xpProgress || 0;
            // const usernameSprite = createUsernameSprite(displayUsername, playerLevel, playerXpProgress);
            // usernameSprite.position.set(0, 2.0, 0);
            // usernameSprite.scale.multiplyScalar(1.5);
            // playerGroup.add(usernameSprite);
            // playerGroup.usernameSprite = usernameSprite;

            // Store target position for interpolation
            playerGroup.targetPosition = new THREE.Vector3(spawnX, 1.7, spawnZ);
            playerGroup.targetRotation = new THREE.Euler(0, 0, 0);

            console.log(`✅ 2v2 Player mesh created: ID=${playerId}, Team=${team}, Pos=(${spawnX}, 1.7, ${spawnZ})`);
            return playerGroup;
        }

        // Create other player mesh with proper skin support
        function createOtherPlayerMesh(spawnOnEnemySide = true) {
            // Remove any existing otherPlayer to prevent duplicates
            if (otherPlayer && scene) {
                scene.remove(otherPlayer);
                otherPlayer = null;
            }

            const playerGroup = new THREE.Group();
            playerGroup.isDying = false;
            playerGroup.deathTimer = 0;
            playerGroup.skeletonId = 'opponent_' + Date.now();
            playerGroup.skinLoaded = false;

            // Get opponent skin from gameState
            const opponentSkin = (window.gameState && window.gameState.otherPlayerSkin) || 'soldier';
            console.log('🎭 Creating opponent with skin:', opponentSkin);

            // Create placeholder body while loading skin (using CylinderGeometry for r128 compatibility)
            const placeholderGeo = new THREE.CylinderGeometry(0.4, 0.4, 1.8, 8);
            const placeholderMat = new THREE.MeshStandardMaterial({
                color: 0x0088ff,
                transparent: true,
                opacity: 0.3
            });
            const placeholder = new THREE.Mesh(placeholderGeo, placeholderMat);
            placeholder.name = 'placeholder';
            placeholder.position.y = 0.9; // Center the cylinder
            playerGroup.add(placeholder);

            // Spawn position - use y=1.7 for consistent headshot detection
            const spawnZ = spawnOnEnemySide ? 20 : -20;
            playerGroup.position.set(0, 1.7, spawnZ);
            playerGroup.rotation.set(0, 0, 0);
            playerGroup.quaternion.set(0, 0, 0, 1);
            playerGroup.castShadow = true;
            playerGroup.receiveShadow = true;
            playerGroup.visible = true;

            // Initialize target position
            targetOtherPlayerPosition.set(0, 1.7, spawnZ);
            targetOtherPlayerRotation.set(0, 0, 0);

            // Add speaker icon
            enemySpeakerIcon = createSpeakerIcon();
            enemySpeakerIcon.position.set(0, 2.2, 0);
            enemySpeakerIcon.visible = false;
            playerGroup.add(enemySpeakerIcon);

            // Load the actual skin model
            loadOpponentSkinModel(playerGroup, opponentSkin);

            console.log('✅ Other player mesh created at:', playerGroup.position, 'skin:', opponentSkin);
            return playerGroup;
        }

        // Load opponent skin model (FBX with animations)
        function loadOpponentSkinModel(playerGroup, skinName) {
            const skinConfig = SKIN_CONFIG[skinName];
            if (!skinConfig) {
                console.warn('⚠️ Unknown skin:', skinName, 'falling back to soldier');
                return;
            }

            console.log('🎭 Loading opponent skin model:', skinName);

            // Use THREE.FBXLoader (added by the FBXLoader script)
            if (typeof THREE.FBXLoader === 'undefined') {
                console.error('❌ FBXLoader not available');
                return;
            }

            const loader = new THREE.FBXLoader();
            // Use modelFbx if available (for skeleton), otherwise use fbx
            const fbxPath = skinConfig.modelFbx || skinConfig.fbx;

            loader.load(fbxPath, (object) => {
                console.log('✅ Opponent FBX loaded:', skinName);

                // Remove placeholder
                const placeholder = playerGroup.getObjectByName('placeholder');
                if (placeholder) {
                    playerGroup.remove(placeholder);
                }

                // Apply scale - skeleton is 25% bigger in gameplay to be more visible
                let scale = skinConfig.scale || 0.01;
                if (skinName === 'skeleton') {
                    scale = scale * 1.4; // Make skeleton 25% bigger in gameplay
                }
                object.scale.set(scale, scale, scale);

                // For skeleton, rotate 180 degrees to face correct direction and lower to ground
                if (skinName === 'skeleton') {
                    object.rotation.y = Math.PI; // 180 degrees
                    // PlayerGroup is at y=1.7, skeleton model needs to be lowered so feet touch ground (y=0)
                    // With scale 1.4*0.012, skeleton is about 2m tall, so we need to offset by about 1.7
                    object.position.y = -1.7;

                    // ADD HITBOX CAPSULE - skeleton has holes, so add invisible hitbox for easier hit detection
                    // Hitbox should cover from ground (y=0) to head (y=2.0) in world space
                    // Since playerGroup is at y=1.7, hitbox local y should be: center at 1.0 world = 1.0 - 1.7 = -0.7 local
                    const hitboxGeo = new THREE.CylinderGeometry(0.5, 0.5, 2.0, 8); // Wider hitbox capsule
                    const hitboxMat = new THREE.MeshBasicMaterial({
                        visible: false, // Invisible!
                        transparent: true,
                        opacity: 0
                    });
                    const hitbox = new THREE.Mesh(hitboxGeo, hitboxMat);
                    hitbox.name = 'skeletonHitbox';
                    hitbox.position.y = -0.7; // Center of hitbox at world y=1.0 (covers y=0 to y=2.0)
                    playerGroup.add(hitbox);
                    playerGroup.hitboxMesh = hitbox;
                    console.log('💀 Added hitbox capsule for skeleton');
                } else {
                    object.position.y = 0;
                }

                // Setup materials
                object.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;

                        // Preserve original materials if specified
                        if (skinConfig.preserveMaterials) {
                            // Keep original material but ensure it renders properly
                            if (child.material) {
                                child.material.side = THREE.DoubleSide;
                                if (child.isSkinnedMesh) child.material.skinning = true;
                                child.material.needsUpdate = true;
                            }
                        } else if (skinConfig.texture) {
                            // Apply single texture
                            const textureLoader = new THREE.TextureLoader();
                            const texture = textureLoader.load(skinConfig.texture);
                            const newMat = new THREE.MeshStandardMaterial({
                                map: texture,
                                side: THREE.DoubleSide
                            });
                            if (child.isSkinnedMesh) newMat.skinning = true;
                            child.material = newMat;
                        } else if (skinConfig.textures) {
                            // Multiple textures (like briefcase)
                            const meshName = child.name.toLowerCase();
                            let texturePath = null;

                            if (meshName.includes('body') || meshName.includes('torso')) {
                                texturePath = skinConfig.textures.body;
                            } else if (meshName.includes('hand')) {
                                texturePath = skinConfig.textures.hands;
                            } else if (meshName.includes('head') || meshName.includes('helmet')) {
                                texturePath = skinConfig.textures.helmet;
                            }

                            if (texturePath) {
                                const textureLoader = new THREE.TextureLoader();
                                const texture = textureLoader.load(texturePath);
                                const newMat = new THREE.MeshStandardMaterial({
                                    map: texture,
                                    side: THREE.DoubleSide
                                });
                                if (child.isSkinnedMesh) newMat.skinning = true;
                                child.material = newMat;
                            }
                        }
                    }
                });

                // Find head bone and spine bone for rotation control
                let headBone = null;
                let spineBone = null;
                let neckBone = null;
                object.traverse((child) => {
                    const name = child.name.toLowerCase();
                    if (name.includes('head') && !name.includes('headshot') && !name.includes('top')) {
                        headBone = child;
                    }
                    if (name.includes('spine') && !spineBone) {
                        spineBone = child;
                    }
                    if (name.includes('neck')) {
                        neckBone = child;
                    }
                });

                playerGroup.skinnedMesh = object;
                playerGroup.headBone = headBone || object;
                playerGroup.spineBone = spineBone;
                playerGroup.neckBone = neckBone;
                playerGroup.add(object);

                if (skinName === 'skeleton') {
                    console.log('💀 Bone references:', {
                        head: headBone?.name,
                        spine: spineBone?.name,
                        neck: neckBone?.name
                    });
                }

                // Debug bones for skeleton
                if (skinName === 'skeleton') {
                    console.log('💀 IN-GAME SKELETON MODEL BONES:');
                    object.traverse((child) => {
                        if (child.isBone) {
                            console.log('   🦴', child.name);
                        }
                    });
                }

                // Setup animation mixer
                // IMPORTANT: For skeleton, ALWAYS use SkeletonAnimationSystem - ignore embedded animations!
                // The skeleton model file has an embedded binding pose that we don't want to use.
                if (skinName === 'skeleton' && window.SkeletonAnimationSystem) {
                    // For skeleton skin, use the full animation system with all 48 animations
                    console.log('💀 Initializing skeleton animation system for in-game opponent');
                    console.log('💀 (Ignoring embedded animations - using skeleton folder animations)');

                    // Generate unique skeleton ID for this opponent
                    playerGroup.skeletonId = 'opponent_skeleton_' + Date.now();

                    SkeletonAnimationSystem.loadAnimations().then(() => {
                        // Create mixer for this skeleton using the animation system
                        const mixer = SkeletonAnimationSystem.createMixer(playerGroup.skeletonId, object);
                        playerGroup.mixer = mixer;
                        console.log('💀 Skeleton animation system initialized for opponent');
                        console.log('💀 Loaded animations:', SkeletonAnimationSystem.animationCache.size);
                    }).catch(err => {
                        console.error('❌ Failed to initialize skeleton animation system:', err);
                    });
                } else if (object.animations && object.animations.length > 0) {
                    // For NON-skeleton skins, use embedded animations if available
                    console.log('💀 In-game model has embedded animations:', object.animations.length);
                    playerGroup.mixer = new THREE.AnimationMixer(object);
                    const idleAction = playerGroup.mixer.clipAction(object.animations[0]);
                    idleAction.play();
                    playerGroup.currentAction = idleAction;
                    console.log('🎭 Playing embedded animation');
                } else if (skinConfig.modelFbx && skinConfig.fbx && skinConfig.fbx !== skinConfig.modelFbx) {
                    // Non-skeleton models with separate animation files
                    console.log('💀 Loading separate animation for in-game model from:', skinConfig.fbx);
                    const animLoader = new THREE.FBXLoader();
                    animLoader.load(skinConfig.fbx, (animObject) => {
                        console.log('💀 In-game animation loaded! Clips:', animObject.animations.length);

                        if (animObject.animations && animObject.animations.length > 0) {
                            playerGroup.mixer = new THREE.AnimationMixer(object);
                            let clip = animObject.animations[0];
                            console.log('💀 Animation clip tracks:', clip.tracks.length);

                            // Try retargeting if needed
                            clip = retargetAnimationClip(clip, object);

                            const idleAction = playerGroup.mixer.clipAction(clip);
                            idleAction.play();
                            playerGroup.currentAction = idleAction;
                            console.log('🎭 Animation started');
                        }
                    }, undefined, (err) => {
                        console.error('❌ Failed to load animation:', err);
                    });
                }

                playerGroup.skinLoaded = true;
                playerGroup.skinName = skinName;

                // Update speaker icon position based on skin
                if (enemySpeakerIcon) {
                    if (skinName === 'skeleton') {
                        enemySpeakerIcon.position.set(0, 2.0, 0);
                    } else if (skinName === 'briefcase') {
                        enemySpeakerIcon.position.set(0, 2.2, 0);
                    } else {
                        enemySpeakerIcon.position.set(0, 1.8, 0);
                    }
                }

                console.log('✅ Opponent skin loaded successfully:', skinName);

            }, undefined, (error) => {
                console.error('❌ Failed to load opponent skin:', skinName, error);
            });
        }

        // Update opponent animation based on movement state
        function updateOpponentAnimation(state) {
            if (!otherPlayer || !otherPlayer.skinLoaded) return;

            const skinName = otherPlayer.skinName || 'soldier';

            // For skeleton, use the animation system
            if (skinName === 'skeleton' && window.SkeletonAnimationSystem) {
                SkeletonAnimationSystem.updateState(otherPlayer.skeletonId, state);
            }
        }

        // Function to reload opponent skin if it changed
        function reloadOpponentSkin(newSkinName) {
            if (!otherPlayer) {
                console.log('⚠️ Cannot reload skin - no otherPlayer');
                return;
            }

            // Check if skin actually changed
            if (otherPlayer.skinName === newSkinName) {
                console.log('ℹ️ Skin unchanged:', newSkinName);
                return;
            }

            console.log('🔄 Reloading opponent skin from', otherPlayer.skinName || 'unknown', 'to', newSkinName);

            // Remove existing skinned mesh if any
            if (otherPlayer.skinnedMesh) {
                otherPlayer.remove(otherPlayer.skinnedMesh);
                otherPlayer.skinnedMesh = null;
            }

            // Remove existing hitbox if any (skeleton hitbox)
            if (otherPlayer.hitboxMesh) {
                otherPlayer.remove(otherPlayer.hitboxMesh);
                otherPlayer.hitboxMesh = null;
            }

            // Reset skin loaded flag
            otherPlayer.skinLoaded = false;
            otherPlayer.skinName = null;

            // Generate new skeleton ID
            otherPlayer.skeletonId = 'opponent_' + Date.now();

            // Load the new skin
            loadOpponentSkinModel(otherPlayer, newSkinName);
        }

        // Expose function globally
        window.updateOpponentAnimation = updateOpponentAnimation;
        window.loadOpponentSkinModel = loadOpponentSkinModel;
        window.reloadOpponentSkin = reloadOpponentSkin;

        // Function to create a 2D speaker icon overlay
        function createSpeakerIcon() {
            const textureLoader = new THREE.TextureLoader();
            const texture = textureLoader.load('Speaker_Icon.svg.png', function () {
                console.log('✅ Speaker icon loaded');
                if (window.LoadingScreen) {
                    LoadingScreen.assetLoaded('speaker_icon');
                }
            });
            const material = new THREE.SpriteMaterial({
                map: texture,
                color: 0xffffff,
                transparent: true,
                opacity: 1.0
            });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(0.4, 0.4, 1); // Made 2x larger (0.2 -> 0.4)
            return sprite;
        }

        function createUsernameSprite(username, level = 1, xpProgress = 0) {
            console.log('Creating username sprite for:', username, 'level:', level);

            // Create a canvas to render the username text with level ring
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 320;  // Wider to fit level ring
            canvas.height = 64;

            // Clear canvas with transparent background
            context.clearRect(0, 0, canvas.width, canvas.height);
            context.imageSmoothingEnabled = false; // keep crisp when scaling

            // --- Level Ring ---
            const ringSize = 28;
            const ringX = 24;
            const ringY = canvas.height / 2;

            // Level ring background
            context.beginPath();
            context.arc(ringX, ringY, ringSize / 2, 0, Math.PI * 2);
            context.fillStyle = "rgba(0, 0, 0, 0.7)";
            context.fill();

            // XP progress arc (black/white)
            context.beginPath();
            context.arc(ringX, ringY, ringSize / 2 - 2, -Math.PI / 2, -Math.PI / 2 + (Math.PI * 2 * xpProgress), false);
            context.strokeStyle = "#ffffff";
            context.lineWidth = 3;
            context.lineCap = "round";
            context.stroke();

            // Level ring border (black/white)
            context.beginPath();
            context.arc(ringX, ringY, ringSize / 2, 0, Math.PI * 2);
            context.strokeStyle = "#ffffff";
            context.lineWidth = 2;
            context.stroke();

            // Level number (black/white)
            context.font = "bold 14px 'Press Start 2P', monospace";
            context.textAlign = "center";
            context.textBaseline = "middle";
            context.fillStyle = "#ffffff";
            context.fillText(level.toString(), ringX, ringY);

            // --- Username Text ---
            const fontSize = 13;
            const fontFamily = "'Press Start 2P', monospace";
            if (!document.getElementById('pixelFontLink')) {
                const link = document.createElement('link');
                link.id = 'pixelFontLink';
                link.rel = 'stylesheet';
                link.href = 'https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap';
                document.head.appendChild(link);
            }
            context.font = 'bold ' + fontSize + 'px ' + fontFamily;
            context.textAlign = 'left';
            context.textBaseline = 'middle';

            // Measure text to draw a tight background box
            const metrics = context.measureText(username);
            const padX = 10;
            const padY = 6;
            const bgW = Math.ceil(metrics.width + padX * 2);
            const bgH = Math.ceil(fontSize + padY * 2);
            const bgX = ringX + ringSize / 2 + 6;  // Start after ring
            const bgY = Math.round(canvas.height / 2 - bgH / 2);

            // Semi-transparent black background
            context.fillStyle = 'rgba(0, 0, 0, 0.55)';
            context.fillRect(bgX, bgY, bgW, bgH);

            // Draw outlined text
            context.lineWidth = 4;
            context.strokeStyle = '#000000';
            context.fillStyle = '#ffffff';
            const textX = bgX + padX;
            const textY = canvas.height / 2;
            context.strokeText(username, textX, textY);
            context.fillText(username, textX, textY);

            console.log('Canvas text drawn:', username);

            // Create texture from canvas with nearest filtering for pixelation
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            texture.minFilter = THREE.NearestFilter;
            texture.magFilter = THREE.NearestFilter;
            texture.generateMipmaps = false;

            // Create sprite with the text texture
            const material = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                opacity: 1.0
            });
            const sprite = new THREE.Sprite(material);
            // Scale sprite based on canvas
            const totalWidth = bgX + bgW;
            const scaleFactor = 0.08;
            sprite.scale.set(totalWidth * scaleFactor, canvas.height * scaleFactor, 1);
            sprite.renderOrder = 999;
            sprite.material.depthTest = false;
            sprite.material.depthWrite = false;
            sprite.material.fog = false;
            sprite.visible = true;
            sprite.frustumCulled = false;

            console.log('Username sprite created successfully, scale:', sprite.scale, 'visible:', sprite.visible);
            return sprite;
        }

        // --- COD-STYLE RED ENEMY NAMETAG ---
        // Shows only when aiming at enemy (like in the reference image)
        let enemyNametagSprite = null;
        let enemyNametagVisible = false;

        function createEnemyNametag(clanTag = 'ENEMY', playerName = 'Bot', playerId = '') {
            console.log('Creating COD-style enemy nametag:', clanTag, playerName);

            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 64;

            // Clear canvas
            context.clearRect(0, 0, canvas.width, canvas.height);

            // Load font
            if (!document.getElementById('enemyFontLink')) {
                const link = document.createElement('link');
                link.id = 'enemyFontLink';
                link.rel = 'stylesheet';
                link.href = 'https://fonts.googleapis.com/css2?family=Oswald:wght@600&display=swap';
                document.head.appendChild(link);
            }

            // Build the full name: [CLANNAME] PlayerName ID
            const fullName = `[${clanTag}] ${playerName}${playerId ? ' ' + playerId : ''}`;

            // Style settings - exactly like the image
            const fontSize = 28;
            context.font = `bold ${fontSize}px 'Oswald', 'Arial Black', sans-serif`;
            context.textAlign = 'center';
            context.textBaseline = 'middle';

            // Semi-transparent dark background behind text
            const metrics = context.measureText(fullName);
            const padX = 20;
            const padY = 8;
            const bgW = Math.ceil(metrics.width + padX * 2);
            const bgH = Math.ceil(fontSize + padY * 2);
            const bgX = (canvas.width - bgW) / 2;
            const bgY = (canvas.height - bgH) / 2;

            // Just text outline for visibility, no background
            // (background removed per user request)

            // RED text - exactly like the image (blood red color)
            context.fillStyle = '#ff2222';
            context.strokeStyle = '#000000';
            context.lineWidth = 3;

            const textX = canvas.width / 2;
            const textY = canvas.height / 2;

            // Draw text with outline for better visibility
            context.strokeText(fullName, textX, textY);
            context.fillText(fullName, textX, textY);

            // Create texture
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;

            // Create sprite
            const material = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                opacity: 0,  // Start hidden
                depthTest: false,
                depthWrite: false
            });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(4, 0.5, 1);  // Wide format like the image
            sprite.renderOrder = 1000;
            sprite.visible = false;  // Hidden by default
            sprite.name = 'enemyNametag';

            console.log('Enemy nametag created:', fullName);
            return sprite;
        }

        // Update enemy nametag visibility based on aim
        // PERF: Pre-allocated vectors for nametag visibility
        const _nametagCameraDir = new THREE.Vector3();
        const _nametagToEnemy = new THREE.Vector3();

        function updateEnemyNametagVisibility(camera, enemy, deltaTime) {
            if (!enemy || !enemy.usernameSprite) return;

            const sprite = enemy.usernameSprite;

            // Calculate angle between camera direction and enemy position
            // PERF: Reuse pre-allocated vectors
            camera.getWorldDirection(_nametagCameraDir);

            _nametagToEnemy.subVectors(enemy.position, camera.position).normalize();

            // Dot product gives us how aligned we are (1 = looking directly at, 0 = perpendicular, -1 = opposite)
            const dot = _nametagCameraDir.dot(_nametagToEnemy);

            // Distance to enemy
            const distance = camera.position.distanceTo(enemy.position);

            // Calculate visibility threshold based on distance
            // At close range, need to be looking more directly
            // At far range, easier to spot (wider cone)
            const minDot = Math.max(0.85, 0.95 - distance * 0.01);  // 0.85 to 0.95

            // Should be visible if looking at enemy and close enough
            const shouldBeVisible = dot > minDot && distance < 50;

            // Smooth fade in/out
            const targetOpacity = shouldBeVisible ? 1 : 0;
            const currentOpacity = sprite.material.opacity;
            const fadeSpeed = 8;  // Fast fade

            sprite.material.opacity += (targetOpacity - currentOpacity) * deltaTime * fadeSpeed;
            sprite.visible = sprite.material.opacity > 0.01;

            // Make sprite face camera (billboard)
            if (sprite.visible) {
                sprite.lookAt(camera.position);
            }
        }
        // PERF: Pre-allocated vector for speaker icon projection
        const _speakerIconVec = new THREE.Vector3();

        // Function to update speaker icon position above player's head
        function updateSpeakerIconPosition(worldPosition) {
            const icon = document.getElementById('speakerIconOverlay');
            if (!icon) return;
            // Project 3D position to 2D screen - PERF: reuse vector
            _speakerIconVec.copy(worldPosition).project(camera);
            const x = (_speakerIconVec.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-_speakerIconVec.y * 0.5 + 0.5) * window.innerHeight - 80; // Offset above head (adjusted for larger icon)
            icon.style.left = `${x - 40}px`; // Center the 80px icon
            icon.style.top = `${y}px`;
        }
        // SOCKET.IO MULTIPLAYER FUNCTIONS
        let lastPositionSend = 0;

        // Expose sendToOther globally IMMEDIATELY for lobby name sync
        // (previously was only exposed after initGame, causing sync failures)
        function sendToOther(data) {
            if (!isMultiplayer) {
                if (data.type !== 'position') {
                    console.warn('⚠️ Cannot send - not in multiplayer mode');
                }
                return;
            }

            // Throttle position updates (30 updates per second for smoother movement)
            if (data.type === 'position') {
                const now = Date.now();
                if (now - lastPositionSend < 33) return; // ~30fps network updates
                lastPositionSend = now;

                // Track packet sending for network stats
                if (window.telemetryData) {
                    window.telemetryData.packetsSent++;
                    // Add timestamp for ping calculation
                    data.sendTime = now;
                }
            }

            // Add playerId and team to ALL messages (1v1 and 2v2)
            data.playerId = myPlayerId;
            if (gameMode === '2v2') {
                data.team = myTeam;
            }

            // 2v2 mode: use WebRTC (like 1v1)
            if (gameMode === '2v2') {
                if (useWebRTC) {
                    // Host: broadcast to all connected players
                    if (isHost && playerConnections.size > 0) {
                        let sent = false;
                        playerConnections.forEach((conn, playerId) => {
                            try {
                                if (conn.open === true || conn.readyState === 'open' || conn.readyState === 'OPEN') {
                                    conn.send(JSON.stringify(data));
                                    sent = true;
                                }
                            } catch (e) {
                                console.error('❌ WebRTC send error to', playerId, ':', e);
                            }
                        });
                        if (data.type !== 'position' && sent) {
                            // PERF: console.log disabled for performance
                            // console.log('✅ Sent via WebRTC (2v2):', data.type);
                        }
                        if (!sent && data.type !== 'position') {
                            // PERF: console.warn disabled (non-critical)
                            // console.warn('⚠️ No active WebRTC connections for 2v2');
                        }
                    } else if (!isHost && dataChannel) {
                        // Client: send to host (host will relay)
                        try {
                            if (dataChannel.open === true || dataChannel.readyState === 'open' || dataChannel.readyState === 'OPEN') {
                                dataChannel.send(JSON.stringify(data));
                                if (data.type !== 'position') {
                                    // PERF: console.log disabled for performance
                                    // console.log('✅ Sent via WebRTC (2v2 client):', data.type);
                                }
                            } else {
                                if (data.type !== 'position') {
                                    // PERF: console.warn disabled (non-critical)
                                    // console.warn('⚠️ WebRTC data channel not open');
                                }
                            }
                        } catch (e) {
                            console.error('❌ WebRTC send error:', e);
                            // Fallback to Socket.IO if available
                            if (socket && socket.connected) {
                                try {
                                    socket.emit('gameData', {
                                        room: currentRoomId,
                                        data: data
                                    });
                                } catch (e2) {
                                    console.error('❌ Socket.IO fallback also failed:', e2);
                                }
                            }
                        }
                    } else {
                        // Fallback to Socket.IO if WebRTC not available
                        if (socket && socket.connected) {
                            try {
                                socket.emit('gameData', {
                                    room: currentRoomId,
                                    data: data
                                });
                                if (data.type !== 'position') {
                                    // PERF: console.log disabled for performance
                                    // console.log('✅ Sent via Socket.IO (2v2 fallback):', data.type);
                                }
                            } catch (e) {
                                console.error('❌ Socket.IO send error:', e);
                            }
                        } else {
                            if (data.type !== 'position') {
                                // PERF: console.warn disabled (non-critical)
                                // console.warn('⚠️ Cannot send data - no connection available:', data.type);
                            }
                        }
                    }
                } else {
                    // Socket.IO fallback for 2v2
                    if (socket && socket.connected) {
                        try {
                            socket.emit('gameData', {
                                room: currentRoomId,
                                data: data
                            });
                            if (data.type !== 'position') {
                                // PERF: console.log disabled for performance
                                // console.log('✅ Sent via Socket.IO (2v2):', data.type);
                            }
                        } catch (e) {
                            console.error('❌ Socket.IO send error:', e);
                        }
                    } else {
                        if (data.type !== 'position') {
                            // PERF: console.warn disabled (non-critical)
                            // console.warn('⚠️ Cannot send data - Socket.IO not connected:', data.type);
                        }
                    }
                }
                return;
            }

            // 1v1 mode: Use WebRTC or Socket.IO fallback
            // Check WebRTC connection state more thoroughly
            let webRTCReady = false;
            if (useWebRTC && dataChannel) {
                // PeerJS connections use 'open' property (boolean)
                if (dataChannel.open === true) {
                    webRTCReady = true;
                } else if (dataChannel.readyState === 'open' || dataChannel.readyState === 'OPEN') {
                    webRTCReady = true;
                }
            }

            // Use WebRTC if available, otherwise fallback to Socket.IO
            if (webRTCReady) {
                try {
                    const dataString = JSON.stringify(data);
                    dataChannel.send(dataString);
                    if (data.type !== 'position') {
                        // PERF: console.log disabled for performance
                        // console.log('✅ Sent via WebRTC:', data.type);
                    }
                } catch (e) {
                    console.error('❌ WebRTC send error:', e);
                    // Try fallback to Socket.IO if WebRTC fails
                    if (socket && socket.connected) {
                        socket.emit('gameData', {
                            room: currentRoomId,
                            data: data
                        });
                    } else {
                        console.error('❌ Both WebRTC and Socket.IO failed to send');
                    }
                }
            } else if (socket && socket.connected) {
                // Fallback to Socket.IO
                try {
                    socket.emit('gameData', {
                        room: currentRoomId,
                        data: data
                    });
                    if (data.type !== 'position') {
                        // PERF: console.log disabled for performance
                        // console.log('✅ Sent via Socket.IO:', data.type);
                    }
                } catch (e) {
                    console.error('❌ Socket.IO send error:', e);
                }
            } else {
                // Connection not ready - log detailed info
                if (data.type !== 'position') {
                    // PERF: console.warn disabled (non-critical)
                    // console.warn('⚠️ Cannot send data - no connection:', data.type);
                    console.warn('   WebRTC:', useWebRTC, 'dataChannel:', !!dataChannel, 'open:', dataChannel?.open, 'readyState:', dataChannel?.readyState);
                    console.warn('   Socket:', !!socket, 'connected:', socket?.connected);
                }
            }
        }

        // CRITICAL: Expose sendToOther to window IMMEDIATELY so lobby name sync works
        window.sendToOther = sendToOther;

        // WebRTC Connection using PeerJS (FREE, no server needed!)
        function connectWebRTC(isHosting) {
            return new Promise((resolve, reject) => {
                console.log('🌐 Setting up WebRTC connection (no server needed!)...');

                // Generate unique peer ID
                const peerId = isHosting ?
                    'host-' + Math.random().toString(36).substring(2, 9) :
                    null;

                // Set up timeout for connection (15 seconds)
                const connectionTimeout = setTimeout(() => {
                    if (peer) {
                        peer.destroy();
                    }
                    reject(new Error('WebRTC connection timeout - PeerJS signaling server may be unreachable. Please try again or use AI mode.'));
                }, 15000); // 15 second timeout

                // Initialize PeerJS (uses free public signaling server)
                peer = new Peer(peerId, {
                    host: '0.peerjs.com',
                    port: 443,
                    path: '/',
                    secure: true,
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' }
                        ]
                    }
                });

                peer.on('open', (id) => {
                    clearTimeout(connectionTimeout);
                    console.log('✅ WebRTC Peer ID:', id);
                    myPlayerId = id;
                    currentRoomId = id;
                    connectionQuality = 'good';
                    resolve(id);
                });

                peer.on('error', (err) => {
                    clearTimeout(connectionTimeout);
                    console.error('❌ WebRTC error:', err);
                    if (err.type === 'peer-unavailable') {
                        reject(new Error('Peer not found. Make sure the Room ID is correct.'));
                    } else {
                        reject(new Error('WebRTC connection failed: ' + err.message));
                    }
                });

                // Handle incoming voice calls
                peer.on('call', (call) => {
                    console.log('📞 Incoming voice call from:', call.peer);
                    console.log('📞 VoiceChat available:', !!VoiceChat);
                    console.log('📞 localStream available:', !!localStream);

                    if (VoiceChat) {
                        // answerCall will handle getting the stream if needed
                        VoiceChat.answerCall(call);
                    } else {
                        console.error('❌ VoiceChat not available to answer call');
                    }
                });

                if (isHosting) {
                    // Host: Wait for incoming connections (1 for 1v1, up to 3 for 2v2)
                    peer.on('connection', (conn) => {
                        const connectingPlayerId = conn.peer;
                        console.log('✅ Peer connecting...', connectingPlayerId);

                        // For 1v1 mode, store as otherPlayerId
                        if (gameMode === '1v1') {
                            otherPlayerId = connectingPlayerId;
                        }

                        // Setup data channel for this connection
                        setupDataChannel(conn, connectingPlayerId);

                        // Handle connection events
                        conn.on('open', () => {
                            console.log(`✅ Host: Client ${connectingPlayerId} connected!`);
                            connectionQuality = 'good';
                            isMultiplayer = true;
                            window.isMultiplayer = true; // Expose globally for emote system

                            // Store connection in playerConnections map for 2v2
                            if (gameMode === '2v2') {
                                playerConnections.set(connectingPlayerId, conn);
                                if (!roomPlayers.includes(connectingPlayerId)) {
                                    roomPlayers.push(connectingPlayerId);
                                }
                                // Include host in count
                                const currentTotalPlayers = roomPlayers.length + 1; // +1 for host

                                // Assign team (alternating: 1, 2, 1, 2)
                                // Host is team 1, first client is team 2, second client is team 1, third client is team 2
                                const team = currentTotalPlayers % 2 === 0 ? 2 : 1;
                                const spawnIndex = roomPlayers.filter((pid, idx) => {
                                    const playerData = otherPlayers.find(p => p && p.playerId === pid);
                                    return playerData && playerData.team === team;
                                }).length;

                                // Initialize squad data first (before creating mesh so username is available)
                                squadData.set(connectingPlayerId, {
                                    health: 100,
                                    weapon: 'rifle',
                                    isDying: false,
                                    username: `Player ${connectingPlayerId.substring(0, 4)}`
                                });

                                // Create player mesh (will use username from squadData)
                                const playerMesh = createOtherPlayerMesh2v2(connectingPlayerId, team, spawnIndex);
                                playerMesh.playerId = connectingPlayerId;
                                playerMesh.team = team;
                                scene.add(playerMesh);
                                otherPlayers.push({ playerId: connectingPlayerId, mesh: playerMesh, team: team });

                                // Send our username to the new player
                                if (gameState.playerUsername) {
                                    try {
                                        const xpNeeded = LevelSystem.getXPForLevel(LevelSystem.data.level);
                                        conn.send(JSON.stringify({
                                            type: 'username',
                                            username: gameState.playerUsername,
                                            playerId: myPlayerId,
                                            level: LevelSystem.data.level,
                                            xpProgress: LevelSystem.data.currentXP / xpNeeded
                                        }));
                                    } catch (e) {
                                        console.error('Error sending username:', e);
                                    }
                                }

                                if (typeof updateSquadList === 'function') updateSquadList();

                                // Update the lobby squad list panel
                                if (window.updateLobbySquadList) {
                                    window.updateLobbySquadList();
                                }

                                // Add opponent to menu scene for 2v2
                                if (window.addOpponentToMenuScene) {
                                    const pData = squadData.get(connectingPlayerId);
                                    window.addOpponentToMenuScene(pData?.username || 'Player', connectingPlayerId);
                                }

                                // Send team assignment to the new player (include existing players info)
                                const existingPlayersInfo = otherPlayers.map(p => ({
                                    playerId: p.playerId,
                                    team: p.team,
                                    username: squadData.get(p.playerId)?.username || 'Player'
                                }));

                                conn.send(JSON.stringify({
                                    type: 'teamAssigned',
                                    team: team,
                                    playerId: connectingPlayerId,
                                    existingPlayers: existingPlayersInfo
                                }));

                                // Notify all other players about the new player (include username)
                                const newPlayerUsername = squadData.get(connectingPlayerId)?.username || 'Player';
                                playerConnections.forEach((otherConn, otherPlayerId) => {
                                    if (otherPlayerId !== connectingPlayerId) {
                                        try {
                                            otherConn.send(JSON.stringify({
                                                type: 'playerJoined',
                                                playerId: connectingPlayerId,
                                                team: team,
                                                username: newPlayerUsername
                                            }));
                                        } catch (e) {
                                            console.error('Error notifying other player:', e);
                                        }
                                    }
                                });

                                // Send existing players info to new player (include usernames)
                                otherPlayers.forEach((playerData) => {
                                    if (playerData.playerId !== connectingPlayerId && playerData.playerId !== myPlayerId) {
                                        try {
                                            const playerUsername = squadData.get(playerData.playerId)?.username || 'Player';
                                            conn.send(JSON.stringify({
                                                type: 'playerJoined',
                                                playerId: playerData.playerId,
                                                team: playerData.team,
                                                username: playerUsername
                                            }));
                                        } catch (e) {
                                            console.error('Error sending existing player info:', e);
                                        }
                                    }
                                });

                                // Update waiting text (include host in count)
                                const playersNeeded = 4 - currentTotalPlayers;
                                if (playersNeeded > 0) {
                                    document.getElementById('waitingText').textContent =
                                        `⏳ Waiting for ${playersNeeded} more player${playersNeeded > 1 ? 's' : ''}...\n\nShare this Room ID with your teammates!\n\n🌍 2v2 Mode - Team Battle!`;
                                } else {
                                    // All players joined, start game
                                    document.getElementById('waitingText').textContent = '✅ All players joined! Starting game...';

                                    // Send startGame message to ALL clients
                                    playerConnections.forEach((playerConn) => {
                                        try {
                                            playerConn.send(JSON.stringify({ type: 'startGame' }));
                                        } catch (e) {
                                            console.error('Error sending startGame:', e);
                                        }
                                    });

                                    setTimeout(() => {
                                        if (document.getElementById('startScreen')) {
                                            document.getElementById('startScreen').style.display = 'none';
                                            if (window.menuSceneController) window.menuSceneController.hide();
                                        }
                                        // Hide lobby squad list
                                        const lobbyList1 = document.getElementById('lobbySquadList');
                                        if (lobbyList1) lobbyList1.style.display = 'none';
                                        // Show Minecraft XP HUD
                                        const mcHud1 = document.getElementById('mcXpHud');
                                        if (mcHud1) mcHud1.classList.add('visible');
                                        // Hide music player and stop music when game starts
                                        if (window.MusicPlayer && typeof window.MusicPlayer.handleGameStart === 'function') {
                                            window.MusicPlayer.handleGameStart();
                                        }
                                        gameState.started = true;

                                        // Show R6 Topbar
                                        if (typeof showR6Topbar === 'function') showR6Topbar();

                                        if (renderer && renderer.domElement) {
                                            renderer.domElement.requestPointerLock();
                                        }
                                        updateHUD();
                                        if (!window.animateStarted) {
                                            window.animateStarted = true;
                                            animate();
                                        }
                                    }, 1000);
                                }
                            } else {
                                // 1v1 mode: single connection
                                // Don't auto-start - wait for host to click START GAME button
                                // The lobby system handles game start via startGameFromLobby()
                                console.log('✅ 1v1: Player connected, waiting in lobby for host to start');
                            }
                        });

                        conn.on('close', () => {
                            console.log(`⚠️ Connection to ${connectingPlayerId} closed`);
                            if (gameMode === '2v2') {
                                playerConnections.delete(connectingPlayerId);
                                const playerIndex = otherPlayers.findIndex(p => p && p.playerId === connectingPlayerId);
                                if (playerIndex !== -1) {
                                    const playerData = otherPlayers[playerIndex];
                                    if (playerData.mesh && scene) {
                                        scene.remove(playerData.mesh);
                                    }
                                    otherPlayers.splice(playerIndex, 1);
                                    roomPlayers = roomPlayers.filter(id => id !== connectingPlayerId);

                                    // Notify other players
                                    playerConnections.forEach((otherConn) => {
                                        try {
                                            otherConn.send(JSON.stringify({
                                                type: 'playerLeft',
                                                playerId: connectingPlayerId
                                            }));
                                        } catch (e) {
                                            console.error('Error notifying player left:', e);
                                        }
                                    });
                                }
                            }
                        });
                    });
                }
                // Client connection is handled in the join button handler
            });
        }

        function setupDataChannel(conn, playerId = null) {
            // For 1v1 mode, store as main dataChannel
            if (gameMode === '1v1') {
                dataChannel = conn;
                window.dataChannel = dataChannel; // Expose globally for lobby
            } else if (gameMode === '2v2') {
                // For 2v2 mode, if we're a client connecting to host, store as dataChannel
                // If we're host accepting a connection, it's already stored in connectWebRTC
                if (!isHost && !dataChannel) {
                    dataChannel = conn;
                    window.dataChannel = dataChannel; // Expose globally for lobby
                }
            }

            // Handle data channel events
            if (conn.on) {
                conn.on('open', () => {
                    console.log('✅ Data channel open!', playerId ? `(Player: ${playerId})` : '');
                    connectionQuality = 'good';
                    isMultiplayer = true;
                    window.isMultiplayer = true; // Expose globally for emote system
                    window.isHost = isHost; // Update global reference

                    // Set player spawn position based on host/client (only for 1v1 or first connection)
                    // Note: spawnPlayer is defined later in the main game script, so we defer this
                    if (gameMode === '1v1') {
                        // Host spawns on player side, client spawns on enemy side
                        const spawnOnPlayerSide = isHost;
                        // Defer spawn until function is available
                        const trySpawn = () => {
                            if (typeof spawnPlayer === 'function') {
                                spawnPlayer(spawnOnPlayerSide);
                                console.log(isHost ? '✅ Host: Spawned on player side' : '✅ Client: Spawned on enemy side');
                            } else {
                                setTimeout(trySpawn, 100);
                            }
                        };
                        trySpawn();
                    } else if (gameMode === '2v2' && !isHost) {
                        // Client in 2v2: wait for team assignment
                        // Position will be set when team is assigned
                    }

                    // Send a test message to verify connection
                    try {
                        conn.send(JSON.stringify({
                            type: 'test',
                            message: 'Connection test',
                            playerId: myPlayerId,
                            team: myTeam
                        }));
                        console.log('✅ Sent connection test message');

                        // Send username after connection test
                        if (gameState.playerUsername) {
                            const xpNeeded = LevelSystem.getXPForLevel(LevelSystem.data.level);
                            conn.send(JSON.stringify({
                                type: 'username',
                                username: gameState.playerUsername,
                                playerId: myPlayerId,
                                level: LevelSystem.data.level,
                                xpProgress: LevelSystem.data.currentXP / xpNeeded
                            }));
                            console.log('📋 Sent username:', gameState.playerUsername);
                        }
                    } catch (e) {
                        console.error('❌ Failed to send test message:', e);
                    }

                    // Notify that connection is ready (only for 1v1, 2v2 handled in connectWebRTC)
                    if (gameMode === '1v1' && !gameState || !gameState.started) {
                        if (window.createMultiplayerOpponent) {
                            window.createMultiplayerOpponent();
                        }
                    }
                });

                conn.on('data', (data) => {
                    try {
                        // Handle both string and object data
                        let gameData = data;
                        if (typeof data === 'string') {
                            gameData = JSON.parse(data);
                        }

                        // Calculate network latency for position updates
                        if (gameData.type === 'position' && gameData.sendTime && window.telemetryData) {
                            const receiveTime = Date.now();
                            const rtt = receiveTime - gameData.sendTime;
                            window.telemetryData.pingRTT = rtt;
                            window.telemetryData.packetsReceived++;

                            // Keep samples for jitter calculation
                            window.telemetryData.pingSamples.push(rtt);
                            if (window.telemetryData.pingSamples.length > 20) {
                                window.telemetryData.pingSamples.shift();
                            }
                        }

                        // For 2v2 host: relay messages to all other players
                        if (gameMode === '2v2' && isHost && gameData.type !== 'test') {
                            const senderId = playerId || gameData.playerId;
                            playerConnections.forEach((otherConn, otherPlayerId) => {
                                // Don't relay back to sender
                                if (senderId && senderId === otherPlayerId) {
                                    return;
                                }

                                try {
                                    otherConn.send(JSON.stringify(gameData));
                                } catch (e) {
                                    console.error('Error relaying message:', e);
                                }
                            });
                        }

                        // Handle team assignment for 2v2 clients
                        if (gameMode === '2v2' && gameData.type === 'teamAssigned') {
                            myTeam = gameData.team;
                            window.myTeam = gameData.team; // Expose globally for lobby squad list
                            console.log(`✅ Assigned to Team ${myTeam}`);

                            // Set spawn position based on team (defer until function is available)
                            const spawnOnPlayerSide = myTeam === 1;
                            const trySpawnTeam = () => {
                                if (typeof spawnPlayer === 'function') {
                                    spawnPlayer(spawnOnPlayerSide);
                                } else {
                                    setTimeout(trySpawnTeam, 100);
                                }
                            };
                            trySpawnTeam();

                            // Get the host's peer ID from the connection
                            const hostId = currentRoomId; // The room ID is the host's peer ID

                            // Add host to squadData and roomPlayers (so they show in squad list)
                            if (hostId) {
                                squadData.set(hostId, {
                                    username: 'Host', // Will be updated when we receive their username
                                    team: 1, // Host is always team 1
                                    health: 100
                                });
                                if (!roomPlayers.includes(hostId)) {
                                    roomPlayers.push(hostId);
                                }
                            }

                            // Show squad list for client
                            if (window.updateLobbySquadList) {
                                window.updateLobbySquadList();
                            }

                            // Add host character to menu scene (client side)
                            if (window.addOpponentToMenuScene) {
                                window.addOpponentToMenuScene('Host', hostId || 'host');
                            }

                            // Create mesh for other players if they exist
                            if (gameData.existingPlayers) {
                                gameData.existingPlayers.forEach((existingPlayer) => {
                                    if (existingPlayer.playerId !== myPlayerId) {
                                        // Add to squadData for squad list
                                        if (!window.squadData) window.squadData = new Map();
                                        window.squadData.set(existingPlayer.playerId, {
                                            username: existingPlayer.username || 'Player',
                                            team: existingPlayer.team,
                                            health: 100
                                        });

                                        // Add to roomPlayers for squad list
                                        if (!window.roomPlayers) window.roomPlayers = [];
                                        if (!window.roomPlayers.includes(existingPlayer.playerId)) {
                                            window.roomPlayers.push(existingPlayer.playerId);
                                        }

                                        // Add character to menu scene
                                        if (window.addOpponentToMenuScene) {
                                            window.addOpponentToMenuScene(existingPlayer.username || 'Player', existingPlayer.playerId);
                                        }

                                        // Calculate spawn index based on existing players of same team
                                        const sameTeamPlayers = otherPlayers.filter(p => p && p.team === existingPlayer.team);
                                        const spawnIndex = sameTeamPlayers.length;
                                        const playerMesh = createOtherPlayerMesh2v2(
                                            existingPlayer.playerId,
                                            existingPlayer.team,
                                            spawnIndex
                                        );
                                        playerMesh.playerId = existingPlayer.playerId;
                                        playerMesh.team = existingPlayer.team;
                                        scene.add(playerMesh);
                                        otherPlayers.push({
                                            playerId: existingPlayer.playerId,
                                            mesh: playerMesh,
                                            team: existingPlayer.team
                                        });
                                    }
                                });

                                // Update squad list after adding all players
                                if (window.updateLobbySquadList) {
                                    window.updateLobbySquadList();
                                }
                            }
                        }

                        // Handle player joined for 2v2 clients
                        if (gameMode === '2v2' && gameData.type === 'playerJoined') {
                            if (gameData.playerId !== myPlayerId) {
                                if (!otherPlayers.find(p => p && p.playerId === gameData.playerId)) {
                                    // Add to squadData for squad list
                                    if (!window.squadData) window.squadData = new Map();
                                    window.squadData.set(gameData.playerId, {
                                        username: gameData.username || 'Player',
                                        team: gameData.team,
                                        health: 100
                                    });

                                    // Add to roomPlayers for squad list
                                    if (!window.roomPlayers) window.roomPlayers = [];
                                    if (!window.roomPlayers.includes(gameData.playerId)) {
                                        window.roomPlayers.push(gameData.playerId);
                                    }

                                    // Calculate spawn index based on existing players of same team
                                    const sameTeamPlayers = otherPlayers.filter(p => p && p.team === gameData.team);
                                    const spawnIndex = sameTeamPlayers.length;
                                    const playerMesh = createOtherPlayerMesh2v2(
                                        gameData.playerId,
                                        gameData.team,
                                        spawnIndex
                                    );
                                    playerMesh.playerId = gameData.playerId;
                                    playerMesh.team = gameData.team;
                                    scene.add(playerMesh);
                                    otherPlayers.push({
                                        playerId: gameData.playerId,
                                        mesh: playerMesh,
                                        team: gameData.team
                                    });

                                    // Update squad list when new player joins
                                    if (window.updateLobbySquadList) {
                                        window.updateLobbySquadList();
                                    }

                                    // Add to menu scene
                                    if (window.addOpponentToMenuScene) {
                                        window.addOpponentToMenuScene(gameData.username || 'Player', gameData.playerId);
                                    }

                                    console.log(`✅ 2v2: Added player ${gameData.playerId} to team ${gameData.team}`);
                                }
                            }
                        }

                        // Handle player left for 2v2
                        if (gameMode === '2v2' && gameData.type === 'playerLeft') {
                            const playerIndex = otherPlayers.findIndex(p => p && p.playerId === gameData.playerId);
                            if (playerIndex !== -1) {
                                const playerData = otherPlayers[playerIndex];
                                if (playerData.mesh && scene) {
                                    scene.remove(playerData.mesh);
                                }
                                otherPlayers.splice(playerIndex, 1);

                                // Remove from squad data
                                squadData.delete(gameData.playerId);
                                updateSquadList();

                                console.log(`✅ Removed player ${gameData.playerId} from 2v2 game`);
                            }
                        }

                        // Immediately handle the data
                        handleNetworkData(gameData);
                    } catch (e) {
                        console.error('❌ Error parsing WebRTC data:', e, data);
                    }
                });

                conn.on('close', () => {
                    console.warn('⚠️ Data channel closed', playerId ? `(Player: ${playerId})` : '');
                    if (gameMode === '1v1') {
                        connectionQuality = 'unknown';
                        if (gameState && gameState.started) {
                            alert('Connection lost!');
                        }
                    }
                });

                conn.on('error', (err) => {
                    console.error('❌ Data channel error:', err, playerId ? `(Player: ${playerId})` : '');
                });
            }

            // Also check if connection is already open
            if (conn.open) {
                console.log('✅ Connection already open!', playerId ? `(Player: ${playerId})` : '');
                connectionQuality = 'good';
                isMultiplayer = true;
                window.isMultiplayer = true; // Expose globally for emote system
            }
        }

        function connectToServer() {
            return new Promise((resolve, reject) => {
                const tryServer = (index) => {
                    if (index >= SERVER_URLS.length) {
                        if (gameMode === '2v2') {
                            reject(new Error('All Socket.IO servers failed. 2v2 mode requires a running server. Please start the server with "node server.js" or add a remote server URL to SERVER_URLS.'));
                        } else {
                            reject(new Error('Socket.IO servers failed. WebRTC should be used instead.'));
                        }
                        return;
                    }

                    const serverUrl = SERVER_URLS[index];
                    console.log(`🌐 Connecting to Socket.IO server ${index + 1}/${SERVER_URLS.length}:`, serverUrl);

                    // Enhanced connection options for global multiplayer
                    socket = io(serverUrl, {
                        transports: ['websocket', 'polling'], // Try websocket first, fallback to polling
                        timeout: 10000, // Increased timeout for global connections (10 seconds)
                        reconnection: true,
                        reconnectionDelay: 1000,
                        reconnectionDelayMax: 5000,
                        reconnectionAttempts: 5,
                        forceNew: true, // Force new connection
                        upgrade: true, // Allow transport upgrades
                        rememberUpgrade: true
                    });

                    // Measure connection quality
                    const connectionStartTime = Date.now();
                    let pingStartTime = null;

                    const connectTimeout = setTimeout(() => {
                        if (!socket || !socket.connected) {
                            console.warn(`⏱️ Server ${index + 1} timeout (10s), trying next...`);
                            if (socket) {
                                socket.disconnect();
                                socket = null;
                            }
                            tryServer(index + 1);
                        }
                    }, 10000); // 10 second timeout for global connections

                    socket.on('connect', () => {
                        clearTimeout(connectTimeout);
                        const connectionTime = Date.now() - connectionStartTime;

                        // Determine connection quality based on connection time
                        if (connectionTime < 1000) {
                            connectionQuality = 'good';
                        } else if (connectionTime < 3000) {
                            connectionQuality = 'medium';
                        } else {
                            connectionQuality = 'poor';
                        }

                        console.log('✅ Connected to server!', socket.id);
                        console.log('🌍 Server:', serverUrl);
                        console.log('📊 Connection quality:', connectionQuality, `(${connectionTime}ms)`);
                        myPlayerId = socket.id;
                        currentServerIndex = index;

                        // Start ping measurement
                        pingStartTime = Date.now();
                        socket.emit('ping', { timestamp: pingStartTime });

                        resolve();
                    });

                    // Handle ping response for latency measurement
                    socket.on('pong', (data) => {
                        if (pingStartTime) {
                            const latency = Date.now() - pingStartTime;
                            console.log('📡 Latency:', latency + 'ms');

                            // Update connection quality based on latency
                            if (latency < 100) {
                                connectionQuality = 'good';
                            } else if (latency < 300) {
                                connectionQuality = 'medium';
                            } else {
                                connectionQuality = 'poor';
                            }
                        }
                    });

                    socket.on('connect_error', (error) => {
                        clearTimeout(connectTimeout);
                        console.error(`❌ Server ${index + 1} error:`, error.message);

                        // More specific error messages
                        if (error.message.includes('xhr poll error') || error.message.includes('Network Error')) {
                            console.error('💡 Network error - check your internet connection');
                        } else if (error.message.includes('timeout')) {
                            console.error('💡 Connection timeout - server may be down or unreachable');
                        } else if (error.message.includes('CORS')) {
                            console.error('💡 CORS error - server configuration issue');
                        }

                        if (socket) {
                            socket.disconnect();
                            socket = null;
                        }
                        tryServer(index + 1);
                    });

                    socket.on('disconnect', (reason) => {
                        console.warn('⚠️ Disconnected from server:', reason);
                        connectionQuality = 'unknown';

                        // Auto-reconnect for certain disconnect reasons
                        if (reason === 'io server disconnect') {
                            // Server disconnected, try to reconnect
                            socket.connect();
                        }
                    });

                    socket.on('reconnect', (attemptNumber) => {
                        console.log('🔄 Reconnected after', attemptNumber, 'attempts');
                    });

                    socket.on('reconnect_error', (error) => {
                        console.error('❌ Reconnection error:', error.message);
                    });

                    socket.on('reconnect_failed', () => {
                        console.error('❌ Reconnection failed - all attempts exhausted');
                        alert('Connection lost. Please refresh the page.');
                    });

                    // Handle incoming game data
                    socket.on('gameData', (data) => {
                        if (data.from !== myPlayerId) {
                            handleNetworkData(data.data);
                        }
                    });

                    // Handle player joined
                    socket.on('playerJoined', (data) => {
                        console.log('✅ Player joined room:', data);
                        if (data.playerId !== myPlayerId) {
                            if (gameMode === '2v2') {
                                // 2v2 mode: add to otherPlayers array
                                if (!otherPlayers.find(p => p && p.playerId === data.playerId)) {
                                    const playerTeam = data.team || 1;
                                    const spawnIndex = otherPlayers.filter(p => p && p.team === playerTeam).length;
                                    const playerMesh = createOtherPlayerMesh2v2(data.playerId, playerTeam, spawnIndex);
                                    playerMesh.playerId = data.playerId;
                                    playerMesh.team = playerTeam;
                                    scene.add(playerMesh);
                                    otherPlayers.push({ playerId: data.playerId, mesh: playerMesh, team: playerTeam });
                                    roomPlayers.push(data.playerId);

                                    // Initialize squad data for ALL players (teammates and enemies)
                                    squadData.set(data.playerId, {
                                        health: 100,
                                        weapon: 'rifle',
                                        isDying: false,
                                        username: `Player ${data.playerId.substring(0, 4)}`
                                    });
                                    updateSquadList();

                                    console.log(`✅ 2v2: Added player ${data.playerId} to team ${playerTeam}`);
                                }
                            } else {
                                // 1v1 mode: single otherPlayer
                                otherPlayerId = data.playerId;
                                if (window.createMultiplayerOpponent) {
                                    window.createMultiplayerOpponent();
                                }
                            }

                            // Send username to the newly joined player
                            if (gameState.playerUsername) {
                                socket.emit('gameData', {
                                    room: currentRoomId,
                                    data: { type: 'username', username: gameState.playerUsername, playerId: myPlayerId }
                                });
                                console.log('📋 Sent username to new player:', gameState.playerUsername);
                            }
                        }

                        // Check if room is full and start game
                        if (gameMode === '2v2' && data.totalPlayers >= 4) {
                            console.log('✅ 2v2 Room full! Starting game...');
                            setTimeout(() => {
                                if (document.getElementById('startScreen')) {
                                    document.getElementById('startScreen').style.display = 'none';
                                    if (window.menuSceneController) window.menuSceneController.hide();
                                }
                                // Hide lobby squad list
                                const lobbyList2 = document.getElementById('lobbySquadList');
                                if (lobbyList2) lobbyList2.style.display = 'none';
                                // Show Minecraft XP HUD
                                const mcHud2 = document.getElementById('mcXpHud');
                                if (mcHud2) mcHud2.classList.add('visible');
                                // Hide music player and stop music when game starts
                                if (window.MusicPlayer && typeof window.MusicPlayer.handleGameStart === 'function') {
                                    window.MusicPlayer.handleGameStart();
                                }
                                gameState.started = true;

                                // Show R6 Topbar
                                if (typeof showR6Topbar === 'function') showR6Topbar();

                                if (renderer && renderer.domElement) {
                                    renderer.domElement.requestPointerLock();
                                }
                                updateHUD();
                                if (!window.animateStarted) {
                                    window.animateStarted = true;
                                    animate();
                                }
                            }, 1000);
                        }
                    });

                    // Handle team assignment
                    socket.on('teamAssigned', (data) => {
                        myTeam = data.team;
                        console.log(`✅ Assigned to Team ${myTeam}`);

                        // Set spawn position based on team (defer until function is available)
                        const spawnOnPlayerSide = myTeam === 1;
                        const trySpawnSocket = () => {
                            if (typeof spawnPlayer === 'function') {
                                spawnPlayer(spawnOnPlayerSide);
                            } else {
                                setTimeout(trySpawnSocket, 100);
                            }
                        };
                        trySpawnSocket();
                    });

                    // Handle room info
                    socket.on('roomInfo', (data) => {
                        console.log('📋 Room info:', data);
                        roomPlayers = data.players || [];
                        // Create player meshes for existing players
                        if (gameMode === '2v2' && data.teams) {
                            data.players.forEach((playerId, index) => {
                                if (playerId !== myPlayerId) {
                                    const playerTeam = data.teams.team1.includes(playerId) ? 1 : 2;
                                    const spawnIndex = otherPlayers.filter(p => p && p.team === playerTeam).length;
                                    const playerMesh = createOtherPlayerMesh2v2(playerId, playerTeam, spawnIndex);
                                    playerMesh.playerId = playerId;
                                    playerMesh.team = playerTeam;
                                    scene.add(playerMesh);
                                    otherPlayers.push({ playerId: playerId, mesh: playerMesh, team: playerTeam });

                                    // Initialize squad data for ALL players (teammates and enemies)
                                    squadData.set(playerId, {
                                        health: 100,
                                        weapon: 'rifle',
                                        isDying: false,
                                        username: `Player ${playerId.substring(0, 4)}`
                                    });
                                }
                            });
                            updateSquadList();
                        }
                    });

                    // Handle room joined
                    socket.on('roomJoined', (data) => {
                        if (data.success) {
                            console.log(`✅ Joined room: ${data.room}, Mode: ${data.mode}, Team: ${data.team}`);
                            currentRoomId = data.room;
                            gameMode = data.mode || '1v1';
                            myTeam = data.team || 1;

                            // Request room info
                            socket.emit('getRoomInfo', { room: currentRoomId });
                        }
                    });

                    // Handle player left
                    socket.on('playerLeft', (data) => {
                        console.log('❌ Player left:', data.playerId);

                        if (gameMode === '2v2') {
                            // 2v2: remove player from otherPlayers array
                            const playerIndex = otherPlayers.findIndex(p => p && p.playerId === data.playerId);
                            if (playerIndex !== -1) {
                                const playerData = otherPlayers[playerIndex];
                                if (playerData.mesh && scene) {
                                    scene.remove(playerData.mesh);
                                }
                                otherPlayers.splice(playerIndex, 1);

                                // Remove from squad data
                                squadData.delete(data.playerId);
                                updateSquadList();

                                console.log(`✅ Removed player ${data.playerId} from 2v2 game`);
                            }
                        }

                        if (gameState && gameState.started) {
                            alert('Player disconnected!');
                        }
                    });
                };

                tryServer(0);
            });
        }

        // Handle incoming data with position interpolation
        let lastPositionLog = 0;

        // Track enemy speaker icon fade timeout
        let enemySpeakerIconFadeTimeout = null;

        // Function to fade out enemy speaker icon opacity
        function fadeOutEnemySpeakerIcon(duration = 3000) {
            console.log('🔊 fadeOutEnemySpeakerIcon called, duration:', duration);
            if (!enemySpeakerIcon) {
                console.log('🔊 enemySpeakerIcon is null, returning');
                return;
            }
            console.log('🔊 Starting fade out, current visibility:', enemySpeakerIcon.visible);

            const startTime = Date.now();
            const startOpacity = 0.9; // Initial opacity from createSpeakerIcon

            function updateOpacity() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const opacity = startOpacity * (1 - progress);

                // Update opacity for all meshes in the speaker icon group
                enemySpeakerIcon.traverse((child) => {
                    if (child.material && child.material.transparent) {
                        child.material.opacity = opacity;
                    }
                });

                if (progress < 1) {
                    requestAnimationFrame(updateOpacity);
                } else {
                    enemySpeakerIcon.visible = false;
                    // Reset opacity for next time
                    enemySpeakerIcon.traverse((child) => {
                        if (child.material && child.material.transparent) {
                            child.material.opacity = startOpacity;
                        }
                    });

                    // Stop the death sound completely when fade finishes
                    if (activeOtherPlayerDeathSound && activeOtherPlayerDeathSound.source) {
                        console.log('🔊 Stopping death sound completely after fade out');
                        try {
                            activeOtherPlayerDeathSound.source.stop();
                        } catch (e) {
                            console.log('Source already stopped or invalid:', e);
                        }
                        activeOtherPlayerDeathSound.source.disconnect();
                        activeOtherPlayerDeathSound.gainNode.disconnect();
                        activeOtherPlayerDeathSound = { source: null, gainNode: null };
                    }
                }
            }

            updateOpacity();
        }

        function otherPlayerDied(deathType = 'front') {
            // Prevent multiple death triggers
            if (!otherPlayer || otherPlayer.isDying) {
                console.log('🔄 otherPlayerDied called but already dying or no player, skipping');
                return;
            }

            console.log('💀 otherPlayerDied called - starting death sequence');
            otherPlayer.isDying = true;
            otherPlayer.deathTimer = 0;

            // Trigger skeleton death animation if applicable
            if (otherPlayer.skinName === 'skeleton' && window.SkeletonAnimationSystem) {
                // Determine death animation type based on hit direction
                let deathAnimName = 'deathFront';
                switch (deathType) {
                    case 'back': deathAnimName = 'deathBack'; break;
                    case 'right': deathAnimName = 'deathRight'; break;
                    case 'headshot_front': deathAnimName = 'deathFrontHeadshot'; break;
                    case 'headshot_back': deathAnimName = 'deathBackHeadshot'; break;
                    case 'headshot_crouch': deathAnimName = 'deathCrouchingHeadshot'; break;
                    default: deathAnimName = 'deathFront';
                }

                SkeletonAnimationSystem.updateState(otherPlayer.skeletonId, {
                    isDead: true,
                    deathType: deathAnimName
                });
                console.log('💀 Playing skeleton death animation:', deathAnimName);
            }

            const distance = camera.position.distanceTo(otherPlayer.position);
            const maxDistance = 50; // Max distance to hear the sound
            const minVolume = 0.1; // Minimum volume so sound never completely shuts off
            // Use exponential falloff for more natural sound attenuation
            let volume = Math.exp(-distance / maxDistance);
            volume = Math.max(minVolume, Math.min(1, volume)); // Clamp volume between minVolume and 1

            console.log('🔊 otherPlayerDied called - enemySpeakerIcon visibility:', enemySpeakerIcon?.visible);

            // Clear any pending fade timeouts from previous deaths
            if (enemySpeakerIconFadeTimeout) {
                console.log('🔊 Clearing existing enemySpeakerIconFadeTimeout:', enemySpeakerIconFadeTimeout);
                clearTimeout(enemySpeakerIconFadeTimeout);
                enemySpeakerIconFadeTimeout = null;
            }

            // Test function for rapid other player deaths
            window.testRapidOtherDeaths = function () {
                console.log('🧪 Testing rapid other player deaths...');
                otherPlayerDied();
                setTimeout(() => {
                    console.log('🧪 Second other death after 500ms');
                    otherPlayerDied();
                }, 500);
                setTimeout(() => {
                    console.log('🧪 Third other death after 1000ms');
                    otherPlayerDied();
                }, 1000);
            };

            // Play death sound for other player
            if (deathSoundMedia) {
                deathSoundMedia.play(volume, 1);
            } else if (deathSoundBuffer) {
                // Stop any existing death sound immediately
                if (activeOtherPlayerDeathSound && activeOtherPlayerDeathSound.source) {
                    try {
                        activeOtherPlayerDeathSound.source.stop();
                        activeOtherPlayerDeathSound.source.disconnect();
                        activeOtherPlayerDeathSound.gainNode.disconnect();
                    } catch (e) {
                        console.log('Error stopping previous death sound:', e);
                    }
                    activeOtherPlayerDeathSound = { source: null, gainNode: null };
                }

                const soundDuration = 8; // Extended duration - sound continues much longer after respawn
                const { source, gainNode } = playSound(deathSoundBuffer, volume, 1); // Play from 1s
                activeOtherPlayerDeathSound = { source, gainNode }; // Store both

                // Schedule the fade out and stop if it plays to its full duration
                gainNode.gain.setValueAtTime(gainNode.gain.value, audioContext.currentTime); // Set initial gain
                gainNode.gain.setValueAtTime(gainNode.gain.value, audioContext.currentTime + 4); // Keep full volume for 4 seconds
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 6); // Then fade out over last 2 seconds
                source.stop(audioContext.currentTime + 6);

                // Also, ensure the source disconnects when it ends
                source.onended = () => {
                    source.disconnect();
                    gainNode.disconnect();
                    if (activeOtherPlayerDeathSound.source === source) { // Only nullify if it's still the active one
                        activeOtherPlayerDeathSound = { source: null, gainNode: null };
                        // Only reset speaker icon if this is still the current sound
                        if (enemySpeakerIcon && !otherPlayer.isDying) {
                            enemySpeakerIcon.visible = false;
                        }
                    }
                };
            }

            // Make speaker icon visible only when player dies
            if (enemySpeakerIcon) {
                console.log('🔊 Setting enemySpeakerIcon.visible = true');
                enemySpeakerIcon.visible = true;
                // Reset opacity to full for fade effect
                enemySpeakerIcon.traverse((child) => {
                    if (child.material && child.material.transparent) {
                        child.material.opacity = 0.9;
                    }
                });

                // Start fade out after 4 seconds (sooner fade)
                enemySpeakerIconFadeTimeout = setTimeout(() => {
                    console.log('🔊 Starting fadeOutEnemySpeakerIcon after 4s delay (sooner)');
                    fadeOutEnemySpeakerIcon(2000); // Faster fade out over 2 seconds
                }, 4000);
                console.log('🔊 Set enemySpeakerIconFadeTimeout to:', enemySpeakerIconFadeTimeout);
            }

            // Fixed respawn timer - independent of sound duration
            setTimeout(() => {
                console.log('🔊 Respawn timer fired - resetting otherPlayer.isDying to false');
                otherPlayer.isDying = false;
                otherPlayer.visible = false; // Hide until they respawn and send new position

                // Reset skeleton animation state for respawn
                if (otherPlayer.skinName === 'skeleton' && window.SkeletonAnimationSystem && otherPlayer.skeletonId) {
                    SkeletonAnimationSystem.updateState(otherPlayer.skeletonId, {
                        isDead: false,
                        velocity: { x: 0, z: 0 },
                        isCrouching: false,
                        isSprinting: false,
                        isJumping: false
                    });
                    console.log('💀 Reset skeleton animation state for respawn');
                }

                // Reset rotation for skeleton (was changed by death animation)
                if (otherPlayer.skinName === 'skeleton') {
                    otherPlayer.rotation.x = 0;
                    otherPlayer.rotation.z = 0;
                }
            }, 3000); // 3 second fixed respawn timer
        }

        // PERF: Reuse vectors for networked bullet tracers
        const _netShootStart = new THREE.Vector3();
        const _netShootEnd = new THREE.Vector3();

        function handleNetworkData(data) {
            // Handle both string and parsed data
            if (typeof data === 'string') {
                try {
                    data = JSON.parse(data);
                } catch (e) {
                    console.error('❌ Error parsing network data:', e, data);
                    return;
                }
            }

            // Validate data structure
            if (!data || typeof data !== 'object' || !data.type) {
                console.error('❌ Invalid network data:', data);
                return;
            }

            // Only log non-position data to avoid spam
            if (data.type !== 'position') {
                console.log('📨 Received network data:', data.type, data);
            }

            // Messages that don't require a player mesh to exist
            const setupMessages = ['test', 'teamAssigned', 'playerJoined', 'username', 'startGame', 'lobbyJoined', 'lobbyNameUpdate', 'requestUsername', 'hostInfo', 'skinChange', 'emote', 'emoteStop', 'voiceStatus'];
            const isSetupMessage = setupMessages.includes(data.type);

            // 2v2 mode: find the player mesh by playerId (only for gameplay messages)
            let targetPlayer = null;
            if (gameMode === '2v2' && data.playerId && !isSetupMessage) {
                const playerData = otherPlayers.find(p => p && p.playerId === data.playerId);
                if (playerData) {
                    targetPlayer = playerData.mesh;
                } else {
                    // Player not found, might need to create it
                    console.warn('⚠️ Player not found in 2v2 mode:', data.playerId, '- message type:', data.type);
                    return;
                }
            } else if (gameMode !== '2v2') {
                // 1v1 mode: use otherPlayer
                targetPlayer = otherPlayer;

                // Ensure otherPlayer exists
                if (!otherPlayer) {
                    console.warn('⚠️ otherPlayer not initialized, creating now...');
                    // Try to create other player if it doesn't exist
                    if (window.createMultiplayerOpponent) {
                        window.createMultiplayerOpponent();
                    }
                    // If still no otherPlayer after creation attempt, wait a bit and retry
                    if (!otherPlayer) {
                        setTimeout(() => {
                            if (window.createMultiplayerOpponent) {
                                window.createMultiplayerOpponent();
                            }
                            if (otherPlayer && data.type === 'position') {
                                handleNetworkData(data); // Retry handling this data
                            }
                        }, 100);
                    }
                    return;
                }

                // Ensure otherPlayer is in scene
                if (otherPlayer && scene && !scene.children.includes(otherPlayer)) {
                    console.log('⚠️ otherPlayer not in scene, adding now...');
                    scene.add(otherPlayer);
                }
            }

            // Only require targetPlayer for gameplay messages (not setup messages)
            if (!targetPlayer && !isSetupMessage) {
                console.warn('⚠️ No target player found for data:', data);
                return;
            }

            switch (data.type) {
                case 'test':
                    console.log('✅ Received connection test - connection is working!');
                    break;
                case 'died':
                    // Other player died
                    console.log('💀 Received death notification from player:', data.playerId);
                    if (gameMode === '2v2') {
                        // Find the player who died
                        const deadPlayerData = otherPlayers.find(p => p && p.playerId === data.playerId);

                        // Set isDying on the mesh for death animation
                        if (deadPlayerData && deadPlayerData.mesh) {
                            deadPlayerData.mesh.isDying = true;
                            deadPlayerData.mesh.deathTimer = 0;

                            // Trigger skeleton death animation if applicable
                            if (deadPlayerData.mesh.skinName === 'skeleton' && window.SkeletonAnimationSystem && deadPlayerData.mesh.skeletonId) {
                                const deathType = data.deathType || 'front';
                                let deathAnimName = 'deathFront';
                                switch (deathType) {
                                    case 'back': deathAnimName = 'deathBack'; break;
                                    case 'right': deathAnimName = 'deathRight'; break;
                                    case 'headshot_front': deathAnimName = 'deathFrontHeadshot'; break;
                                    case 'headshot_back': deathAnimName = 'deathBackHeadshot'; break;
                                    case 'headshot_crouch': deathAnimName = 'deathCrouchingHeadshot'; break;
                                    default: deathAnimName = 'deathFront';
                                }
                                SkeletonAnimationSystem.updateState(deadPlayerData.mesh.skeletonId, {
                                    isDead: true,
                                    deathType: deathAnimName
                                });
                                console.log('💀 Playing 2v2 skeleton death animation:', deathAnimName);
                            }
                        }

                        // Update squad data for the dead player
                        if (data.playerId) {
                            const squadInfo = squadData.get(data.playerId) || { health: 100, weapon: 'rifle', isDying: false };
                            squadInfo.health = 0;
                            squadInfo.isDying = true;
                            squadData.set(data.playerId, squadInfo);
                        }

                        // 2v2: team-based scoring - only score if WE killed an enemy
                        const isEnemy = data.team !== myTeam;
                        if (isEnemy) {
                            gameState.playerScore++;
                            const wasHeadshot = data.isHeadshot || lastKillWasHeadshot;
                            LevelSystem.recordKill(wasHeadshot); // Record kill in level system with headshot

                            // Spawn XP orbs at dead player position (Minecraft style!)
                            if (deadPlayerData && deadPlayerData.mesh && deadPlayerData.mesh.position) {
                                const killType = getKillType(wasHeadshot);
                                // PERF: Pass position directly - spawnXPOrbs copies it internally
                                spawnXPOrbs(deadPlayerData.mesh.position, killType);
                                resetKillTracking();
                            }

                            updateHUD();
                            const deadPlayerInfo = squadData.get(data.playerId);
                            const deadPlayerName = deadPlayerInfo?.username || `Enemy (Team ${data.team})`;

                            // Play appropriate kill sound and show message
                            if (wasHeadshot) {
                                if (typeof window.playHeadshotKillSound === 'function') window.playHeadshotKillSound(1.0);
                                addKillFeedMessage(`🎯 HEADSHOT! Eliminated ${deadPlayerName}`);
                            } else {
                                if (typeof window.playKillSound === 'function') window.playKillSound(1.0);
                                addKillFeedMessage(`Eliminated ${deadPlayerName}`);
                            }

                            // Reset body shot sequence after kill
                            if (typeof currentBodyShotIndex !== 'undefined') currentBodyShotIndex = 0;
                            if (typeof lastKillWasHeadshot !== 'undefined') lastKillWasHeadshot = false;

                            // Play death sound for enemy death
                            if (deadPlayerData && deadPlayerData.mesh && deathSoundBuffer) {
                                const distance = camera.position.distanceTo(deadPlayerData.mesh.position);
                                const maxDistance = 50;
                                let volume = Math.exp(-distance / maxDistance);
                                volume = Math.max(0.1, Math.min(1, volume));
                                playSound(deathSoundBuffer, volume, 1);
                            }

                            // Check win condition (first team to 10 kills)
                            if (gameState.playerScore >= 10) {
                                endGame(true);
                            }
                        }

                        // Schedule respawn (reset isDying after 3 seconds)
                        if (deadPlayerData && deadPlayerData.mesh) {
                            setTimeout(() => {
                                deadPlayerData.mesh.isDying = false;
                                deadPlayerData.mesh.visible = false; // Hide until respawn position
                            }, 3000);
                        }
                    } else {
                        // 1v1: individual scoring
                        gameState.playerScore++;
                        const wasHeadshot = data.isHeadshot || lastKillWasHeadshot;
                        LevelSystem.recordKill(wasHeadshot); // Record kill in level system with headshot

                        // Spawn XP orbs at other player position (Minecraft style!)
                        if (otherPlayer && otherPlayer.position) {
                            const killType = getKillType(wasHeadshot);
                            // PERF: Pass position directly - spawnXPOrbs copies it internally
                            spawnXPOrbs(otherPlayer.position, killType);
                            resetKillTracking();
                        }

                        updateHUD();

                        // Play appropriate kill sound and show message
                        if (wasHeadshot) {
                            if (typeof window.playHeadshotKillSound === 'function') window.playHeadshotKillSound(1.0);
                            addKillFeedMessage('🎯 HEADSHOT! You eliminated Enemy');
                        } else {
                            if (typeof window.playKillSound === 'function') window.playKillSound(1.0);
                            addKillFeedMessage('You eliminated Enemy');
                        }

                        // Reset body shot sequence after kill
                        if (typeof currentBodyShotIndex !== 'undefined') currentBodyShotIndex = 0;
                        if (typeof lastKillWasHeadshot !== 'undefined') lastKillWasHeadshot = false;

                        // Pass death type to trigger correct skeleton animation
                        otherPlayerDied(data.deathType || 'front');
                        if (gameState.playerScore >= 10) {
                            endGame(true);
                        }
                    }
                    break;
                case 'respawn':
                    // Other player respawned - reset their death state
                    console.log('🔄 Received respawn notification from player:', data.playerId);
                    if (gameMode === '2v2') {
                        // Find the player who respawned
                        const respawnedPlayerData = otherPlayers.find(p => p && p.playerId === data.playerId);

                        if (respawnedPlayerData && respawnedPlayerData.mesh) {
                            // Reset death state
                            respawnedPlayerData.mesh.isDying = false;
                            respawnedPlayerData.mesh.deathTimer = 0;
                            respawnedPlayerData.mesh.visible = true;

                            // Reset position and rotation to upright
                            respawnedPlayerData.mesh.rotation.x = 0;
                            respawnedPlayerData.mesh.rotation.z = 0;
                            respawnedPlayerData.mesh.position.y = data.y || 1.7;

                            // Reset skeleton animation state for respawn (2v2)
                            if (respawnedPlayerData.mesh.skinName === 'skeleton' && window.SkeletonAnimationSystem && respawnedPlayerData.mesh.skeletonId) {
                                SkeletonAnimationSystem.updateState(respawnedPlayerData.mesh.skeletonId, {
                                    isDead: false,
                                    velocity: { x: 0, z: 0 },
                                    isCrouching: false,
                                    isSprinting: false,
                                    isJumping: false
                                });
                                console.log('💀 Reset 2v2 skeleton animation state on respawn');
                            }

                            // Update target position if provided
                            if (typeof data.x === 'number' && typeof data.z === 'number') {
                                if (respawnedPlayerData.mesh.targetPosition) {
                                    respawnedPlayerData.mesh.targetPosition.set(data.x, data.y || 1.7, data.z);
                                } else {
                                    respawnedPlayerData.mesh.targetPosition = new THREE.Vector3(data.x, data.y || 1.7, data.z);
                                }
                            }
                        }

                        // Update squad data
                        if (data.playerId) {
                            const squadInfo = squadData.get(data.playerId) || { health: 100, weapon: 'rifle', isDying: false, username: 'Player' };
                            squadInfo.health = 100;
                            squadInfo.isDying = false;
                            squadData.set(data.playerId, squadInfo);
                            if (typeof updateSquadList === 'function') updateSquadList();
                        }
                    } else {
                        // 1v1: reset otherPlayer death state
                        if (otherPlayer) {
                            console.log('🔄 Resetting otherPlayer death state');
                            otherPlayer.isDying = false;
                            otherPlayer.deathTimer = 0;
                            otherPlayer.visible = true;

                            // Reset rotation to upright
                            otherPlayer.rotation.x = 0;
                            otherPlayer.rotation.z = 0;
                            otherPlayer.position.y = data.y || 1.7;

                            // Reset skeleton animation state for respawn (1v1)
                            if (otherPlayer.skinName === 'skeleton' && window.SkeletonAnimationSystem && otherPlayer.skeletonId) {
                                SkeletonAnimationSystem.updateState(otherPlayer.skeletonId, {
                                    isDead: false,
                                    velocity: { x: 0, z: 0 },
                                    isCrouching: false,
                                    isSprinting: false,
                                    isJumping: false
                                });
                                console.log('💀 Reset 1v1 skeleton animation state on respawn');
                            }

                            // Update target position if provided
                            if (typeof data.x === 'number' && typeof data.z === 'number') {
                                targetOtherPlayerPosition.set(data.x, data.y || 1.7, data.z);
                            }
                        }

                        // Update squad data for opponent
                        if (otherPlayerId) {
                            const squadInfo = squadData.get(otherPlayerId) || { health: 100, weapon: 'rifle', isDying: false, username: gameState.otherPlayerUsername || 'Player' };
                            squadInfo.health = 100;
                            squadInfo.isDying = false;
                            squadData.set(otherPlayerId, squadInfo);
                            if (typeof updateSquadList === 'function') updateSquadList();
                        }
                    }
                    break;
                case 'position':
                    // Validate position data
                    if (typeof data.x === 'number' && typeof data.y === 'number' && typeof data.z === 'number' &&
                        !isNaN(data.x) && !isNaN(data.y) && !isNaN(data.z) &&
                        isFinite(data.x) && isFinite(data.y) && isFinite(data.z)) {

                        if (gameMode === '2v2') {
                            // 2v2: update specific player's target position
                            if (targetPlayer.targetPosition) {
                                targetPlayer.targetPosition.set(data.x, data.y, data.z);
                            } else {
                                targetPlayer.targetPosition = new THREE.Vector3(data.x, data.y, data.z);
                            }

                            if (typeof data.rx === 'number' && typeof data.ry === 'number' && typeof data.rz === 'number' &&
                                !isNaN(data.rx) && !isNaN(data.ry) && !isNaN(data.rz)) {
                                if (targetPlayer.targetRotation) {
                                    targetPlayer.targetRotation.set(data.rx, data.ry, data.rz);
                                } else {
                                    targetPlayer.targetRotation = new THREE.Euler(data.rx, data.ry, data.rz);
                                }
                            }

                            // If player was dead but is now sending positions, they respawned
                            // Reset their death state if Y position is normal standing height
                            if (targetPlayer.isDying && data.y > 1.5) {
                                console.log('🔄 Auto-detecting respawn from position for 2v2 player');
                                targetPlayer.isDying = false;
                                targetPlayer.deathTimer = 0;
                                targetPlayer.rotation.x = 0;
                                targetPlayer.rotation.z = 0;
                                targetPlayer.visible = true;

                                // Reset skeleton animation state for respawn (2v2 auto-detect)
                                if (targetPlayer.skinName === 'skeleton' && window.SkeletonAnimationSystem && targetPlayer.skeletonId) {
                                    SkeletonAnimationSystem.updateState(targetPlayer.skeletonId, {
                                        isDead: false,
                                        velocity: { x: 0, z: 0 },
                                        isCrouching: false,
                                        isSprinting: false,
                                        isJumping: false
                                    });
                                    console.log('💀 Reset 2v2 skeleton animation state on auto-respawn');
                                }

                                // Update squad data
                                if (data.playerId) {
                                    const squadInfo = squadData.get(data.playerId) || { health: 100, weapon: 'rifle', isDying: false };
                                    squadInfo.health = 100;
                                    squadInfo.isDying = false;
                                    squadData.set(data.playerId, squadInfo);
                                }
                            }
                        } else {
                            // 1v1: update single otherPlayer with smooth interpolation
                            const now = Date.now();
                            const timeSinceLastUpdate = (now - lastPositionUpdateTime) / 1000; // in seconds

                            // Calculate velocity from position delta (for prediction)
                            if (lastPositionUpdateTime > 0 && timeSinceLastUpdate > 0 && timeSinceLastUpdate < 1) {
                                otherPlayerVelocity.set(
                                    (data.x - targetOtherPlayerPosition.x) / timeSinceLastUpdate,
                                    (data.y - targetOtherPlayerPosition.y) / timeSinceLastUpdate,
                                    (data.z - targetOtherPlayerPosition.z) / timeSinceLastUpdate
                                );
                            }

                            // Store current position as start of new interpolation
                            if (otherPlayer) {
                                interpolationStartPos.copy(otherPlayer.position);
                            }

                            // Set new target
                            previousOtherPlayerPosition.copy(targetOtherPlayerPosition);
                            targetOtherPlayerPosition.set(data.x, data.y, data.z);
                            lastPositionUpdateTime = now;

                            // Reset interpolation progress
                            interpolationProgress = 0;

                            if (typeof data.rx === 'number' && typeof data.ry === 'number' && typeof data.rz === 'number' &&
                                !isNaN(data.rx) && !isNaN(data.ry) && !isNaN(data.rz)) {
                                targetOtherPlayerRotation.set(data.rx, data.ry, data.rz);
                            }

                            // Handle animation state from opponent
                            if (data.anim && window.updateOpponentAnimation) {
                                updateOpponentAnimation({
                                    velocity: { x: data.anim.vx || 0, z: data.anim.vz || 0 },
                                    isCrouching: data.anim.crouch || false,
                                    isSprinting: data.anim.sprint || false,
                                    isJumping: data.anim.jump || false,
                                    jumpPhase: data.anim.jumpPhase || null,
                                    isAiming: data.anim.aim || false,
                                    isDead: false
                                });
                            }

                            // If otherPlayer was dead but is now sending positions at standing height, they respawned
                            if (otherPlayer && otherPlayer.isDying && data.y > 1.5) {
                                console.log('🔄 Auto-detecting respawn from position for 1v1 otherPlayer');
                                otherPlayer.isDying = false;
                                otherPlayer.deathTimer = 0;
                                otherPlayer.rotation.x = 0;
                                otherPlayer.rotation.z = 0;
                                otherPlayer.position.y = data.y;
                                otherPlayer.visible = true;

                                // Reset skeleton animation state for respawn
                                if (otherPlayer.skinName === 'skeleton' && window.SkeletonAnimationSystem && otherPlayer.skeletonId) {
                                    SkeletonAnimationSystem.updateState(otherPlayer.skeletonId, {
                                        isDead: false,
                                        velocity: { x: 0, z: 0 },
                                        isCrouching: false,
                                        isSprinting: false,
                                        isJumping: false
                                    });
                                    console.log('💀 Reset skeleton animation state on auto-respawn');
                                }

                                // Update squad data
                                if (otherPlayerId) {
                                    const squadInfo = squadData.get(otherPlayerId) || { health: 100, weapon: 'rifle', isDying: false };
                                    squadInfo.health = 100;
                                    squadInfo.isDying = false;
                                    squadData.set(otherPlayerId, squadInfo);
                                }
                            }
                        }
                    } else {
                        console.error('❌ Invalid position data:', data);
                    }
                    break;
                case 'shoot':
                    console.log('Other player shot!');
                    // Show muzzle flash at other player's position
                    if (scene && targetPlayer) {
                        const flash = new THREE.PointLight(0xffaa00, 5, 12);
                        flash.position.copy(targetPlayer.position);
                        scene.add(flash);
                        setTimeout(() => scene.remove(flash), 50);
                    }

                    // Render the other player's tracer/smoke if endpoints are provided
                    if (
                        typeof data.sx === 'number' && typeof data.sy === 'number' && typeof data.sz === 'number' &&
                        typeof data.ex === 'number' && typeof data.ey === 'number' && typeof data.ez === 'number'
                    ) {
                        _netShootStart.set(data.sx, data.sy, data.sz);
                        _netShootEnd.set(data.ex, data.ey, data.ez);
                        window.createBulletTracer?.(_netShootStart, _netShootEnd, true);
                    }
                    break;
                case 'whiz':
                    // Near-miss: other player missed close to us
                    if (data.target === myPlayerId && typeof data.volume === 'number' && !isNaN(data.volume)) {
                        window.playBulletWhizSound?.(clamp01(data.volume));
                    }
                    break;
                case 'hit':
                    // We got hit by other player
                    console.log('💥 Got hit by other player! Damage:', data.damage);
                    if (data.target === myPlayerId && gameState && typeof data.damage === 'number' && !isNaN(data.damage)) {
                        // Store hit info for death animation
                        gameState.lastHitDirection = data.hitDirection || 'front';
                        gameState.lastHitWasHeadshot = data.isHeadshot || false;

                        // Prevent damage when already dead or dying
                        if (gameState.playerHealth > 0 && !gameState.isDying) {
                            // Play bullet hit sound for multiplayer hit
                            window.playBulletHitSound?.(0.8);
                            
                            gameState.playerHealth -= data.damage;
                            updateHUD();
                            showDamage();
                            if (gameState.playerHealth <= 0) {
                                console.log('💀 Player died from multiplayer hit');
                                // Determine death type for animation
                                let deathType = gameState.lastHitDirection || 'front';
                                if (gameState.lastHitWasHeadshot) {
                                    if (deathType === 'back') deathType = 'headshot_back';
                                    else if (gameState.isSliding) deathType = 'headshot_crouch';
                                    else deathType = 'headshot_front';
                                }
                                playerDied();
                                sendToOther({ type: 'died', team: myTeam, deathType: deathType, isHeadshot: gameState.lastHitWasHeadshot });
                            }
                        } else {
                            console.log('🚫 Ignoring hit - player already dead/dying');
                        }
                    }
                    // Update squad data if teammate got hit
                    if (gameMode === '2v2' && data.playerId && data.target) {
                        const squadInfo = squadData.get(data.target) || { health: 100, weapon: 'rifle', isDying: false };
                        if (typeof data.damage === 'number' && !squadInfo.isDying) {
                            squadInfo.health = Math.max(0, (squadInfo.health || 100) - data.damage);
                            if (squadInfo.health <= 0) {
                                squadInfo.isDying = true;
                            }
                            squadData.set(data.target, squadInfo);
                            updateSquadList();
                        }
                    }
                    break;
                case 'weapon':
                    // Other player switched weapon
                    console.log('Other player switched weapon');
                    break;
                case 'username':
                    // Other player sent their username
                    if (data.username && typeof data.username === 'string') {
                        // Update squad data for ALL players (teammates and enemies)
                        if (data.playerId) {
                            const squadInfo = squadData.get(data.playerId) || { health: 100, weapon: 'rifle', isDying: false };
                            squadInfo.username = data.username;
                            squadData.set(data.playerId, squadInfo);

                            // Also add to roomPlayers if not already there (for squad list)
                            if (!roomPlayers.includes(data.playerId)) {
                                roomPlayers.push(data.playerId);
                            }

                            if (typeof updateSquadList === 'function') updateSquadList();
                            // Also update lobby squad list
                            if (window.updateLobbySquadList) {
                                window.updateLobbySquadList();
                            }
                        }

                        // Update username sprite above player's head in 3D world
                        if (gameMode === '2v2') {
                            // 2v2: find player by playerId and update their username sprite
                            if (data.playerId) {
                                const playerData = otherPlayers.find(p => p && p.playerId === data.playerId);
                                if (playerData && playerData.mesh && playerData.mesh.usernameSprite) {
                                    playerData.mesh.remove(playerData.mesh.usernameSprite);
                                    const newUsernameSprite = createUsernameSprite(data.username, data.level || 1, data.xpProgress || 0);
                                    newUsernameSprite.position.set(0, 1.4, 0);
                                    newUsernameSprite.scale.multiplyScalar(1.5);
                                    playerData.mesh.add(newUsernameSprite);
                                    playerData.mesh.usernameSprite = newUsernameSprite;
                                }

                                // Also update menu scene nametag if still in lobby
                                if (window.updateOpponentNametagInLobby) {
                                    window.updateOpponentNametagInLobby(data.username, data.level || 1);
                                }
                            }
                        } else {
                            // 1v1: update otherPlayer username
                            gameState.otherPlayerUsername = data.username;
                            gameState.otherPlayerLevel = data.level || 1;
                            gameState.otherPlayerXpProgress = data.xpProgress || 0;
                            console.log('📋 Other player username received:', data.username, 'level:', data.level);

                            if (otherPlayer && otherPlayer.usernameSprite) {
                                otherPlayer.remove(otherPlayer.usernameSprite);
                                const newUsernameSprite = createUsernameSprite(data.username, data.level || 1, data.xpProgress || 0);
                                newUsernameSprite.position.set(0, 1.4, 0);
                                newUsernameSprite.scale.multiplyScalar(1.5);
                                otherPlayer.add(newUsernameSprite);
                                otherPlayer.usernameSprite = newUsernameSprite;
                            }
                        }
                    }
                    break;
                case 'lobbyJoined':
                    // Other player joined the lobby - show their character in menu scene
                    console.log('📋 Player joined lobby:', data.username, 'Level:', data.level, 'Skin:', data.skin);
                    gameState.otherPlayerUsername = data.username || 'Player';
                    gameState.otherPlayerLevel = data.level || 1;
                    gameState.otherPlayerAvatar = data.avatar || null;
                    gameState.otherPlayerSkin = data.skin || 'soldier';

                    // Reload in-game opponent skin if it's different from what was loaded
                    if (window.reloadOpponentSkin && data.skin) {
                        window.reloadOpponentSkin(data.skin);
                    }

                    // Preload skeleton animations if opponent is using skeleton skin
                    if (data.skin === 'skeleton' && window.SkeletonAnimationSystem) {
                        console.log('💀 Preloading skeleton animations for opponent...');
                        SkeletonAnimationSystem.loadAnimations();
                    }

                    if (window.addOpponentToMenuScene) {
                        window.addOpponentToMenuScene(data.username || 'Player', data.level || 1, data.skin || 'soldier');
                    }
                    // Update squad list with opponent's data
                    if (window.updateLobbySquadList) {
                        window.updateLobbySquadList();
                    }
                    // Retry nametag update after a delay (in case model is still loading)
                    setTimeout(() => {
                        if (window.updateOpponentNametagInLobby) {
                            console.log('🔄 Deferred nametag update for lobbyJoined');
                            window.updateOpponentNametagInLobby(data.username || 'Player', data.level || 1);
                        }
                    }, 2000);
                    // Send back our info so client can see host's character too
                    const myLevel = window.LevelSystem ? window.LevelSystem.data.level : 1;
                    const myAvatar = window.ProfilePicture ? window.ProfilePicture.get() : null;
                    const mySkin = window.selectedSkin || 'soldier';
                    sendToOther({ type: 'hostInfo', username: gameState.playerUsername || 'Player', level: myLevel, avatar: myAvatar, skin: mySkin });
                    break;
                case 'hostInfo':
                    // Host sent their info - client should add host's character to menu scene
                    console.log('📋 Host info received:', data.username, 'Level:', data.level, 'Skin:', data.skin);
                    gameState.otherPlayerUsername = data.username || 'Host';
                    gameState.otherPlayerLevel = data.level || 1;
                    gameState.otherPlayerAvatar = data.avatar || null;
                    gameState.otherPlayerSkin = data.skin || 'soldier';

                    // Reload in-game opponent skin if it's different from what was loaded
                    if (window.reloadOpponentSkin && data.skin) {
                        window.reloadOpponentSkin(data.skin);
                    }

                    // Preload skeleton animations if opponent is using skeleton skin
                    if (data.skin === 'skeleton' && window.SkeletonAnimationSystem) {
                        console.log('💀 Preloading skeleton animations for opponent...');
                        SkeletonAnimationSystem.loadAnimations();
                    }

                    if (window.addOpponentToMenuScene && !isHost) {
                        window.addOpponentToMenuScene(data.username || 'Host', data.level || 1, data.skin || 'soldier');
                    }
                    // Update squad list with host's data
                    if (window.updateLobbySquadList) {
                        window.updateLobbySquadList();
                    }
                    // Retry nametag update after a delay (in case model is still loading)
                    setTimeout(() => {
                        if (window.updateOpponentNametagInLobby) {
                            console.log('🔄 Deferred nametag update for hostInfo');
                            window.updateOpponentNametagInLobby(data.username || 'Host', data.level || 1);
                        }
                    }, 2000);
                    break;
                case 'requestUsername':
                    // Host is requesting our username for lobby display
                    console.log('📋 Host requested username, sending:', gameState.playerUsername);
                    const reqLevel = window.LevelSystem ? window.LevelSystem.data.level : 1;
                    const reqAvatar = window.ProfilePicture ? window.ProfilePicture.get() : null;
                    const reqSkin = window.selectedSkin || 'soldier';
                    sendToOther({ type: 'lobbyJoined', username: gameState.playerUsername || 'Player', level: reqLevel, avatar: reqAvatar, skin: reqSkin });
                    break;
                case 'startGame':
                    // Host started the game - start for client too
                    console.log('🎮 Host started the game!');
                    if (window.startGameFromLobby) {
                        window.startGameFromLobby();
                    }
                    break;
                case 'lobbyNameUpdate':
                    // Other player changed their name in the lobby
                    // PERF: console.log + JSON.stringify disabled (expensive in hot path)
                    // console.log('📥 Lobby name update RECEIVED:', data.username, 'Level:', data.level);
                    // console.log('📥 Full data:', JSON.stringify(data));
                    gameState.otherPlayerUsername = data.username || 'Player';
                    gameState.otherPlayerLevel = data.level || gameState.otherPlayerLevel || 1;
                    if (data.avatar) gameState.otherPlayerAvatar = data.avatar;
                    // Update opponent's nametag in the menu scene
                    if (window.updateOpponentNametagInLobby) {
                        // PERF: console.log disabled
                        window.updateOpponentNametagInLobby(data.username || 'Player', data.level || 1);
                    } // PERF: removed console.warn for missing function
                    // Update squad list
                    if (window.updateLobbySquadList) {
                        window.updateLobbySquadList();
                    }
                    break;
                case 'skinChange':
                    // Other player changed their skin in the lobby
                    console.log('👔 Opponent skin change:', data.skin);
                    gameState.otherPlayerSkin = data.skin || 'soldier';
                    // Update opponent's character model in menu scene
                    if (window.updateOpponentSkinInLobby) {
                        window.updateOpponentSkinInLobby(data.skin || 'soldier');
                    }
                    break;
                case 'emote':
                    // Other player is emoting
                    console.log('💃 Opponent emote received, skin:', data.skin);
                    console.log('💃 window.playOpponentEmote exists:', !!window.playOpponentEmote);
                    if (window.playOpponentEmote) {
                        window.playOpponentEmote(data.skin);
                    } else {
                        console.log('❌ playOpponentEmote function not found!');
                    }
                    break;
                case 'emoteStop':
                    // Other player stopped emoting
                    console.log('💃 Opponent stopped emoting');
                    if (window.stopOpponentEmote) {
                        window.stopOpponentEmote();
                    }
                    break;
                case 'voiceStatus':
                    // Other player voice status update - this is now mostly handled by remote audio analysis
                    // But we still use this to get the speaker name and as a backup
                    const speakerName = gameState.otherPlayerUsername || 'Opponent';
                    console.log('📨 Voice status received:', data.speaking, 'from:', speakerName);
                    if (window.VoiceChat) {
                        // Update speaker name in the indicator
                        const nameEl = document.getElementById('opponentSpeakerName');
                        if (nameEl) {
                            nameEl.textContent = speakerName;
                        }
                        // Only show if we're not already doing audio-based detection
                        // This serves as a fallback
                        if (data.speaking && !opponentIsSpeaking) {
                            window.VoiceChat.showOpponentSpeaking(true, speakerName);
                        }
                    }
                    break;
            }
        }

        // Setup multiplayer buttons (will be initialized after initGame)
        function setupMultiplayerButtons() {
            document.getElementById('hostButton').addEventListener('click', async () => {
                console.log('🌐 HOST GAME clicked - WebRTC multiplayer (no server needed!)');
                gameMode = '1v1'; // Set to 1v1 mode
                useWebRTC = true; // Use WebRTC for 1v1

                // Initialize game first
                if (!window.gameInitialized) {
                    console.log('Initializing game...');
                    initGame();
                }

                // CRITICAL: Always capture username from input (was previously inside if block!)
                const usernameInput = document.getElementById('usernameInput');
                const username = usernameInput.value.trim() || 'Player';
                gameState.playerUsername = username;
                console.log('📋 Host username set:', username);

                // Show loading
                document.getElementById('multiplayerSetup').style.display = 'block';
                document.getElementById('hostInfo').style.display = 'block';
                document.getElementById('roomId').value = 'Setting up connection...';
                document.getElementById('waitingText').textContent = '⏳ Setting up WebRTC connection...';

                try {
                    // Connect using WebRTC (no server needed!)
                    const peerId = await connectWebRTC(true);
                    isMultiplayer = true;
                    window.isMultiplayer = true; // Expose globally for emote system
                    isHost = true;

                    // Show room ID (this is the Peer ID)
                    document.getElementById('roomId').value = peerId;
                    document.getElementById('waitingText').textContent = '⏳ Waiting for opponent...\n\nShare this Room ID with your friend!\n\n🌍 Works from anywhere in the world!';

                    // Show lobby squad list (just you for now)
                    if (window.updateLobbySquadList) {
                        window.updateLobbySquadList();
                    }

                    console.log('✅ ROOM CREATED:', peerId);
                    console.log('📋 Share this ID with your friend anywhere in the world!');

                    // Wait for player to join (handled in setupDataChannel and peer connection event)
                    let connectionReady = false;
                    const checkConnection = setInterval(() => {
                        if (dataChannel && (dataChannel.open === true || dataChannel.readyState === 'open')) {
                            if (!connectionReady) {
                                connectionReady = true;
                                clearInterval(checkConnection);
                                document.getElementById('waitingText').innerHTML = '✅ Player connected!<br><span style="color: #66ff66; font-weight: bold;">Waiting in lobby...</span>';

                                // Show START GAME button for host
                                document.getElementById('startGameButton').style.display = 'block';

                                // Add opponent character to menu scene
                                if (window.addOpponentToMenuScene) {
                                    // Request opponent's username
                                    if (dataChannel && dataChannel.open) {
                                        dataChannel.send(JSON.stringify({ type: 'requestUsername' }));
                                    }
                                }
                            }
                        }
                    }, 300);

                    // Cleanup after 30 seconds if no connection
                    setTimeout(() => {
                        if (!connectionReady) {
                            clearInterval(checkConnection);
                        }
                    }, 30000);

                } catch (error) {
                    console.error('WebRTC connection failed:', error);
                    alert('❌ Connection failed: ' + error.message + '\n\nTry again or use "PLAY vs AI" for offline mode.');
                    document.getElementById('multiplayerSetup').style.display = 'none';
                    document.getElementById('hostInfo').style.display = 'none';
                }
            });

            // START GAME button handler (only visible to host)
            document.getElementById('startGameButton').addEventListener('click', () => {
                if (window.resumeGlobalAudio) window.resumeGlobalAudio();
                console.log('🎮 Host starting game!');

                // Send startGame message to other player
                sendToOther({ type: 'startGame' });

                // Start game for host
                if (window.startGameFromLobby) {
                    window.startGameFromLobby();
                }
            });

            document.getElementById('joinButton').addEventListener('click', () => {
                if (window.resumeGlobalAudio) window.resumeGlobalAudio();
                gameMode = '1v1'; // Set to 1v1 mode
                useWebRTC = true; // Use WebRTC for 1v1

                // Initialize game first
                if (!window.gameInitialized) {
                    initGame();
                }

                // CRITICAL: Always capture username from input (was previously inside if block!)
                const usernameInput = document.getElementById('usernameInput');
                const username = usernameInput.value.trim() || 'Player';
                gameState.playerUsername = username;
                console.log('📋 Join username set:', username);

                document.getElementById('multiplayerSetup').style.display = 'block';
                document.getElementById('joinInfo').style.display = 'block';
            });

            document.getElementById('connectButton').addEventListener('click', async () => {
                const roomId = document.getElementById('joinRoomId').value.trim();
                if (!roomId) {
                    alert('Please enter a Room ID!');
                    return;
                }

                // Check if 2v2 mode (handled separately below)
                if (gameMode === '2v2') {
                    // This will be handled by the 2v2 handler added later
                    return;
                }

                otherPlayerId = roomId;

                // Set isHost to false when joining
                isHost = false;
                console.log('🔗 Joining room via WebRTC:', roomId);
                document.getElementById('joinRoomId').value = 'Connecting...';
                document.getElementById('connectButton').disabled = true;

                let connectionCheckInterval = null;
                let connectionTimeout = null;

                try {
                    // Connect using WebRTC
                    await connectWebRTC(false);

                    // Wait a moment for peer to be fully ready
                    await new Promise(resolve => setTimeout(resolve, 500));

                    // Connect to the host peer
                    console.log('Connecting to peer:', roomId);
                    const conn = peer.connect(roomId, {
                        reliable: true
                    });

                    if (!conn) {
                        throw new Error('Failed to create connection');
                    }

                    // Set up connection handlers before setting up data channel
                    conn.on('open', () => {
                        console.log('✅ Connection opened!');
                        if (connectionCheckInterval) clearInterval(connectionCheckInterval);
                        if (connectionTimeout) clearTimeout(connectionTimeout);

                        // Set client spawn position (enemy side) - will be applied when game starts
                        window.clientSpawnPosition = { x: 0, y: 1.7, z: 20 };
                        console.log('✅ Client: Ready to spawn on enemy side (z = 20)');

                        // Show waiting message
                        document.getElementById('joinInfo').innerHTML = '<div style="color: #66ff66; font-size: 14px; text-align: center; padding: 20px;">✅ Connected to host!<br><br><span style="color: rgba(255, 204, 0, 0.9);">Waiting for host to start the game...</span></div>';

                        // Show lobby squad list
                        if (window.updateLobbySquadList) {
                            window.updateLobbySquadList();
                        }

                        // Add opponent character to menu scene and send our username, level, avatar, skin
                        if (window.addOpponentToMenuScene && dataChannel) {
                            const joinLevel = window.LevelSystem ? window.LevelSystem.data.level : 1;
                            const joinAvatar = window.ProfilePicture ? window.ProfilePicture.get() : null;
                            const joinSkin = window.selectedSkin || 'soldier';
                            dataChannel.send(JSON.stringify({
                                type: 'lobbyJoined',
                                username: gameState.playerUsername || 'Player',
                                level: joinLevel,
                                avatar: joinAvatar,
                                skin: joinSkin
                            }));
                        }
                    });

                    conn.on('error', (err) => {
                        console.error('❌ Connection error:', err);
                        if (connectionCheckInterval) clearInterval(connectionCheckInterval);
                        if (connectionTimeout) clearTimeout(connectionTimeout);
                        alert('Connection error: ' + (err.message || 'Failed to connect') + '\n\nMake sure the Room ID is correct and the host is waiting.');
                        document.getElementById('joinRoomId').value = roomId;
                        document.getElementById('connectButton').disabled = false;
                    });

                    conn.on('close', () => {
                        console.warn('⚠️ Connection closed');
                        if (connectionCheckInterval) clearInterval(connectionCheckInterval);
                        if (connectionTimeout) clearTimeout(connectionTimeout);
                        if (!gameState || !gameState.started) {
                            alert('Connection closed. Room may not exist or host disconnected.');
                            document.getElementById('joinRoomId').value = roomId;
                            document.getElementById('connectButton').disabled = false;
                        }
                    });

                    setupDataChannel(conn);
                    currentRoomId = roomId;
                    isMultiplayer = true;
                    window.isMultiplayer = true; // Expose globally for emote system

                    // Wait for connection to open with better checking
                    connectionCheckInterval = setInterval(() => {
                        if (conn.open === true || conn.readyState === 'open') {
                            clearInterval(connectionCheckInterval);
                            if (connectionTimeout) clearTimeout(connectionTimeout);
                            console.log('✅ Connected to host! Waiting in lobby...');

                            // Don't start the game yet - wait for host to start
                            // The game will start when we receive 'startGame' message from host
                        } else if (conn.destroyed) {
                            clearInterval(connectionCheckInterval);
                            if (connectionTimeout) clearTimeout(connectionTimeout);
                            alert('Connection failed. Room may not exist or host disconnected.');
                            document.getElementById('joinRoomId').value = roomId;
                            document.getElementById('connectButton').disabled = false;
                        }
                    }, 300);

                    // Extended timeout for WebRTC connection
                    connectionTimeout = setTimeout(() => {
                        if (!gameState || !gameState.started) {
                            if (connectionCheckInterval) clearInterval(connectionCheckInterval);
                            if (conn && conn.open !== true && conn.readyState !== 'open') {
                                console.error('Connection timeout - peer may be offline');
                                alert('Connection timeout. Please check:\n\n1. Room ID is correct\n2. Host is waiting in the game\n3. Both players have good internet connection\n\nTry again!');
                                document.getElementById('joinRoomId').value = roomId;
                                document.getElementById('connectButton').disabled = false;
                            }
                        }
                    }, 15000); // 15 seconds for WebRTC

                } catch (error) {
                    console.error('Connection failed:', error);
                    if (connectionCheckInterval) clearInterval(connectionCheckInterval);
                    if (connectionTimeout) clearTimeout(connectionTimeout);
                    alert('❌ Connection failed: ' + error.message + '\n\nMake sure:\n1. Room ID is correct\n2. Host is waiting in the game\n3. You have internet connection');
                    document.getElementById('joinRoomId').value = roomId;
                    document.getElementById('connectButton').disabled = false;
                }
            });

            document.getElementById('cancelButton').addEventListener('click', () => {
                document.getElementById('multiplayerSetup').style.display = 'none';
                document.getElementById('hostInfo').style.display = 'none';
                document.getElementById('joinInfo').style.display = 'none';
                if (peer) peer.destroy();
            });

            // ==================== 2V2 MULTIPLAYER BUTTONS ====================
            document.getElementById('host2v2Button').addEventListener('click', async () => {
                console.log('🌐 HOST 2V2 GAME clicked - Using WebRTC (no server needed!)');
                gameMode = '2v2';
                window.gameMode = '2v2'; // Expose globally
                useWebRTC = true; // 2v2 now uses WebRTC like 1v1
                isHost = true;
                myTeam = 1; // Host is team 1
                window.myTeam = 1; // Expose globally

                // Initialize game first
                if (!window.gameInitialized) {
                    console.log('Initializing game for 2v2...');
                    initGame();
                }

                // Capture username from input
                const usernameInput = document.getElementById('usernameInput');
                const username = usernameInput.value.trim() || 'Player';
                gameState.playerUsername = username;
                console.log('📋 Host 2v2 username set:', username);

                // Show loading
                document.getElementById('multiplayerSetup').style.display = 'block';
                document.getElementById('hostInfo').style.display = 'block';
                document.getElementById('roomId').value = 'Setting up WebRTC...';
                document.getElementById('waitingText').textContent = '⏳ Setting up WebRTC connection...';

                try {
                    // Connect using WebRTC (no server needed!)
                    const peerId = await connectWebRTC(true);
                    isMultiplayer = true;
                    window.isMultiplayer = true; // Expose globally for emote system

                    // Show room ID (peer ID)
                    document.getElementById('roomId').value = peerId;
                    document.getElementById('waitingText').textContent = '⏳ Waiting for 3 more players...\n\nShare this Room ID with your teammates!\n\n🌍 2v2 Mode - Team Battle!';

                    console.log('✅ 2v2 ROOM CREATED (WebRTC):', peerId);

                    // Set spawn position for host (team 1) - defer until function is available
                    const trySpawnHost = () => {
                        if (typeof spawnPlayer === 'function') {
                            spawnPlayer(true);
                        } else {
                            setTimeout(trySpawnHost, 100);
                        }
                    };
                    trySpawnHost();

                    // Show squad list for host
                    if (window.updateLobbySquadList) {
                        window.updateLobbySquadList();
                    }

                } catch (error) {
                    console.error('2v2 WebRTC connection failed:', error);
                    alert('❌ 2v2 Connection Failed!\n\n' +
                        'WebRTC connection error.\n\n' +
                        'Please try again or check your internet connection.\n\n' +
                        'Error: ' + error.message);
                    document.getElementById('multiplayerSetup').style.display = 'none';
                    document.getElementById('hostInfo').style.display = 'none';
                }
            });

            document.getElementById('join2v2Button').addEventListener('click', () => {
                gameMode = '2v2';
                window.gameMode = '2v2'; // Expose globally
                useWebRTC = true; // 2v2 now uses WebRTC like 1v1
                isHost = false;

                // Initialize game first
                if (!window.gameInitialized) {
                    initGame();
                }

                // Capture username from input
                const usernameInput = document.getElementById('usernameInput');
                const username = usernameInput.value.trim() || 'Player';
                gameState.playerUsername = username;
                console.log('📋 Join 2v2 username set:', username);

                document.getElementById('multiplayerSetup').style.display = 'block';
                document.getElementById('joinInfo').style.display = 'block';
            });

            // Add 2v2 handler for connect button (runs after 1v1 handler checks gameMode)
            // The 1v1 handler will return early if gameMode is '2v2', so this will handle it
            const connectButton2v2Handler = async () => {
                const roomId = document.getElementById('joinRoomId').value.trim();
                if (!roomId) {
                    alert('Please enter a Room ID!');
                    return;
                }

                if (gameMode !== '2v2') return; // Only handle 2v2

                // 2v2 mode: use WebRTC
                console.log('🔗 Joining 2v2 room via WebRTC:', roomId);
                document.getElementById('joinRoomId').value = 'Connecting...';
                document.getElementById('connectButton').disabled = true;

                let connectionCheckInterval = null;
                let connectionTimeout = null;

                try {
                    // Connect using WebRTC
                    await connectWebRTC(false);

                    // Wait a moment for peer to be fully ready
                    await new Promise(resolve => setTimeout(resolve, 500));

                    // Connect to the host peer
                    console.log('Connecting to peer:', roomId);
                    const conn = peer.connect(roomId, {
                        reliable: true
                    });

                    if (!conn) {
                        throw new Error('Failed to create connection to host');
                    }

                    setupDataChannel(conn, roomId);

                    isMultiplayer = true;
                    window.isMultiplayer = true; // Expose globally for emote system
                    isHost = false;
                    currentRoomId = roomId;

                    // Set up connection check
                    connectionCheckInterval = setInterval(() => {
                        if (dataChannel && (dataChannel.open === true || dataChannel.readyState === 'open' || dataChannel.readyState === 'OPEN')) {
                            clearInterval(connectionCheckInterval);
                            if (connectionTimeout) clearTimeout(connectionTimeout);
                            document.getElementById('joinRoomId').value = 'Connected! Waiting for game...';
                        }
                    }, 100);

                    connectionTimeout = setTimeout(() => {
                        clearInterval(connectionCheckInterval);
                        if (!dataChannel || (dataChannel.open !== true && dataChannel.readyState !== 'open' && dataChannel.readyState !== 'OPEN')) {
                            throw new Error('Connection timeout - host may not be available');
                        }
                    }, 15000); // 15 seconds for WebRTC

                    // Handle connection open
                    conn.on('open', () => {
                        console.log('✅ 2v2 Connection opened!');
                        if (connectionCheckInterval) clearInterval(connectionCheckInterval);
                        if (connectionTimeout) clearTimeout(connectionTimeout);
                        document.getElementById('joinRoomId').value = 'Connected! Waiting for game...';

                        // Show squad list for client
                        if (window.updateLobbySquadList) {
                            window.updateLobbySquadList();
                        }

                        // Send our username to the host
                        if (dataChannel && dataChannel.open) {
                            try {
                                const xpNeeded = LevelSystem.getXPForLevel(LevelSystem.data.level);
                                dataChannel.send(JSON.stringify({
                                    type: 'username',
                                    username: gameState.playerUsername || 'Player',
                                    playerId: myPlayerId,
                                    level: LevelSystem.data.level,
                                    xpProgress: LevelSystem.data.currentXP / xpNeeded
                                }));
                            } catch (e) {
                                console.error('Error sending username:', e);
                            }
                        }
                    });

                } catch (error) {
                    console.error('2v2 WebRTC join failed:', error);
                    if (connectionCheckInterval) clearInterval(connectionCheckInterval);
                    if (connectionTimeout) clearTimeout(connectionTimeout);
                    alert('❌ 2v2 Join Failed!\n\n' +
                        'WebRTC connection error.\n\n' +
                        'Please check:\n' +
                        '1. Room ID is correct\n' +
                        '2. Host is waiting for players\n' +
                        '3. Your internet connection is working\n' +
                        '4. Try again\n\n' +
                        'Error: ' + error.message);
                    document.getElementById('joinRoomId').value = roomId;
                    document.getElementById('connectButton').disabled = false;
                }
            };

            // Add 2v2 handler (will run after 1v1 handler if gameMode is 2v2)
            document.getElementById('connectButton').addEventListener('click', connectButton2v2Handler);
        }

        // Global game variables (accessible from multiplayer handlers)
        // Note: gameState is declared earlier with var for lobby name sync
        let scene, camera, renderer, updateHUD, animate, showDamage, playerDied, endGame, addKillFeedMessage;
        
        // PERF: Global reusable objects to avoid GC spikes (declared here for scope access)
        let _reusableVec3A, _reusableVec3B, _reusableVec3C, _reusableVec3D, _reusableVec3E, _reusableVec3F;
        let _reusableEuler, _reusableQuaternion, _reusableRaycaster, _reusableVec2Zero;
        let _shootRaycaster, _shootVec2Center, _shootBulletStart, _shootBulletEnd, _shootDirection, _shootHitNormal;
        let _smokeCamDirTrail, _smokeCamRightTrail, _smokeMuzzleStart, _smokeVec, _smokeDirection, _smokePerpUp, _smokeRight, _smokeUpVec;
        let _tracerDirection, _tracerMidPoint, _xpToPlayer;
        let _deathKillerPos, _deathLookAtMat, _deathTargetQuat, _deathGlowColor;
        let _smokePoints = [], _smokePointVecs = [];
        let boxes = [];
        let enemy;
        // Weapon globals (used by weapon systems defined outside initGame)
        let weaponScene = null;
        let weaponCamera = null;
        let _pendingWeaponType = null;
        let currentWeaponMesh = null;
        let weaponBobOffset = 0;
        let weaponRecoilOffset = 0;
        let weaponAnimationMixer = null;
        let weaponAnimations = {};
        let loadedWeaponModels = {};
        const weaponClock = (typeof THREE !== 'undefined' && THREE.Clock) ? new THREE.Clock() : null;
        const weaponPhysics = {
            sway: { x: 0, y: 0 },
            recoil: { kick: 0, rot: 0 },
            lastMouseX: 0,
            lastMouseY: 0
        };

        // Defer work until scene exists (some init code runs before initGame)
        const _sceneReadyQueue = [];
        function runWhenSceneReady(fn) {
            if (scene && typeof scene.add === 'function') {
                try { fn(); } catch (e) { console.warn('⚠️ Scene-ready task failed:', e); }
                return;
            }
            _sceneReadyQueue.push(fn);
        }
        function _flushSceneReadyQueue() {
            if (!(scene && typeof scene.add === 'function')) return;
            while (_sceneReadyQueue.length) {
                const fn = _sceneReadyQueue.shift();
                try { fn(); } catch (e) { console.warn('⚠️ Scene-ready task failed:', e); }
            }
        }
        const IS_ELECTRON_APP = /Electron/i.test(navigator.userAgent) || !!(window.process && window.process.versions && window.process.versions.electron);
        const IS_WINDOWS_OS = /Windows/i.test(navigator.userAgent);
        // Native crash workaround: Electron/Chromium on Windows can crash when decoding some MP3s via decodeAudioData.
        const DISABLE_WEBAUDIO_MP3_DECODE = IS_ELECTRON_APP && IS_WINDOWS_OS;

        let deathSoundBuffer = null;
        let ak47SoundBuffer = null;
        let awpSoundBuffer = null;
        let deagleSoundBuffer = null;
        let activeDeathSound = { source: null, gainNode: null };
        let activeOtherPlayerDeathSound = { source: null, gainNode: null };
        let enemySpeakerIcon = null;

        // Safe media-element fallbacks (used when DISABLE_WEBAUDIO_MP3_DECODE is true)
        let deathSoundMedia = null;
        let ak47SoundMedia = null;
        let awpSoundMedia = null;
        let deagleSoundMedia = null;

        // Body shot sounds (1-4.mp3 played in sequence)
        let bodyShotSoundBuffers = [null, null, null, null]; // 1.mp3, 2.mp3, 3.mp3, 4.mp3
        let bodyShotSoundMedias = [null, null, null, null];
        let currentBodyShotIndex = 0; // Track which body shot sound to play next
        let bodyShotResetTimer = null; // Timer to reset sequence after inactivity

        // Kill sounds
        let killedSoundBuffer = null; // killed.mp3
        let killedMedalSoundBuffer = null; // killedmedal.mp3
        let killedSoundMedia = null;
        let killedMedalSoundMedia = null;

        // Headshot kill sounds
        let headshotDead1SoundBuffer = null; // headshotdead1.mp3
        let headshotDead2SoundBuffer = null; // headshotdead2.mp3
        let headshotDead1SoundMedia = null;
        let headshotDead2SoundMedia = null;

        // Bullet sounds (incoming bullets from enemies)
        // hit.mp3, hit2.mp3 - when player gets hit by bullet
        // missed0-4.mp3 - bullet whizzing by (near miss)
        let bulletHitSoundBuffers = [null, null]; // hit.mp3, hit2.mp3
        let bulletMissedSoundBuffers = [null, null, null, null, null]; // missed0-4.mp3
        let bulletHitSoundMedias = [null, null];
        let bulletMissedSoundMedias = [null, null, null, null, null];

        // Multiplayer near-miss "whiz" networking (so the target hears missed*.mp3)
        const BULLET_WHIZ_NEAR_RADIUS = 2.6; // world units (bigger near-miss detection)
        const BULLET_WHIZ_HEAD_OFFSET_Y = 1.0; // also count shots that pass above the head
        const BULLET_WHIZ_SEND_COOLDOWN_MS = 140; // throttle to avoid spam on full-auto
        let _whizSeg, _whizToPoint, _whizClosestPoint, _whizTargetPos, _whizHeadPos;
        let _whizLastSentAtByTarget = null;

        // Track if last kill was a headshot
        let lastKillWasHeadshot = false;

        // Track body shots during current engagement for kill type detection
        let bodyShotsThisKill = 0;
        let headshotsThisKill = 0;

        // ============================================
        // MINECRAFT-STYLE XP ORBS SYSTEM
        // ============================================
        const xpOrbs = []; // Active orbs in scene
        const MAX_XP_ORBS = 100; // PERF: Limit max orbs to prevent buildup
        let orbTextures = {}; // Loaded orb textures
        let orbSoundBuffer = null; // Orb pickup sound
        let orbSoundMedia = null;

        // Orb types based on kill type
        const ORB_TYPES = {
            HEADSHOT_ONLY: 'orb1',    // Pure headshot kill - green/special orb
            BODY_SHOT: 'orb2',         // Body shot kill - normal orb
            MIXED_KILL: 'orb3'         // Body shots + headshot finish - mixed orb
        };

        // Load orb textures
        function loadOrbTextures() {
            const textureLoader = new THREE.TextureLoader();

            // Load all 3 orb types
            textureLoader.load('orbs/orb1.webp', (tex) => {
                tex.colorSpace = THREE.SRGBColorSpace;
                orbTextures.orb1 = tex;
                console.log('✨ Orb texture 1 loaded (headshot)');
            });

            textureLoader.load('orbs/orb2.webp', (tex) => {
                tex.colorSpace = THREE.SRGBColorSpace;
                orbTextures.orb2 = tex;
                console.log('✨ Orb texture 2 loaded (body shot)');
            });

            textureLoader.load('orbs/orb3.png', (tex) => {
                tex.colorSpace = THREE.SRGBColorSpace;
                orbTextures.orb3 = tex;
                console.log('✨ Orb texture 3 loaded (mixed)');
            });

            // Load Minecraft XP sound
            if (DISABLE_WEBAUDIO_MP3_DECODE) {
                orbSoundMedia = createMediaSoundPool('Minecraft xp sound effect.mp3', 4);
                console.log('✨ Minecraft XP sound loaded via media pool (safe mode)');
            } else {
                fetch('Minecraft xp sound effect.mp3')
                    .then(response => response.arrayBuffer())
                    .then(data => {
                        const ctx = ensureAudioContext();
                        if (ctx) {
                            ctx.decodeAudioData(data, (buffer) => {
                                orbSoundBuffer = buffer;
                                console.log('✨ Minecraft XP sound loaded!');
                            });
                        }
                    })
                    .catch(e => console.warn('Could not load XP sound:', e));
            }
        }

        // Create XP orb sprite - with color-based glow
        function createXPOrb(position, orbType) {
            const texture = orbTextures[orbType];
            if (!texture) {
                console.warn('Orb texture not loaded:', orbType);
                return null;
            }

            // Glow color based on orb type
            const glowColors = {
                'orb1': 0x00ffff, // Cyan glow for headshot orb
                'orb2': 0xff3333, // Red glow for body shot orb
                'orb3': 0x33ff33  // Green glow for mixed kill orb
            };

            const material = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                alphaTest: 0.1,
                depthTest: true,
                depthWrite: false,
                sizeAttenuation: true
            });

            const sprite = new THREE.Sprite(material);
            sprite.scale.set(0.25, 0.25, 0.25);
            sprite.position.copy(position);

            // Create glow sprite behind the orb
            const glowMaterial = new THREE.SpriteMaterial({
                color: glowColors[orbType] || 0xffffff,
                transparent: true,
                opacity: 0.4,
                blending: THREE.AdditiveBlending,
                depthTest: true,
                depthWrite: false
            });

            const glowSprite = new THREE.Sprite(glowMaterial);
            glowSprite.scale.set(0.5, 0.5, 0.5); // Larger than orb for glow effect
            sprite.add(glowSprite); // Attach glow to orb
            sprite.userData.glowSprite = glowSprite;

            return sprite;
        }

        // Spawn XP orbs when enemy dies
        function spawnXPOrbs(enemyPosition, killType) {
            if (!scene) return;

            // Determine orb type based on kill
            let orbType;
            if (killType === 'headshot_only') {
                orbType = ORB_TYPES.HEADSHOT_ONLY;
            } else if (killType === 'body_shot') {
                orbType = ORB_TYPES.BODY_SHOT;
            } else {
                orbType = ORB_TYPES.MIXED_KILL;
            }

            // Number of orbs based on kill type
            let orbCount;
            if (killType === 'headshot_only') {
                orbCount = 8 + Math.floor(Math.random() * 5); // 8-12 orbs for headshot
            } else if (killType === 'mixed') {
                orbCount = 5 + Math.floor(Math.random() * 4); // 5-8 orbs for mixed
            } else {
                orbCount = 3 + Math.floor(Math.random() * 3); // 3-5 orbs for body
            }

            // PERF: Pre-allocated vector for spawn position (avoids clone() per orb)
            const _spawnPosTemp = _reusableVec3A || new THREE.Vector3();
            
            // Spawn orbs with random spread and velocity
            for (let i = 0; i < orbCount; i++) {
                // PERF: Copy instead of clone to avoid allocation
                _spawnPosTemp.copy(enemyPosition);
                _spawnPosTemp.y += 1.0; // Start at enemy chest height

                // Random initial burst direction
                const angle = Math.random() * Math.PI * 2;
                const upForce = 3 + Math.random() * 4; // Initial upward velocity
                const outForce = 1 + Math.random() * 2; // Horizontal spread

                const orb = createXPOrb(_spawnPosTemp, orbType);
                if (!orb) continue;

                // Store orb data
                orb.userData = {
                    velocity: new THREE.Vector3(
                        Math.cos(angle) * outForce,
                        upForce,
                        Math.sin(angle) * outForce
                    ),
                    age: 0,
                    maxAge: 10, // Despawn after 10 seconds if not collected
                    collectDelay: 0.5 + Math.random() * 0.3, // Delay before can be collected
                    bobPhase: Math.random() * Math.PI * 2, // Random bob phase
                    rotationSpeed: (Math.random() - 0.5) * 5,
                    collected: false,
                    orbType: orbType
                };

                scene.add(orb);
                xpOrbs.push(orb);

                // PERF: Remove oldest orbs if over limit
                while (xpOrbs.length > MAX_XP_ORBS) {
                    const oldOrb = xpOrbs.shift();
                    scene.remove(oldOrb);
                    if (oldOrb.children) {
                        oldOrb.children.forEach(c => {
                            if (c.material) c.material.dispose();
                        });
                    }
                    if (oldOrb.geometry) oldOrb.geometry.dispose();
                    if (oldOrb.material) oldOrb.material.dispose();
                }
            }
        }

        // Update XP orbs (call in animation loop)
        function updateXPOrbs(deltaTime) {
            if (!camera || xpOrbs.length === 0) return;

            const playerPos = camera.position;
            const collectRadius = 2.5; // Distance to auto-collect
            const magnetRadius = 5.0; // Distance to start attracting
            const collectRadiusSq = collectRadius * collectRadius;
            const magnetRadiusSq = magnetRadius * magnetRadius;
            const gravity = -15; // Gravity
            const friction = 0.98; // Air friction

            for (let i = xpOrbs.length - 1; i >= 0; i--) {
                const orb = xpOrbs[i];
                const data = orb.userData;

                data.age += deltaTime;

                // Remove old orbs
                if (data.age > data.maxAge || data.collected) {
                    scene.remove(orb);
                    // Dispose glow sprite material too (prevents memory leak)
                    if (orb.userData.glowSprite && orb.userData.glowSprite.material) {
                        orb.userData.glowSprite.material.dispose();
                    }
                    orb.material.dispose();
                    xpOrbs.splice(i, 1);
                    continue;
                }

                // Physics update
                if (data.age < data.collectDelay) {
                    // Initial burst phase - just physics
                    data.velocity.y += gravity * deltaTime;
                    data.velocity.multiplyScalar(friction);

                    // Ground collision
                    if (orb.position.y < 0.3) {
                        orb.position.y = 0.3;
                        data.velocity.y = Math.abs(data.velocity.y) * 0.5; // Bounce
                        data.velocity.x *= 0.8;
                        data.velocity.z *= 0.8;
                    }

                    orb.position.addScaledVector(data.velocity, deltaTime);
                } else {
                    // Can be collected - check distance to player
                    _xpToPlayer.subVectors(playerPos, orb.position);
                    const distSq = _xpToPlayer.lengthSq();

                    if (distSq < collectRadiusSq) {
                        // Collect orb!
                        data.collected = true;
                        playOrbPickupSound();
                        continue;
                    }

                    if (distSq < magnetRadiusSq) {
                        // Magnet effect - attract to player
                        const distance = Math.sqrt(distSq) || 0.0001;
                        _xpToPlayer.multiplyScalar(1 / distance);
                        const attractSpeed = 8 + (magnetRadius - distance) * 3; // Faster when closer
                        _xpToPlayer.multiplyScalar(attractSpeed);
                        data.velocity.lerp(_xpToPlayer, deltaTime * 5);
                    } else {
                        // Gentle gravity and bobbing when waiting
                        data.velocity.y += gravity * 0.3 * deltaTime;
                        data.velocity.multiplyScalar(0.95);

                        // Ground collision
                        if (orb.position.y < 0.3) {
                            orb.position.y = 0.3;
                            data.velocity.y = 0;
                        }
                    }

                    orb.position.addScaledVector(data.velocity, deltaTime);

                    // No bobbing - orbs stay still when waiting
                }

                // Subtle glow pulse only (no size change)
                if (orb.userData.glowSprite) {
                    const glowPulse = 0.3 + Math.sin(data.age * 3) * 0.15;
                    orb.userData.glowSprite.material.opacity = glowPulse;
                }
            }
        }

        // Play orb pickup sound (Actual Minecraft XP sound)
        function playOrbPickupSound() {
            if (orbSoundMedia) {
                orbSoundMedia.play(0.4);
                return;
            }
            if (!orbSoundBuffer) {
                // Fallback to generated sound if MP3 not loaded
                const ctx = ensureAudioContext();
                if (!ctx) return;

                const oscillator = ctx.createOscillator();
                const gainNode = ctx.createGain();

                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(1200 + Math.random() * 400, ctx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(800, ctx.currentTime + 0.1);

                gainNode.gain.setValueAtTime(0.15, ctx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.15);

                oscillator.connect(gainNode);
                gainNode.connect(ctx.destination);

                oscillator.start(ctx.currentTime);
                oscillator.stop(ctx.currentTime + 0.15);
                return;
            }

            // Play the actual Minecraft XP sound - 1 second with instant fade
            const ctx = ensureAudioContext();
            if (!ctx) return;

            const source = ctx.createBufferSource();
            source.buffer = orbSoundBuffer;

            // Random pitch variation like Minecraft
            source.playbackRate.value = 0.9 + Math.random() * 0.3;

            const gainNode = ctx.createGain();
            gainNode.gain.setValueAtTime(0.4, ctx.currentTime); // Start volume
            gainNode.gain.setValueAtTime(0.4, ctx.currentTime + 0.8); // Hold for 0.8s
            gainNode.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 1.0); // Instant fade in 0.2s

            source.connect(gainNode);
            gainNode.connect(ctx.destination);

            source.start(0);
            source.stop(ctx.currentTime + 1.0); // Stop after 1 second
        }

        // Determine kill type based on shots fired
        function getKillType(isHeadshot) {
            if (isHeadshot && bodyShotsThisKill === 0) {
                return 'headshot_only'; // Pure headshot kill
            } else if (!isHeadshot && headshotsThisKill === 0) {
                return 'body_shot'; // Pure body shot kill
            } else {
                return 'mixed'; // Mixed kill (body + headshot finish or vice versa)
            }
        }

        // Reset kill tracking
        function resetKillTracking() {
            bodyShotsThisKill = 0;
            headshotsThisKill = 0;
        }
        // ============================================
        // END XP ORBS SYSTEM
        // ============================================

        // Enhanced weapon animation system
        let weaponSwayTime = 0;
        let weaponIdleSway = { x: 0, y: 0, z: 0 };
        let weaponSwayTarget = { x: 0, y: 0, z: 0 };
        let weaponRecoilRotation = { x: 0, y: 0, z: 0 };
        let weaponRecoilY = 0; // Store recoil Y for smooth recovery

        // Audio Context for sound effects - DELAYED to avoid WebRTC conflict
        const AudioContext = window.AudioContext || window.webkit.AudioContext;
        let audioContext = null;
        
        // ========== TRAUMA AUDIO SYSTEM (Shell Shock / Numb Sound) ==========
        let traumaAudioFilter = null; // Low-pass filter for muffled sound
        let traumaAudioBassBoost = null; // Low-shelf filter to boost bass
        let traumaAudioMidScoop = null; // Midrange scoop to simulate ear-plug / pressure
        let traumaAudioCompressor = null; // Compression to mimic ear protection + shock pressure
        let traumaAudioGain = null; // Gain node for volume control
        let tinnitusOscillator = null; // High-pitched ringing
        let tinnitusGain = null;
        let traumaAudioMasterGain = null; // Master output before destination
        let traumaAudioInitialized = false;
        
        // Trauma audio state
        const traumaAudio = {
            currentMuffle: 0, // 0 = normal, 1 = fully muffled
            targetMuffle: 0,
            currentTinnitus: 0,
            targetTinnitus: 0
        };
        
        // Initialize trauma audio system (call after audioContext is created)
        function initTraumaAudio() {
            if (traumaAudioInitialized || !audioContext) return;
            
            try {
                // Create low-pass filter for aggressive muffled effect (shockwave-like)
                traumaAudioFilter = audioContext.createBiquadFilter();
                traumaAudioFilter.type = 'lowpass';
                traumaAudioFilter.frequency.value = 20000; // Start with full frequency (no muffling)
                traumaAudioFilter.Q.value = 1.2; // Slightly lower Q to avoid harsh resonance
                
                // Create low-shelf filter to boost bass frequencies (shockwave rumble)
                traumaAudioBassBoost = audioContext.createBiquadFilter();
                traumaAudioBassBoost.type = 'lowshelf';
                traumaAudioBassBoost.frequency.value = 200; // Bass frequencies
                traumaAudioBassBoost.gain.value = 0; // Start with no boost

                // Create midrange scoop to simulate pressure/earplug effect
                traumaAudioMidScoop = audioContext.createBiquadFilter();
                traumaAudioMidScoop.type = 'peaking';
                traumaAudioMidScoop.frequency.value = 1200; // Speech/clarity band
                traumaAudioMidScoop.Q.value = 0.9;
                traumaAudioMidScoop.gain.value = 0; // Will go negative when hurt

                // Compression makes the whole mix feel "flattened" and distant (more realistic)
                traumaAudioCompressor = audioContext.createDynamicsCompressor();
                traumaAudioCompressor.threshold.value = -34;
                traumaAudioCompressor.knee.value = 24;
                traumaAudioCompressor.ratio.value = 10;
                traumaAudioCompressor.attack.value = 0.002;
                traumaAudioCompressor.release.value = 0.22;
                
                // Create master gain for overall volume control
                traumaAudioMasterGain = audioContext.createGain();
                traumaAudioMasterGain.gain.value = 1.0;
                
                // Chain: lowpass -> bass boost -> mid scoop -> compressor -> master gain -> destination
                traumaAudioFilter.connect(traumaAudioBassBoost);
                traumaAudioBassBoost.connect(traumaAudioMidScoop);
                traumaAudioMidScoop.connect(traumaAudioCompressor);
                traumaAudioCompressor.connect(traumaAudioMasterGain);
                traumaAudioMasterGain.connect(audioContext.destination);
                
                // Create tinnitus (ringing) oscillator
                tinnitusOscillator = audioContext.createOscillator();
                tinnitusOscillator.type = 'sine';
                tinnitusOscillator.frequency.value = 4200; // High-pitched ring
                
                // Secondary oscillator for more realistic tinnitus
                const tinnitusOsc2 = audioContext.createOscillator();
                tinnitusOsc2.type = 'sine';
                tinnitusOsc2.frequency.value = 5800;
                
                // Tinnitus gain (starts at 0)
                tinnitusGain = audioContext.createGain();
                tinnitusGain.gain.value = 0;
                
                const tinnitusGain2 = audioContext.createGain();
                tinnitusGain2.gain.value = 0;
                
                // Connect oscillators
                tinnitusOscillator.connect(tinnitusGain);
                tinnitusOsc2.connect(tinnitusGain2);
                tinnitusGain.connect(audioContext.destination);
                tinnitusGain2.connect(audioContext.destination);
                
                // Start oscillators (they're silent until gain > 0)
                tinnitusOscillator.start();
                tinnitusOsc2.start();
                
                // Store secondary tinnitus for later
                window._tinnitusGain2 = tinnitusGain2;
                
                traumaAudioInitialized = true;
                console.log('🔊 Trauma audio system initialized');
            } catch (e) {
                console.warn('Failed to initialize trauma audio:', e);
            }
        }
        
        // Trigger trauma audio effect (call when player takes damage)
        function triggerTraumaAudio(intensity = 0.5) {
            if (!traumaAudioInitialized) {
                initTraumaAudio();
            }
            
            // Set target values based on intensity - increased for more dramatic effect
            traumaAudio.targetMuffle = Math.min(1, traumaAudio.targetMuffle + intensity * 1.15);
            traumaAudio.targetTinnitus = Math.min(1, traumaAudio.targetTinnitus + intensity * 0.85);
        }
        
        // Update trauma audio (call every frame)
        function updateTraumaAudio(deltaTime) {
            if (!traumaAudioInitialized || !audioContext) return;

            // PERSISTENT TRAUMA: Muffle stays as long as you are hurt
            // Instead of decaying, we pull the target from the global game state trauma (which tracks health)
            if (window.gameState) {
                 // Use a curve so it doesn't sound too muffled at high HP, but gets deep at low HP
                 // 80-100 HP = very little effect
                 // <50 HP = strong effect
                 traumaAudio.targetMuffle = Math.max(traumaAudio.targetMuffle, window.gameState.trauma);
            }

            // Smoothly interpolate toward targets
            traumaAudio.currentMuffle += (traumaAudio.targetMuffle - traumaAudio.currentMuffle) * 4.0 * deltaTime; // Slower transition for "bass" feel
            traumaAudio.currentTinnitus += (traumaAudio.targetTinnitus - traumaAudio.currentTinnitus) * 10.0 * deltaTime;
            
            // Sync target decay
            // If we have gameState, we let it dictate the target (it recovers when health recovers)
            // If no gameState/trauma, we use auto-decay as fallback
            if (window.gameState && window.gameState.trauma > 0.01) {
                // Hard sync to game trauma (health)
                // If health recovers, trauma drops, so muffle drops
                traumaAudio.targetMuffle = window.gameState.trauma; 
            } else {
                // Fallback decay (or when fully healed)
                traumaAudio.targetMuffle *= Math.pow(0.55, deltaTime);
            }
            
            traumaAudio.targetTinnitus *= Math.pow(0.40, deltaTime); // Tinnitus STILL fades fast (annoying if constant)
            
            // Clamp small values to 0
            if (traumaAudio.targetMuffle < 0.01) traumaAudio.targetMuffle = 0;
            if (traumaAudio.targetTinnitus < 0.01) traumaAudio.targetTinnitus = 0;
            
            // Shape curve so even moderate damage feels heavily "plugged"
            const shapedMuffle = Math.pow(clamp01(traumaAudio.currentMuffle), 0.55);
            const shapedTinnitus = Math.pow(clamp01(traumaAudio.currentTinnitus), 0.75);

            // Apply aggressive low-pass filter (heavy muffle like shockwave)
            // Frequency range: 20000 Hz (normal) -> ~90 Hz (EXTREMELY muffled)
            const filterFreq = 20000 - (shapedMuffle * (20000 - 90));
            if (traumaAudioFilter) {
                traumaAudioFilter.frequency.setTargetAtTime(Math.max(90, filterFreq), audioContext.currentTime, 0.035);
            }
            
            // Boost bass frequencies (shockwave rumble effect) up to 22dB
            if (traumaAudioBassBoost) {
                const bassBoost = shapedMuffle * 22; // Up to 22dB bass boost
                traumaAudioBassBoost.gain.setTargetAtTime(bassBoost, audioContext.currentTime, 0.035);
            }

            // Scoop mids (earplug / pressure). Deeper scoop = more "plugged" feeling.
            if (traumaAudioMidScoop) {
                const midScoopDb = -22 * shapedMuffle; // 0..-22dB
                traumaAudioMidScoop.gain.setTargetAtTime(midScoopDb, audioContext.currentTime, 0.035);
            }
            
            // Apply tinnitus volume - increased for more noticeable ringing
            const tinnitusVolume = shapedTinnitus * 0.32; // Max 32% volume
            if (tinnitusGain) {
                tinnitusGain.gain.setTargetAtTime(tinnitusVolume, audioContext.currentTime, 0.02);
            }
            if (window._tinnitusGain2) {
                window._tinnitusGain2.gain.setTargetAtTime(tinnitusVolume * 0.7, audioContext.currentTime, 0.02);
            }
            
            // More aggressive volume reduction when muffled (sounds feel very distant)
            if (traumaAudioMasterGain) {
                const masterVol = 1.0 - (shapedMuffle * 0.65); // Up to 65% volume reduction
                traumaAudioMasterGain.gain.setTargetAtTime(masterVol, audioContext.currentTime, 0.035);
            }
        }
        
        // Get the trauma audio output node (use this instead of audioContext.destination)
        function getTraumaAudioDestination() {
            if (traumaAudioInitialized && traumaAudioFilter) {
                return traumaAudioFilter;
            }
            return audioContext ? audioContext.destination : null;
        }
        // ========== END TRAUMA AUDIO SYSTEM ==========

        // Initialize audio context lazily (after user interaction to avoid autoplay issues AND WebRTC conflicts)
        function ensureAudioContext() {
            if (!audioContext) {
                audioContext = new AudioContext();
                console.log('AudioContext initialized');
                // Initialize trauma audio system when audio context is created
                initTraumaAudio();
            }
            if (audioContext.state === 'suspended') {
                audioContext.resume().catch(() => {});
            }
            return audioContext;
        }

        function resumeGlobalAudio() {
            try {
                const ctx = ensureAudioContext();
                if (ctx && ctx.state === 'suspended') ctx.resume().catch(() => {});
            } catch (e) {}

            try {
                if (window.AmbienceSystem && typeof window.AmbienceSystem.resume === 'function') {
                    window.AmbienceSystem.resume();
                }
            } catch (e) {}

            try {
                if (window.MusicPlayer && window.MusicPlayer.audioContext && window.MusicPlayer.audioContext.state === 'suspended') {
                    window.MusicPlayer.audioContext.resume().catch(() => {});
                }
            } catch (e) {}

            // Unlock footstep audio element on user gesture
            try {
                if (window._unlockFootstepAudio) window._unlockFootstepAudio();
            } catch (e) {}
        }
        window.resumeGlobalAudio = resumeGlobalAudio;

        // Utility function to play sounds
        function playSound(buffer, volume = 1, offset = 0) {
            if (!buffer) return null;

            const ctx = ensureAudioContext();
            if (!ctx) return null;

            const source = ctx.createBufferSource();
            source.buffer = buffer;

            const gainNode = ctx.createGain();
            gainNode.gain.value = volume;
            source.connect(gainNode);
            
            // Route through trauma audio system for muffle effect
            const destination = getTraumaAudioDestination() || ctx.destination;
            gainNode.connect(destination);

            source.start(0, offset);

            return { source, gainNode }; // Return both source and gainNode
        }

        function clamp01(v) {
            return Math.max(0, Math.min(1, v));
        }

        // Generate avatar from username (used in HUDs and kill feeds)
        function generateDefaultAvatar(name, isEnemy) {
            const canvas = document.createElement('canvas');
            const size = 64;
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            // Dark background with subtle color tint
            const baseColor = isEnemy ? [40, 32, 20] : [20, 28, 45];
            ctx.fillStyle = `rgb(${baseColor[0]}, ${baseColor[1]}, ${baseColor[2]})`;
            ctx.fillRect(0, 0, size, size);

            // Subtle noise/texture
            for (let i = 0; i < 80; i++) {
                const x = Math.random() * size;
                const y = Math.random() * size;
                ctx.fillStyle = `rgba(255,255,255,${Math.random() * 0.03})`;
                ctx.fillRect(x, y, 1, 1);
            }

            // Initial letter
            const accentColor = isEnemy ? '#fab95c' : '#5c7cfa';
            ctx.fillStyle = accentColor;
            ctx.font = `600 ${size * 0.45}px 'Segoe UI', Arial, sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const initial = (name || 'P').charAt(0).toUpperCase();
            ctx.fillText(initial, size / 2, size / 2 + 1);

            return canvas.toDataURL('image/png');
        }

        // Route HTMLAudioElement through trauma chain.
        // IMPORTANT: MediaElementAudioSourceNodes can only be created once per element; we cache per element.
        const _traumaMediaElementNodes = new WeakMap();

        function ensureMediaElementThroughTrauma(mediaEl) {
            if (!mediaEl) return null;

            // Ensure global audio context + trauma chain exist
            const ctx = ensureAudioContext();
            if (!ctx) return null;
            if (!traumaAudioInitialized) initTraumaAudio();

            if (_traumaMediaElementNodes.has(mediaEl)) {
                return _traumaMediaElementNodes.get(mediaEl);
            }

            try {
                const mediaSource = ctx.createMediaElementAudioSource(mediaEl);
                const gainNode = ctx.createGain();
                gainNode.gain.value = 1.0;

                mediaSource.connect(gainNode);
                const dest = getTraumaAudioDestination() || ctx.destination;
                gainNode.connect(dest);

                const state = { mediaSource, gainNode };
                _traumaMediaElementNodes.set(mediaEl, state);
                return state;
            } catch (e) {
                // Likely already connected elsewhere; fall back to unprocessed element audio
                _traumaMediaElementNodes.set(mediaEl, null);
                return null;
            }
        }

        // Safe SFX playback: use HTMLAudioElement pools for MP3 and route through trauma audio chain.
        function createMediaSoundPool(src, poolSize = 6) {
            const audios = [];
            const encodedSrc = encodeURI(src);
            for (let i = 0; i < poolSize; i++) {
                const a = new Audio();
                a.preload = 'auto';
                a.src = encodedSrc;
                a.volume = 1;
                try { a.load(); } catch (_) {}
                audios.push(a);
            }

            let nextIndex = 0;
            return {
                play(volume = 1, offset = 0) {
                    const a = audios[nextIndex];
                    nextIndex = (nextIndex + 1) % audios.length;

                    // Ensure this element is routed through WebAudio trauma chain
                    const routed = ensureMediaElementThroughTrauma(a);

                    try { a.pause(); } catch (_) {}
                    try { a.currentTime = offset; } catch (_) {}

                    if (routed && routed.gainNode) {
                        // Control loudness via WebAudio gain (keeps trauma filters working)
                        routed.gainNode.gain.value = clamp01(volume);
                        a.volume = 1;
                    } else {
                        // Fallback path (no trauma processing possible)
                        a.volume = clamp01(volume);
                    }

                    const p = a.play();
                    if (p && typeof p.catch === 'function') p.catch(() => {});
                }
            };
        }

        // Menu 3D Scene Setup - Modern Module Implementation
        // Create a module script for the menu scene
        const menuModuleScript = document.createElement('script');
        menuModuleScript.type = 'module';
        menuModuleScript.textContent = `
            import * as THREE from 'three';
            import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
            import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';

            // Initialize menu scene
            function initMenuScene() {
                // Helper: Create 3D Text Sprite with Level Ring
                function createNameSprite(text, level = 1, xpProgressOverride = null) {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = 512;
                    canvas.height = 128;
                    
                    // Use passed level parameter (for opponents) or fallback to local LevelSystem
                    // If level is explicitly passed and > 0, use it (for opponents)
                    // Otherwise use local player's level from LevelSystem
                    let displayLevel = level;
                    let xpProgress = 0;
                    
                    if (xpProgressOverride !== null) {
                        // XP progress was explicitly passed (for opponents)
                        xpProgress = xpProgressOverride;
                    } else if (window.LevelSystem && window.LevelSystem.data) {
                        // Use local player's XP progress
                        const currentXP = window.LevelSystem.data.currentXP || 0;
                        const xpNeeded = window.LevelSystem.getXPForLevel(displayLevel) || 100;
                        xpProgress = currentXP / xpNeeded;
                    }

                    // === LEVEL RING (Left side) ===
                    const ringRadius = 45;
                    const ringX = 60;
                    const ringY = 64;
                    
                    // Ring background
                    ctx.beginPath();
                    ctx.arc(ringX, ringY, ringRadius, 0, Math.PI * 2);
                    ctx.fillStyle = "rgba(0, 0, 0, 0.85)";
                    ctx.fill();
                    
                    // XP progress arc (black/white)
                    ctx.beginPath();
                    ctx.arc(ringX, ringY, ringRadius - 6, -Math.PI/2, -Math.PI/2 + (Math.PI * 2 * xpProgress), false);
                    ctx.strokeStyle = "#ffffff";
                    ctx.lineWidth = 10;
                    ctx.lineCap = "round";
                    ctx.stroke();
                    
                    // Ring outer border (black/white)
                    ctx.beginPath();
                    ctx.arc(ringX, ringY, ringRadius, 0, Math.PI * 2);
                    ctx.strokeStyle = "#ffffff";
                    ctx.lineWidth = 4;
                    ctx.stroke();
                    
                    // Level number (black/white)
                    ctx.font = "bold 40px Arial";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillStyle = "#ffffff";
                    ctx.shadowColor = "#000";
                    ctx.shadowBlur = 4;
                    ctx.fillText(displayLevel.toString(), ringX, ringY + 2);
                    ctx.shadowBlur = 0;

                    // === NAME (Right side, no box) ===
                    ctx.font = "bold 55px 'Courier New', monospace";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillStyle = "#ffffff";
                    ctx.shadowColor = "#000";
                    ctx.shadowBlur = 4;
                    ctx.fillText(text.toUpperCase(), 300, 64);

                    const texture = new THREE.CanvasTexture(canvas);
                    texture.needsUpdate = true;
                    const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
                    const sprite = new THREE.Sprite(material);
                    sprite.scale.set(1.6, 0.4, 1);
                    sprite.name = "playerNametag";
                    
                    return sprite;
                }

                const menuCanvas = document.getElementById('menuCanvas');
                
                // Create renderer
                const menuRenderer = new THREE.WebGLRenderer({ 
                    canvas: menuCanvas, 
                    antialias: true, 
                    alpha: false
                });
                menuRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                menuRenderer.setSize(window.innerWidth, window.innerHeight);
                menuRenderer.setClearColor(0x000000, 1);
                // Match the user's working snippet, across Three.js versions (encoding vs colorSpace)
                if ('outputColorSpace' in menuRenderer && THREE.SRGBColorSpace) {
                    menuRenderer.outputColorSpace = THREE.SRGBColorSpace;
                }
                if ('outputEncoding' in menuRenderer && THREE.sRGBEncoding) {
                    menuRenderer.outputEncoding = THREE.sRGBEncoding;
                }
                // Baked background should not be tone-mapped (working snippet renders with default NoToneMapping)
                if (THREE.NoToneMapping) {
                    menuRenderer.toneMapping = THREE.NoToneMapping;
                }
                menuRenderer.toneMappingExposure = 1.0;
                menuRenderer.shadowMap.enabled = true;
                menuRenderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // 1. INIT SCENE (Matching test scene style)
                const menuScene = new THREE.Scene();
                menuScene.background = new THREE.Color(0xa0a0a0); // Grey background like test
                // Fog helps blend the floor into the background
                menuScene.fog = new THREE.Fog(0xa0a0a0, 10, 50);

                const menuCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
                // Camera position: Side view like a character selection screen
                menuCamera.position.set(2.5, 1.5, 4);

                // 2. CONTROLS (Rotate the character) - Fixed constructor
                let controls = new OrbitControls(menuCamera, menuRenderer.domElement);
                controls.target.set(0, 1.0, 0); // Look at character's chest
                controls.enableDamping = true; // Smooth movement
                controls.autoRotate = false;    // DISABLED - Fixed position
                controls.enableZoom = false;   // Keep zoom fixed for menu consistency
                controls.enablePan = false;
                controls.update();

                // 3. LIGHTING (Matching test scene)
                // Hemisphere light (ambient soft light)
                const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.5);
                hemiLight.position.set(0, 20, 0);
                menuScene.add(hemiLight);

                // Directional light (sun-like shadow caster)
                const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
                dirLight.position.set(0, 20, 10);
                dirLight.castShadow = true;
                dirLight.shadow.camera.top = 10;
                dirLight.shadow.camera.bottom = -10;
                dirLight.shadow.camera.left = -10;
                dirLight.shadow.camera.right = 10;
                dirLight.shadow.bias = -0.0001;
                dirLight.shadow.mapSize.width = 1024;
                dirLight.shadow.mapSize.height = 1024;
                menuScene.add(dirLight);

                // 4. LOAD WINTER TREE BACKGROUND SCENE
                // Replace the default grid/floor with a 3D environment from GLB
                let backgroundScene = null;
                let backgroundCamera = null; // Will use camera from GLB if available

                // Menu background asset (requested: vr-liminal-room-baked)
                const MENU_BG_URL = 'vr-liminal-room-baked/source/Untitled1.glb';
                // Tuning for an indoor/room-style background
                const MENU_BG_TARGET_SPAN_XZ = 55;
                const MENU_BG_SCALE_MAX = 4.0;
                const MENU_BG_PUSHBACK = 12;
                const MENU_BG_DESIRED_MAX_Z = -1.5;
                const MENU_BG_FOG_NEAR = 30;
                const MENU_BG_FOG_FAR = 140;
                
                const ensureGLTFLoaderForBackground = () => {
                    return new Promise((resolve, reject) => {
                        if (typeof THREE.GLTFLoader !== 'undefined' || (window.THREE && window.THREE.GLTFLoader)) {
                            return resolve();
                        }
                        const script = document.createElement('script');
                        script.src = 'loaders/GLTFLoader.js';
                        script.onload = () => {
                            setTimeout(() => {
                                if (typeof THREE.GLTFLoader !== 'undefined' || (window.THREE && window.THREE.GLTFLoader)) {
                                    resolve();
                                } else {
                                    reject(new Error('GLTFLoader not available'));
                                }
                            }, 10);
                        };
                        script.onerror = reject;
                        document.head.appendChild(script);
                    });
                };
                
                // Load the winter tree pack as background
                ensureGLTFLoaderForBackground().then(() => {
                    const GLTFLoaderClass = (typeof THREE.GLTFLoader !== 'undefined') ? THREE.GLTFLoader : window.THREE.GLTFLoader;
                    const bgLoader = new GLTFLoaderClass();
                    
                    bgLoader.load(MENU_BG_URL, (gltf) => {
                        console.log('🟦 Menu background GLB loaded:', MENU_BG_URL);
                        backgroundScene = gltf.scene;

                        const hasGlbCamera = !!(gltf.cameras && gltf.cameras.length > 0);
                        
                        // Calculate bounding box to understand the model's size
                        const box = new THREE.Box3().setFromObject(backgroundScene);
                        const size = new THREE.Vector3();
                        const center = new THREE.Vector3();
                        box.getSize(size);
                        box.getCenter(center);
                        console.log('🌲 Tree pack size:', size.x.toFixed(1), size.y.toFixed(1), size.z.toFixed(1));
                        console.log('🌲 Tree pack center:', center.x.toFixed(1), center.y.toFixed(1), center.z.toFixed(1));
                        console.log('🌲 Tree pack bounds: min:', box.min.x.toFixed(1), box.min.y.toFixed(1), box.min.z.toFixed(1),
                                    'max:', box.max.x.toFixed(1), box.max.y.toFixed(1), box.max.z.toFixed(1));

                        // MENU BACKGROUND PLACEMENT STRATEGY
                        // If the GLB contains a camera, load scene AS-IS (scale 1, no position transforms).
                        // This preserves the exact Blender framing.
                        let scaleFactor = 1;
                        if (!hasGlbCamera) {
                            const targetSpanXZ = MENU_BG_TARGET_SPAN_XZ;
                            const spanXZ = Math.max(1, Math.max(size.x, size.z));
                            const rawScale = targetSpanXZ / spanXZ;
                            scaleFactor = Math.max(0.01, Math.min(MENU_BG_SCALE_MAX, rawScale));
                            backgroundScene.scale.setScalar(scaleFactor);

                            // Recalculate bounds after scaling
                            backgroundScene.updateMatrixWorld(true);
                            const scaledBox = new THREE.Box3().setFromObject(backgroundScene);
                            const scaledCenter = new THREE.Vector3();
                            scaledBox.getCenter(scaledCenter);

                            // Center X, put on ground, and push it behind the character
                            backgroundScene.position.set(
                                -scaledCenter.x,
                                -scaledBox.min.y,
                                -scaledCenter.z - MENU_BG_PUSHBACK
                            );

                            // Ensure the whole background is behind the origin
                            backgroundScene.updateMatrixWorld(true);
                            const worldBoxAfter = new THREE.Box3().setFromObject(backgroundScene);
                            const desiredMaxZ = MENU_BG_DESIRED_MAX_Z;
                            if (worldBoxAfter.max.z > desiredMaxZ) {
                                backgroundScene.position.z -= (worldBoxAfter.max.z - desiredMaxZ);
                                backgroundScene.updateMatrixWorld(true);
                            }

                            console.log('🟦 Background backdrop mode | scale:', scaleFactor.toFixed(4),
                                '| pos:', backgroundScene.position.x.toFixed(1), backgroundScene.position.y.toFixed(1), backgroundScene.position.z.toFixed(1));
                        } else {
                            // GLB has camera: keep authored transforms exactly as exported.
                            // IMPORTANT: Do NOT reset position/rotation/scale, or the camera + bake won't match Blender.
                            backgroundScene.updateMatrixWorld(true);
                            console.log('📷 GLB camera detected: keeping authored transforms (no overrides)');
                        }
                        
                        // CRITICAL FIX: The GLB uses TEXCOORD_2 for baked textures, but
                        // Three.js r128's GLTFLoader only supports TEXCOORD_0 and TEXCOORD_1!
                        // We must copy TEXCOORD_2 data to the 'uv' attribute for textures to work.
                        backgroundScene.traverse((child) => {
                            if (child.isMesh && child.geometry) {
                                const geom = child.geometry;
                                // Check if TEXCOORD_2 exists (it gets loaded as _TEXCOORD_2 or similar)
                                // GLTFLoader names custom attributes with underscore prefix
                                const attr2 = geom.getAttribute('uv3') || 
                                              geom.getAttribute('_TEXCOORD_2') ||
                                              geom.attributes['uv3'] ||
                                              geom.attributes['_TEXCOORD_2'];
                                
                                // Try all possible attribute names for TEXCOORD_2
                                let texcoord2 = null;
                                for (const key of Object.keys(geom.attributes)) {
                                    if (key.toLowerCase().includes('texcoord') && key.includes('2')) {
                                        texcoord2 = geom.attributes[key];
                                        console.log('🔧 Found TEXCOORD_2 as:', key);
                                        break;
                                    }
                                }
                                
                                if (texcoord2) {
                                    // Copy TEXCOORD_2 to uv (TEXCOORD_0) so the texture maps correctly
                                    geom.setAttribute('uv', texcoord2);
                                    console.log('🔧 Copied TEXCOORD_2 to uv for:', child.name);
                                }
                            }
                        });
                        
                        // NUCLEAR OPTION: Replace materials with MeshBasicMaterial
                        // This ignores all Three.js lights and displays the Blender bake EXACTLY.
                        // CRITICAL: The GLB uses TEXCOORD_2 (channel 2) for baked textures!
                        // We must preserve the UV channel when creating new materials.
                        backgroundScene.traverse((child) => {
                            if (child.isMesh) {
                                // 1. Get the texture from the loaded model
                                const bakedTexture = child.material.map;
                                
                                // 2. CRITICAL: Preserve the UV channel (texCoord) from the original material
                                // GLTFLoader sets texture.channel based on the glTF texCoord attribute
                                // The baked texture uses TEXCOORD_2, so channel should be 2
                                const uvChannel = bakedTexture ? (bakedTexture.channel !== undefined ? bakedTexture.channel : 0) : 0;
                                
                                // 3. Fix colors (Blender exports sRGB, Three.js needs to know that)
                                if (bakedTexture) {
                                    bakedTexture.colorSpace = THREE.SRGBColorSpace;
                                    bakedTexture.flipY = false;
                                    // Ensure the channel is preserved
                                    bakedTexture.channel = uvChannel;
                                }
                                
                                // 4. NUCLEAR OPTION: Replace the material with MeshBasicMaterial
                                // This ignores all Three.js lights and displays the Blender Bake exactly.
                                child.material = new THREE.MeshBasicMaterial({
                                    map: bakedTexture
                                });
                                
                                // 5. Re-apply the UV channel to the new material's map
                                // (MeshBasicMaterial may reset this)
                                if (child.material.map) {
                                    child.material.map.channel = uvChannel;
                                }
                            }
                        });
                        
                        // NOTE: No lights needed for the baked background!
                        // The background is effectively a 3D photograph.
                        // Only add lights for the Player Character (skeleton).
                        
                        // Add to menu scene
                        menuScene.add(backgroundScene);

                        // Use camera embedded in GLB if present (DIRECTLY, not copying properties)
                        if (gltf.cameras && gltf.cameras.length > 0) {
                            // Find preferred camera (one with "cam" in name, or first one)
                            const preferred = gltf.cameras.find((c) => /cam/i.test(c.name)) ?? gltf.cameras[0];
                            console.log('📷 Using GLB camera DIRECTLY:', preferred.name || '(unnamed)', preferred);
                            
                            // USE THE GLB CAMERA DIRECTLY - this is the key!
                            // Update aspect ratio to match canvas
                            if (preferred.isPerspectiveCamera) {
                                preferred.aspect = window.innerWidth / window.innerHeight;
                                preferred.updateProjectionMatrix();
                            }
                            
                            // Store the GLB camera as the active menu camera
                            window._menuGlbCamera = preferred;

                            // Recreate controls bound to the GLB camera (do NOT mutate controls.object)
                            // Preserve the authored view by targeting along the camera forward direction.
                            if (controls && controls.dispose) {
                                controls.dispose();
                            }
                            controls = new OrbitControls(preferred, menuRenderer.domElement);
                            controls.enableDamping = true;
                            controls.autoRotate = false;
                            controls.enableZoom = false;
                            controls.enablePan = false;

                            const dir = new THREE.Vector3();
                            preferred.getWorldDirection(dir);
                            controls.target.copy(preferred.position).add(dir.multiplyScalar(1));
                            controls.enabled = false; // keep the view exactly as authored
                            controls.update();

                            // For GLB camera mode: hide character for pure background mode
                            window._menuBgUsesGlbCamera = true;
                            window._menuBgHideCharacter = false; // Show character in the room
                            
                        } else {
                            // No GLB camera - use default menuCamera
                            window._menuGlbCamera = null;
                            menuCamera.position.set(2.6, 1.7, 6.5);
                            if (controls && controls.dispose) {
                                controls.dispose();
                            }
                            controls = new OrbitControls(menuCamera, menuRenderer.domElement);
                            controls.target.set(0, 1.1, 0);
                            controls.enableDamping = true;
                            controls.autoRotate = false;
                            controls.enableZoom = false;
                            controls.enablePan = false;
                            controls.enabled = true;
                            controls.update();
                        }

                        // For camera-authored GLBs, preserve exact Blender look (no fog, dark background)
                        if (hasGlbCamera) {
                            menuScene.background = new THREE.Color(0x000000);
                            menuScene.fog = null;
                        } else {
                            menuScene.background = new THREE.Color(0xD7E9FF);
                            menuScene.fog = new THREE.Fog(0xD7E9FF, MENU_BG_FOG_NEAR, MENU_BG_FOG_FAR);
                        }
                        
                    }, undefined, (error) => {
                        console.warn('🟦 Could not load menu background GLB, using default grid:', error);
                        // Fallback: add grid if GLB fails
                        const grid = new THREE.GridHelper(20, 20, 0x000000, 0x000000);
                        grid.material.opacity = 0.2;
                        grid.material.transparent = true;
                        menuScene.add(grid);
                    });
                }).catch((error) => {
                    console.warn('GLTFLoader not available for background:', error);
                    // Fallback: add grid
                    const grid = new THREE.GridHelper(20, 20, 0x000000, 0x000000);
                    grid.material.opacity = 0.2;
                    grid.material.transparent = true;
                    menuScene.add(grid);
                });

                // 5. LOAD FBX CHARACTER & TEXTURE
                let mixer = null;
                const clock = new THREE.Clock();
                const loadingLabel = document.getElementById('loadingStatus');

                const loader = new FBXLoader();
                const texLoader = new THREE.TextureLoader();
                
                // Store current menu character for skin switching
                let currentMenuCharacter = null;
                let currentHeadBone = null;
                let currentPlayerName = document.getElementById('usernameInput').value || 'PLAYER';
                let currentLoadedSkin = 'soldier'; // Track which skin is currently loaded

                // Function to load a character skin
                function loadMenuCharacterSkin(skinName) {
                    const skinConfig = window.SKIN_CONFIG ? window.SKIN_CONFIG[skinName] : null;
                    if (!skinConfig) {
                        console.warn('Skin config not found:', skinName);
                        return;
                    }

                    // Helper to load GLTFLoader dynamically if missing
                    const ensureGLTFLoader = () => {
                        return new Promise((resolve, reject) => {
                            if (typeof THREE.GLTFLoader !== 'undefined' || (window.THREE && window.THREE.GLTFLoader)) {
                                console.log('✅ GLTFLoader already available');
                                return resolve();
                            }
                            
                            console.log('📦 Loading GLTFLoader from local fallback...');
                            const script = document.createElement('script');
                            // Use absolute path relative to the HTML file location to be safe
                            script.src = 'loaders/GLTFLoader.js';
                            
                            script.onload = () => {
                                console.log('📦 Local loader script onload fired.');
                                // Give it a tiny tick to execute if needed (though onload corresponds to execution complete)
                                setTimeout(() => {
                                    if (typeof THREE.GLTFLoader !== 'undefined' || (window.THREE && window.THREE.GLTFLoader)) {
                                        console.log('✅ GLTFLoader class confirmed present.');
                                        resolve();
                                    } else {
                                        console.error('❌ GLTFLoader script finished but THREE.GLTFLoader is undefined.');
                                        console.log('DEBUG: THREE keys:', Object.keys(window.THREE).filter(k => k.indexOf('Loader') !== -1));
                                        reject(new Error('Local GLTFLoader script loaded but class missing. Check console.'));
                                    }
                                }, 10);
                            };
                            
                            script.onerror = (e) => {
                                console.error('❌ Failed to load local GLTFLoader script:', e);
                                reject(new Error('Network/Path error loading local GLTFLoader'));
                            };
                            
                            document.head.appendChild(script);
                        });
                    };
                    
                    // FIX: Determine which file to load for visuals
                    // If a specific model file is defined (Skeleton), use it. Otherwise use the default fbx.
                    const visualFile = skinConfig.modelFbx ? skinConfig.modelFbx : skinConfig.fbx;
                    
                    console.log('👤 Loading skin:', skinName, '| Visual file:', visualFile);
                    
                    // Store the skin name being loaded
                    currentLoadedSkin = skinName;
                    
                    // Remove existing character if any
                    if (currentMenuCharacter) {
                        menuScene.remove(currentMenuCharacter);
                        currentMenuCharacter = null;
                        mixer = null;
                    }
                    
                    // Remove any debug markers from previous skeleton loads
                    const oldMarker = menuScene.getObjectByName('debugSkeletonMarker');
                    if (oldMarker) menuScene.remove(oldMarker);
                    const oldBBox = menuScene.getObjectByName('debugSkeletonBBox');
                    if (oldBBox) menuScene.remove(oldBBox);

                    const isGlb = (skinConfig.format === 'glb' || visualFile.toLowerCase().endsWith('.glb') || visualFile.toLowerCase().endsWith('.gltf'));
                    
                    // FIX: Ensure loader exists, awaiting the promise if needed
                    const gltfLoaderAvailable = (typeof THREE.GLTFLoader !== 'undefined' || (window.THREE && window.THREE.GLTFLoader));
                    if (isGlb && !gltfLoaderAvailable) {
                        ensureGLTFLoader().then(() => {
                            loadMenuCharacterSkin(skinName); // Retry loading after script loads
                        }).catch(err => {
                            console.error('❌ Critical Error: Could not load GLTFLoader:', err);
                        });
                        return; // Stop execution here, wait for retry call
                    }
                    
                    const GLTFLoaderClass = (typeof THREE.GLTFLoader !== 'undefined') ? THREE.GLTFLoader : (window.THREE && window.THREE.GLTFLoader);
                    const activeLoader = isGlb ? new GLTFLoaderClass() : loader;

                    activeLoader.load(visualFile, function(loadedResource) {
                        // Handle GLB/GLTF structure vs FBX structure
                        let object = loadedResource;
                        if (isGlb) {
                            object = loadedResource.scene;
                            if (loadedResource.animations) {
                                object.animations = loadedResource.animations;
                            }
                        }

                        if (loadingLabel) loadingLabel.style.display = 'none';
                        console.log(isGlb ? '✅ Menu character GLB loaded:' : '✅ Menu character FBX loaded:', skinName);
                        
                        // Track menu model asset loading (only first time)
                        if (window.LoadingScreen && !window.menuModelLoaded) {
                            LoadingScreen.assetLoaded('menu_model');
                            window.menuModelLoaded = true;
                        }
                        
                        // 1. Load Textures - support single texture, multiple textures, or procedural materials
                        if (skinConfig.proceduralMaterials && skinConfig.meshMaterials) {
                            // Procedural materials - different colors/materials for each mesh part
                            console.log('🎨 Using procedural materials for', skinName);
                            
                            let meshIndex = 0;
                            object.traverse(function(child) {
                                if (child.isMesh) {
                                    child.castShadow = true;
                                    child.receiveShadow = true;
                                    
                                    // Get material config for this mesh index
                                    const matConfig = skinConfig.meshMaterials[meshIndex % skinConfig.meshMaterials.length];
                                    console.log('📦 Mesh:', child.name, '| Applying:', matConfig.name);
                                    
                                    // Create material with the specified properties
                                    const newMaterial = new THREE.MeshStandardMaterial({
                                        color: matConfig.color,
                                        roughness: matConfig.roughness !== undefined ? matConfig.roughness : 0.5,
                                        metalness: matConfig.metalness !== undefined ? matConfig.metalness : 0.1,
                                        side: THREE.DoubleSide
                                    });
                                    // Enable skinning for SkinnedMesh to fix shadow warnings
                                    if (child.isSkinnedMesh) newMaterial.skinning = true;
                                    
                                    child.material = newMaterial;
                                    console.log('  ✅ Material applied:', matConfig.name);
                                    meshIndex++;
                                }
                            });
                            
                            if (window.LoadingScreen && !window.menuTextureLoaded) {
                                LoadingScreen.assetLoaded('menu_texture');
                                window.menuTextureLoaded = true;
                            }
                        } else if (skinConfig.textures) {
                            // Multiple textures for different mesh parts
                            const bodyTex = texLoader.load(skinConfig.textures.body);
                            const handsTex = texLoader.load(skinConfig.textures.hands);
                            const helmetTex = texLoader.load(skinConfig.textures.helmet);
                            
                            // Set encoding for proper color display
                            [bodyTex, handsTex, helmetTex].forEach(tex => {
                                tex.encoding = THREE.sRGBEncoding;
                                tex.flipY = true;  // Try true for these textures
                                tex.wrapS = THREE.RepeatWrapping;
                                tex.wrapT = THREE.RepeatWrapping;
                            });
                            
                            console.log('✅ Loading textures for', skinName);
                            
                            // Assign textures: try helmet first (obj1), then body (obj2), then hands (obj3)
                            // Based on visual - the pyramid head is on top
                            let meshIndex = 0;
                            const textureArray = [helmetTex, bodyTex, handsTex]; // Reordered!
                            const textureNames = ['helmet', 'body', 'hands'];
                            
                            object.traverse(function(child) {
                                if (child.isMesh) {
                                    child.castShadow = true;
                                    child.receiveShadow = true;
                                    
                                    const texIndex = meshIndex % textureArray.length;
                                    const selectedTex = textureArray[texIndex];
                                    console.log('📦 Mesh:', child.name, '-> Texture:', textureNames[texIndex]);
                                    
                                    // Use MeshBasicMaterial (unlit) to match dance.fbx
                                    const newMaterial = new THREE.MeshBasicMaterial({
                                        map: selectedTex,
                                        side: THREE.DoubleSide
                                    });
                                    // Enable skinning for SkinnedMesh to fix shadow warnings
                                    if (child.isSkinnedMesh) newMaterial.skinning = true;
                                    
                                    child.material = newMaterial;
                                    meshIndex++;
                                }
                            });
                            
                            if (window.LoadingScreen && !window.menuTextureLoaded) {
                                LoadingScreen.assetLoaded('menu_texture');
                                window.menuTextureLoaded = true;
                            }
                        } else if (skinConfig.texture) {
                            // Single texture for all meshes
                            const texture = texLoader.load(skinConfig.texture, function() {
                                console.log('✅ Menu character texture loaded');
                                if (window.LoadingScreen && !window.menuTextureLoaded) {
                                    LoadingScreen.assetLoaded('menu_texture');
                                    window.menuTextureLoaded = true;
                                }
                            });
                            texture.encoding = THREE.sRGBEncoding;

                            object.traverse(function(child) {
                                if (child.isMesh) {
                                    child.castShadow = true;
                                    child.receiveShadow = true;
                                    // Use MeshBasicMaterial (unlit) for consistency with other skins
                                    const newMaterial = new THREE.MeshBasicMaterial({
                                        map: texture,
                                        side: THREE.DoubleSide
                                    });
                                    // Enable skinning for SkinnedMesh to fix shadow warnings
                                    if (child.isSkinnedMesh) newMaterial.skinning = true;
                                    child.material = newMaterial;
                                }
                            });
                        } else if (skinConfig.preserveMaterials) {
                            // Preserve original FBX materials (for models with embedded textures like skeleton)
                            console.log('🎨 Preserving original materials for', skinName);
                            
                            let meshCount = 0;
                            
                            object.traverse(function(child) {
                                if (child.isMesh) {
                                    meshCount++;
                                    child.castShadow = true;
                                    child.receiveShadow = true;
                                    child.visible = true;
                                    child.frustumCulled = false;
                                    
                                    console.log('💀 Mesh #' + meshCount + ':', child.name, 
                                        '| Vertices:', child.geometry?.attributes?.position?.count || 0,
                                        '| Material:', child.material?.type || 'none');
                                    
                                    // Keep original material but ensure it renders properly
                                    if (child.material) {
                                        child.material.side = THREE.DoubleSide;
                                        child.material.transparent = false;
                                        
                                        // FIX: Brighten materials for dark GLB models
                                        if (child.material.isMeshStandardMaterial || child.material.isMeshPhysicalMaterial) {
                                            child.material.emissive = new THREE.Color(0x111111); // Subtle self-illumination
                                            child.material.roughness = 0.7;
                                            child.material.metalness = 0.1; 
                                        }

                                        child.material.opacity = 1;
                                        child.material.visible = true;
                                        child.material.depthWrite = true;
                                        child.material.depthTest = true;
                                        // Enable skinning for SkinnedMesh to fix shadow warnings
                                        if (child.isSkinnedMesh) child.material.skinning = true;
                                        child.material.needsUpdate = true;
                                    } else {
                                        // No material - create a visible one
                                        const newMat = new THREE.MeshBasicMaterial({
                                            color: 0xcccccc,
                                            side: THREE.DoubleSide
                                        });
                                        if (child.isSkinnedMesh) newMat.skinning = true;
                                        child.material = newMat;
                                    }
                                }
                            });
                            
                            console.log('💀 Total meshes found:', meshCount);
                            
                            if (window.LoadingScreen && !window.menuTextureLoaded) {
                                LoadingScreen.assetLoaded('menu_texture');
                                window.menuTextureLoaded = true;
                            }
                        } else {
                            // No texture - use solid material color
                            const matColor = skinConfig.materialColor || 0x888888;
                            console.log('🎨 Using solid material color:', matColor.toString(16));
                            
                            object.traverse(function(child) {
                                if (child.isMesh) {
                                    child.castShadow = true;
                                    child.receiveShadow = true;
                                    
                                    // Create a nice looking solid material
                                    const newMaterial = new THREE.MeshStandardMaterial({
                                        color: matColor,
                                        roughness: 0.5,
                                        metalness: 0.1,
                                        side: THREE.DoubleSide
                                    });
                                    // Enable skinning for SkinnedMesh to fix shadow warnings
                                    if (child.isSkinnedMesh) newMaterial.skinning = true;
                                    
                                    child.material = newMaterial;
                                }
                            });
                            
                            if (window.LoadingScreen && !window.menuTextureLoaded) {
                                LoadingScreen.assetLoaded('menu_texture');
                                window.menuTextureLoaded = true;
                            }
                        }

                        // 2. Setup Scale
                        const modelScale = skinConfig.scale || 0.012; 
                        object.scale.set(modelScale, modelScale, modelScale);
                        object.position.set(0, 0, 0);
                        
                        // Skeleton faces same direction as other skins (no extra rotation needed)
                        // Note: Skeleton model is already oriented correctly

                        // 3. FIND THE HEAD BONE
                        let headBone = null;
                        object.traverse((child) => {
                            if (child.isBone && (child.name.includes('Head') || child.name.includes('head'))) {
                                headBone = child;
                            }
                        });
                        
                        currentHeadBone = headBone ? headBone : object;
                        currentMenuCharacter = object;
                        
                        // Debug bounding box for skeleton
                        if (skinName === 'skeleton') {
                            const bbox = new THREE.Box3().setFromObject(object);
                            const bboxSize = new THREE.Vector3();
                            bbox.getSize(bboxSize);
                            console.log('💀 Skeleton bounding box size:', bboxSize.x.toFixed(2), bboxSize.y.toFixed(2), bboxSize.z.toFixed(2));
                            console.log('💀 Skeleton scale:', object.scale.x, object.scale.y, object.scale.z);
                        }
                        
                        // Force visibility on all children
                        object.visible = true;
                        object.traverse((c) => {
                            c.visible = true;
                            if (c.isMesh) {
                                c.frustumCulled = false;
                            }
                        });

                        // 4. ATTACH NAMETAG
                        updateMenuNametag();

                        // 5. Start Animation - FIX: Handle separate animation files for skeleton
                        // Debug: Log all bone names in the model
                        if (skinName === 'skeleton') {
                            console.log('💀 SKELETON MODEL BONES:');
                            object.traverse((child) => {
                                if (child.isBone) {
                                    console.log('   🦴', child.name);
                                }
                            });
                        }
                        
                        // For skeleton, ALWAYS load from separate file - ignore embedded animations
                        if (skinName === 'skeleton' && skinConfig.modelFbx && skinConfig.fbx) {
                            console.log('💀 Skeleton (player): Loading animation from separate file:', skinConfig.fbx);
                            const animLoader = new FBXLoader();
                            animLoader.load(skinConfig.fbx, function(animObject) {
                                console.log('💀 Animation FBX loaded! Animations:', animObject.animations.length);
                                
                                if (animObject.animations && animObject.animations.length > 0) {
                                    // Create mixer on the LOADED MODEL (object), not the animation object
                                    mixer = new THREE.AnimationMixer(object);
                                    
                                    // Get the animation clip from the animation file
                                    let clip = animObject.animations[0];
                                    console.log('💀 Applying animation clip:', clip.name, 'duration:', clip.duration);
                                    
                                    // Sanitize - remove scale tracks that cause deformation
                                    clip = sanitizeAnimationClip(clip);
                                    
                                    // Try retargeting if needed
                                    clip = retargetAnimationClip(clip, object);
                                    
                                    const action = mixer.clipAction(clip);
                                    action.play();
                                    console.log('💀 Skeleton animation playing');
                                }
                            }, undefined, function(err) {
                                console.error('❌ Failed to load skeleton animation:', err);
                            });
                        } else if (object.animations && object.animations.length > 0) {
                            // For non-skeleton skins, use embedded animations if available
                            console.log('💀 Model has embedded animations:', object.animations.length);
                            object.animations.forEach((clip, i) => {
                                console.log('   - Clip', i, ':', clip.name, 'duration:', clip.duration);
                            });
                            // Use embedded animations from the model
                            mixer = new THREE.AnimationMixer(object);
                            
                            let clip = object.animations[0];
                            if (skinConfig.animationName) {
                                const namedClip = object.animations.find(a => a.name === skinConfig.animationName);
                                if (namedClip) clip = namedClip;
                            }
                            
                            const action = mixer.clipAction(clip);
                            action.play();
                            console.log('💀 Playing embedded animation:', clip.name);
                        } else if (skinConfig.modelFbx && skinConfig.fbx && skinConfig.fbx !== skinConfig.modelFbx) {
                            // Other skins with no embedded animations - load from separate file
                            console.log('💀 No embedded animations, loading from:', skinConfig.fbx);
                            const animLoader = new FBXLoader();
                            animLoader.load(skinConfig.fbx, function(animObject) {
                                console.log('💀 Animation FBX loaded! Animations:', animObject.animations.length);
                                
                                if (animObject.animations && animObject.animations.length > 0) {
                                    mixer = new THREE.AnimationMixer(object);
                                    let clip = animObject.animations[0];
                                    clip = retargetAnimationClip(clip, object);
                                    const action = mixer.clipAction(clip);
                                    action.play();
                                    console.log('💀 Animation playing');
                                }
                            }, undefined, function(err) {
                                console.error('❌ Failed to load animation:', err);
                            });
                        }

                        // If GLB camera mode wants to hide the character, don't add it
                        if (window._menuBgHideCharacter) {
                            console.log('🎬 GLB camera mode: character hidden (pure background view)');
                            // Don't add to scene - the room IS the menu background
                            return;
                        }

                        // If a background stage was computed (GLB camera mode), place the character there
                        if (window._menuBgStagePosition) {
                            object.position.copy(window._menuBgStagePosition);
                            object.userData._menuBgStageApplied = true;
                        }

                        menuScene.add(object);
                        console.log('✅ Skin loaded and added to scene:', skinName);

                    }, undefined, function(err) { 
                        console.error('❌ Failed to load skin:', skinName, err);
                    });
                }
                
                // Update nametag function
                function updateMenuNametag() {
                    if (!currentHeadBone) return;
                    
                    // Remove old tag
                    const oldTag = currentHeadBone.getObjectByName("playerNametag");
                    if (oldTag) currentHeadBone.remove(oldTag);
                    
                    const usernameInput = document.getElementById('usernameInput');
                    const finalName = (usernameInput && usernameInput.value && usernameInput.value.trim()) ? usernameInput.value : "PLAYER";
                    currentPlayerName = finalName;
                    
                    // Get player level
                    const playerLevel = window.LevelSystem ? window.LevelSystem.data.level : 1;
                    const sprite = createNameSprite(finalName, playerLevel);

                    // Get skin-specific nametag settings using the actually loaded skin
                    const skinConfig = window.SKIN_CONFIG ? window.SKIN_CONFIG[currentLoadedSkin] : null;
                    
                    console.log('📍 Nametag for skin:', currentLoadedSkin, skinConfig);
                    
                    if (skinConfig && skinConfig.nametagScale && skinConfig.nametagPos) {
                        sprite.scale.set(skinConfig.nametagScale.x, skinConfig.nametagScale.y, skinConfig.nametagScale.z);
                        sprite.position.set(skinConfig.nametagPos.x, skinConfig.nametagPos.y, skinConfig.nametagPos.z);
                    } else {
                        // Default fallback for soldier
                        sprite.scale.set(65, 16, 1); 
                        sprite.position.set(0, 15, 0);
                    }

                    currentHeadBone.add(sprite);
                    
                    // Register sprite for hover detection
                    if (window.setPlayerNametagSprite) {
                        window.setPlayerNametagSprite(sprite);
                    }
                    
                    // Update 3D squad list if it exists
                    if (window.updateLobbySquadList) {
                        window.updateLobbySquadList();
                    }
                    
                    // Send name update to other player if connected
                    // Debug: log all conditions
                    console.log('📋 Name sync check:', {
                        sendToOther: !!window.sendToOther,
                        isMultiplayer: window.isMultiplayer,
                        LevelSystem: !!window.LevelSystem,
                        finalName: finalName
                    });
                    
                    if (window.sendToOther && window.isMultiplayer) {
                        const level = window.LevelSystem ? window.LevelSystem.data.level : 1;
                        const xpNeeded = window.LevelSystem ? (window.LevelSystem.getXPForLevel(level) || 100) : 100;
                        const currentXP = window.LevelSystem ? window.LevelSystem.data.currentXP : 0;
                        const myAvatar = window.ProfilePicture ? window.ProfilePicture.get() : null;
                        
                        console.log('📤 Sending lobbyNameUpdate:', finalName);
                        window.sendToOther({ 
                            type: 'lobbyNameUpdate', 
                            username: finalName,
                            level: level,
                            xpProgress: currentXP / xpNeeded,
                            avatar: myAvatar,
                            skin: window.selectedSkin || 'soldier'
                        });
                    } else {
                        console.log('📋 Not sending name update - not in multiplayer lobby');
                    }
                }
                
                // Expose functions globally
                window.updateMenuNametag = updateMenuNametag;
                window.updateMenuCharacterSkin = loadMenuCharacterSkin;
                
                // Emote animation system for menu character
                let isPlayingEmote = false;
                let emoteCharacter = null;
                let emoteMixerRef = null;
                let savedIdleCharacter = null;
                let savedIdleMixer = null;
                
                function playMenuEmote(emoteFbxPath) {
                    if (!currentMenuCharacter) {
                        console.log('❌ No menu character to emote');
                        return;
                    }
                    
                    if (isPlayingEmote) {
                        console.log('⚠️ Already playing emote');
                        return;
                    }
                    
                    console.log('💃 Loading emote model:', emoteFbxPath);
                    isPlayingEmote = true;
                    
                    // Save reference to current idle character
                    savedIdleCharacter = currentMenuCharacter;
                    savedIdleMixer = mixer;
                    
                    // Get the SKIN CONFIG scale for the current skin (not hardcoded!)
                    const currentSkinName = window.selectedSkin || 'briefcase';
                    const skinConfig = window.SKIN_CONFIG?.[currentSkinName];
                    const modelScale = skinConfig ? skinConfig.scale : 1.09;
                    
                    // Get current position and rotation from the idle character
                    // PERF: Use reusable vectors instead of clone() for menu scene (not in hot path but good practice)
                    const currentPos = _reusableVec3A ? _reusableVec3A.copy(currentMenuCharacter.position) : currentMenuCharacter.position.clone();
                    const currentRot = currentMenuCharacter.rotation.clone(); // Euler clone is cheap
                    
                    console.log('💃 Idle character pos:', currentPos, 'rot:', currentRot, 'scale:', modelScale);
                    
                    // REMOVE idle character from scene (not just hide - visibility doesn't always work)
                    menuScene.remove(currentMenuCharacter);
                    console.log('💃 Removed idle character from scene');
                    
                    // Load the emote FBX
                    const emoteLoader = new FBXLoader();
                    emoteLoader.load(emoteFbxPath, function(emoteObject) {
                        console.log('✅ Emote FBX loaded');

                        // Convert all materials to MeshBasicMaterial to REMOVE lighting effects
                        emoteObject.traverse(function(child) {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                                
                                // Get the existing texture from the embedded material
                                const oldMat = child.material;
                                let texture = null;
                                
                                if (oldMat && oldMat.map) {
                                    texture = oldMat.map;
                                }
                                
                                // Create unlit material (no lighting response)
                                const newMat = new THREE.MeshBasicMaterial({
                                    map: texture,
                                    side: THREE.DoubleSide
                                });
                                if (child.isSkinnedMesh) newMat.skinning = true;
                                child.material = newMat;
                                
                                console.log('💃 Mesh:', child.name, '- converted to MeshBasicMaterial (unlit)');
                            }
                        });
                        
                        // Set scale - emote model is much larger, so use a smaller scale
                        const emoteScale = modelScale * 0.01; // Reduce to 1% of normal
                        emoteObject.scale.set(emoteScale, emoteScale, emoteScale);
                        
                        // FORCE position to (0,0,0) - same as idle character
                        emoteObject.position.set(0, 0, 0);
                        emoteObject.rotation.set(0, 0, 0);
                        
                        emoteObject.name = 'emoteCharacter';
                        
                        // Start animation - but REMOVE ROOT MOTION
                        if (emoteObject.animations && emoteObject.animations.length > 0) {
                            emoteMixerRef = new THREE.AnimationMixer(emoteObject);
                            
                            // Get the animation clip
                            const clip = emoteObject.animations[0];
                            
                            // Remove position tracks from animation to prevent movement
                            const tracksToKeep = clip.tracks.filter(track => {
                                const trackName = track.name.toLowerCase();
                                // Remove root position/translation tracks that cause movement
                                if (trackName.includes('position') && (trackName.includes('root') || trackName.includes('hips') || trackName.startsWith('.'))) {
                                    console.log('💃 Removing root motion track:', track.name);
                                    return false;
                                }
                                return true;
                            });
                            
                            // Create new clip without root motion
                            const cleanClip = new THREE.AnimationClip(clip.name, clip.duration, tracksToKeep);
                            
                            const action = emoteMixerRef.clipAction(cleanClip);
                            action.setLoop(THREE.LoopRepeat);
                            action.play();
                            console.log('💃 Emote animation playing (root motion removed)');
                        }
                        
                        emoteCharacter = emoteObject;
                        menuScene.add(emoteObject);
                        
                        console.log('💃 Emote character added at pos:', emoteObject.position);
                        
                        // === FIND HEAD BONE FOR NAMETAG TRACKING ===
                        let emoteHeadBone = null;
                        emoteObject.traverse(function(child) {
                            if (child.isBone) {
                                const boneName = child.name;
                                // Look for exact "mixamorigHead" bone (not HeadTop_End)
                                if (boneName === 'mixamorigHead' || boneName === 'Head' || boneName === 'head') {
                                    emoteHeadBone = child;
                                    console.log('🦴 ✅ Found HEAD bone:', child.name);
                                }
                            }
                        });
                        
                        // Store head bone reference globally for animation loop
                        window.emoteHeadBone = emoteHeadBone;
                        console.log('🦴 Final emoteHeadBone:', emoteHeadBone ? emoteHeadBone.name : 'NULL');
                        
                        // === CREATE NAMETAG IN SCENE (will track head bone position) ===
                        const usernameInput = document.getElementById('usernameInput');
                        const finalName = (usernameInput && usernameInput.value && usernameInput.value.trim()) ? usernameInput.value : "PLAYER";
                        const playerLevel = window.LevelSystem ? window.LevelSystem.data.level : 1;
                        
                        console.log('🏷️ Creating emote nametag for:', finalName, 'Level:', playerLevel);
                        
                        const emoteNametagSprite = createNameSprite(finalName, playerLevel);
                        emoteNametagSprite.name = 'emoteNametag';
                        
                        // Scale for scene-level (same as idle nametag)
                        emoteNametagSprite.scale.set(0.7, 0.17, 1);
                        
                        // Initial position (will be updated every frame to follow head)
                        emoteNametagSprite.position.set(0, 2.2, 0);
                        
                        // Add to scene
                        menuScene.add(emoteNametagSprite);
                        
                        // Store reference for hover detection and cleanup
                        window.emoteNametagSprite = emoteNametagSprite;
                        
                        // Register for hover detection (same as idle nametag)
                        if (window.setPlayerNametagSprite) {
                            window.setPlayerNametagSprite(emoteNametagSprite);
                        }
                        
                        console.log('🏷️ Emote nametag added, head bone:', emoteHeadBone ? emoteHeadBone.name : 'NOT FOUND');
                        // === END NAMETAG ===
                        
                        // ============================================
                        // 🔴🔴🔴 MEGA DEBUG - DUMP ENTIRE SCENE 🔴🔴🔴
                        // ============================================
                        console.log('🔴🔴🔴 ========== MEGA SCENE DEBUG ========== 🔴🔴🔴');
                        console.log('🔴 Total children in menuScene:', menuScene.children.length);
                        
                        menuScene.children.forEach(function(obj, index) {
                            console.log('🔴 [' + index + '] Type:', obj.type, '| Name:', obj.name || 'unnamed', '| Visible:', obj.visible);
                            
                            if (obj.isMesh) {
                                const mat = obj.material;
                                console.log('    🟡 MESH - Material:', mat ? mat.type : 'none', '| Color:', mat && mat.color ? mat.color.getHexString() : 'N/A');
                                if (obj.geometry && obj.geometry.boundingBox) {
                                    obj.geometry.computeBoundingBox();
                                    const b = obj.geometry.boundingBox;
                                    console.log('    🟡 Size:', (b.max.x-b.min.x).toFixed(1), 'x', (b.max.y-b.min.y).toFixed(1), 'x', (b.max.z-b.min.z).toFixed(1));
                                }
                            }
                            
                            // Check children of this object
                            if (obj.children && obj.children.length > 0) {
                                console.log('    🟢 Has', obj.children.length, 'children');
                                obj.traverse(function(child) {
                                    if (child.isMesh && child !== obj) {
                                        console.log('      🔵 Child Mesh:', child.name || 'unnamed', '| Visible:', child.visible);
                                        if (child.geometry) {
                                            child.geometry.computeBoundingBox();
                                            const b = child.geometry.boundingBox;
                                            if (b) {
                                                const h = b.max.y - b.min.y;
                                                const w = b.max.x - b.min.x;
                                                const d = b.max.z - b.min.z;
                                                console.log('        Size:', w.toFixed(2), 'x', h.toFixed(2), 'x', d.toFixed(2));
                                                // Flag potential ground meshes
                                                if (h < 0.5 && (w > 0.5 || d > 0.5)) {
                                                    console.log('        ⚠️⚠️⚠️ POTENTIAL GROUND MESH! ⚠️⚠️⚠️');
                                                }
                                            }
                                        }
                                    }
                                });
                            }
                        });
                        console.log('🔴🔴🔴 ======== END MEGA DEBUG ======== 🔴🔴🔴');
                        // ============================================
                        
                        }, undefined, function(err) {
                            console.error('❌ Failed to load emote FBX:', err);
                            isPlayingEmote = false;
                            if (savedIdleCharacter) {
                                menuScene.add(savedIdleCharacter);
                                savedIdleCharacter.visible = true;
                            }
                        });
                }
                
                function stopMenuEmote() {
                    if (!isPlayingEmote) return;
                    
                    console.log('💃 Stopping emote animation');
                    isPlayingEmote = false;
                    
                    // Remove emote character
                    if (emoteCharacter) {
                        menuScene.remove(emoteCharacter);
                        emoteCharacter = null;
                        emoteMixerRef = null;
                    }
                    
                    // Remove emote nametag from scene and clear head bone reference
                    if (window.emoteNametagSprite) {
                        menuScene.remove(window.emoteNametagSprite);
                        window.emoteNametagSprite = null;
                        window.emoteHeadBone = null;
                        console.log('🏷️ Emote nametag removed');
                    }
                    
                    // Re-register idle nametag for hover detection
                    if (currentHeadBone) {
                        const idleNametag = currentHeadBone.getObjectByName("playerNametag");
                        if (idleNametag && window.setPlayerNametagSprite) {
                            window.setPlayerNametagSprite(idleNametag);
                        }
                    }
                    
                    // Add idle character back to scene
                    if (savedIdleCharacter) {
                        menuScene.add(savedIdleCharacter);
                        savedIdleCharacter.visible = true;
                    }
                }
                
                // Update animation loop to handle emote mixer AND nametag tracking
                window.updateEmoteMixer = (delta) => {
                    if (emoteMixerRef) {
                        emoteMixerRef.update(delta);
                    }
                    
                    // Update emote nametag position to follow head bone
                    if (window.emoteNametagSprite && window.emoteHeadBone) {
                        const headWorldPos = new THREE.Vector3();
                        window.emoteHeadBone.getWorldPosition(headWorldPos);
                        
                        // Position nametag above head (add offset for visibility)
                        window.emoteNametagSprite.position.set(
                            headWorldPos.x,
                            headWorldPos.y + 0.35, // Offset above head
                            headWorldPos.z
                        );
                    }
                };
                
                window.playMenuEmote = playMenuEmote;
                window.stopMenuEmote = stopMenuEmote;
                
                // Listen for username input - CRITICAL: sync to gameState and notify opponents
                const usernameInput = document.getElementById('usernameInput');
                if (usernameInput) {
                    usernameInput.addEventListener('input', (e) => {
                        const newName = e.target.value.trim() || 'Player';
                        
                        // Update gameState so multiplayer messages use correct name
                        if (window.gameState) {
                            window.gameState.playerUsername = newName;
                            console.log('📋 gameState.playerUsername updated to:', newName);
                        }
                        
                        // Update menu nametag
                        updateMenuNametag();
                    });
                }
                
                // Load initial skin
                const initialSkin = window.selectedSkin || 'soldier';
                loadMenuCharacterSkin(initialSkin);

                // 6. ANIMATION LOOP
                let opponentMixer = null;
                
                // Setup level ring hover tooltip
                const levelHoverArea = document.getElementById('levelHoverArea');
                const levelTooltip = document.getElementById('levelTooltip');
                let playerNametagSprite = null;
                
                // Store reference to player's nametag for hover positioning
                window.setPlayerNametagSprite = (sprite) => {
                    playerNametagSprite = sprite;
                    levelHoverArea.style.display = 'block';
                };
                
                // Hover area event handlers
                levelHoverArea.addEventListener('mouseenter', () => {
                    // Update tooltip content from LevelSystem
                    if (window.LevelSystem && window.LevelSystem.data) {
                        const ls = window.LevelSystem;
                        const level = ls.data.level;
                        const currentXP = ls.data.currentXP;
                        const xpNeeded = ls.getXPForLevel(level);
                        const xpToNext = xpNeeded - currentXP;
                        const progress = (currentXP / xpNeeded) * 100;
                        
                        document.getElementById('tooltipCurrentLevel').textContent = level;
                        document.getElementById('tooltipXpProgress').textContent = currentXP + ' / ' + xpNeeded;
                        document.getElementById('tooltipXpNeeded').textContent = xpToNext + ' XP';
                        document.getElementById('tooltipProgressBar').style.width = progress + '%';
                        document.getElementById('tooltipKills').textContent = ls.data.totalKills || 0;
                        document.getElementById('tooltipWins').textContent = ls.data.totalWins || 0;
                    }
                    levelTooltip.classList.add('visible');
                });
                
                levelHoverArea.addEventListener('mouseleave', () => {
                    levelTooltip.classList.remove('visible');
                });
                
                levelHoverArea.addEventListener('mousemove', (event) => {
                    levelTooltip.style.left = (event.clientX + 20) + 'px';
                    levelTooltip.style.top = (event.clientY - 10) + 'px';
                });
                
                function animateMenu() {
                    requestAnimationFrame(animateMenu);

                    const currentTime = performance.now();
                    updateTelemetrySystem(currentTime, menuRenderer, menuCamera);

                    const delta = clock.getDelta();

                    // If the background GLB camera is used, snap the character onto the computed stage position
                    if (window._menuBgStagePosition && currentMenuCharacter && !currentMenuCharacter.userData._menuBgStageApplied) {
                        currentMenuCharacter.position.copy(window._menuBgStagePosition);
                        currentMenuCharacter.userData._menuBgStageApplied = true;
                    }
                    
                    // Update character animation
                    if (mixer) mixer.update(delta);
                    
                    // Update emote animation if playing
                    if (window.updateEmoteMixer) {
                        window.updateEmoteMixer(delta);
                    }
                    
                    // Update opponent emote animation if playing
                    if (window.updateOpponentEmoteMixer) {
                        window.updateOpponentEmoteMixer(delta);
                    }
                    
                    // Update opponent animation (1v1 mode)
                    if (opponentMixer) opponentMixer.update(delta);
                    
                    // Update all opponent animations (2v2 mode)
                    menuScene.traverse((obj) => {
                        if (obj.userData && obj.userData.mixer) {
                            obj.userData.mixer.update(delta);
                        }
                    });
                    
                    // Update level hover area position based on sprite's screen position
                    if (playerNametagSprite && playerNametagSprite.parent) {
                        // Get the sprite's world position
                        const spriteWorldPos = new THREE.Vector3();
                        playerNametagSprite.getWorldPosition(spriteWorldPos);
                        
                        // Get world rotation for 3D tilt effect
                        const spriteWorldQuat = new THREE.Quaternion();
                        playerNametagSprite.getWorldQuaternion(spriteWorldQuat);
                        const spriteEuler = new THREE.Euler().setFromQuaternion(spriteWorldQuat);
                        
                        // Project center of sprite to screen
                        const centerPos = spriteWorldPos.clone();
                        centerPos.project(menuCamera);
                        
                        const centerScreenX = (centerPos.x * 0.5 + 0.5) * window.innerWidth;
                        const centerScreenY = (-centerPos.y * 0.5 + 0.5) * window.innerHeight;
                        
                        // Calculate sprite width on screen
                        const spriteWorldWidth = 65 * 0.012;
                        const distToCamera = spriteWorldPos.distanceTo(menuCamera.position);
                        const fovRad = menuCamera.fov * Math.PI / 180;
                        const screenHeightAtDist = 2 * distToCamera * Math.tan(fovRad / 2);
                        const pixelsPerUnit = window.innerHeight / screenHeightAtDist;
                        const spriteScreenWidth = spriteWorldWidth * pixelsPerUnit;
                        
                        // Level ring position
                        const ringOffsetRatio = 60 / 512;
                        const ringScreenOffset = spriteScreenWidth * (0.5 - ringOffsetRatio);
                        
                        // Position hover area over the level ring
                        const hoverSize = Math.max(40, spriteScreenWidth * 0.2);
                        levelHoverArea.style.width = hoverSize + 'px';
                        levelHoverArea.style.height = hoverSize + 'px';
                        levelHoverArea.style.left = (centerScreenX - ringScreenOffset - hoverSize/2) + 'px';
                        levelHoverArea.style.top = (centerScreenY - hoverSize/2) + 'px';
                    }

                    controls.update();
                    // Use GLB camera directly if available, otherwise use menuCamera
                    const activeMenuCamera = window._menuGlbCamera || menuCamera;
                    menuRenderer.render(menuScene, activeMenuCamera);
                }
                animateMenu();

                // Handle resize
                window.addEventListener('resize', () => {
                    const activeMenuCamera = window._menuGlbCamera || menuCamera;
                    if (activeMenuCamera && activeMenuCamera.isPerspectiveCamera) {
                        activeMenuCamera.aspect = window.innerWidth / window.innerHeight;
                        activeMenuCamera.updateProjectionMatrix();
                    }
                    menuRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                    menuRenderer.setSize(window.innerWidth, window.innerHeight);
                });
                
                // Function to add opponent character to menu scene (supports multiple for 2v2)
                let menuCharacterCount = 0; // Track how many characters added
                const menuCharacterPositions = [
                    { x: 2, y: 0, z: 0 },      // 1st opponent (right)
                    { x: -2, y: 0, z: 0 },     // 2nd opponent (left)
                    { x: 3.5, y: 0, z: -1 }    // 3rd opponent (far right back)
                ];
                
                function addOpponent(opponentUsername, playerIdOrLevel, levelOrSkin, skinArg) {
                    // Handle both old calls (username, playerId) and new calls (username, level, skin)
                    // If playerIdOrLevel is a number, it's the level. If it's a string, it's playerId
                    let playerId = null;
                    let level = 1;
                    let skin = 'soldier';
                    
                    if (typeof playerIdOrLevel === 'number') {
                        level = playerIdOrLevel;
                        skin = levelOrSkin || 'soldier';
                    } else if (typeof playerIdOrLevel === 'string') {
                        playerId = playerIdOrLevel;
                        level = levelOrSkin || 1;
                        skin = skinArg || 'soldier';
                    }
                    
                    // If skin wasn't passed, check if we have it stored in gameState
                    if (skin === 'soldier' && window.gameState && window.gameState.otherPlayerSkin) {
                        skin = window.gameState.otherPlayerSkin;
                        console.log('📦 Using stored opponent skin:', skin);
                    }
                    
                    console.log('🎮 Adding opponent to menu scene:', opponentUsername, 'ID:', playerId, 'Level:', level, 'Skin:', skin);
                    
                    // For 2v2, allow up to 3 opponents
                    const gameMode = window.gameMode || '1v1';
                    
                    if (gameMode === '1v1') {
                        // Check if opponent already exists for 1v1
                        const existingOpponent = menuScene.getObjectByName('opponentCharacter');
                        if (existingOpponent) {
                            console.log('⚠️ Opponent already in menu scene (1v1)');
                            
                            // Check if skin changed - if so, need to reload
                            if (existingOpponent.userData.skin !== skin) {
                                console.log('👔 Skin changed, reloading opponent');
                                menuScene.remove(existingOpponent);
                                menuCharacterCount = Math.max(0, menuCharacterCount - 1);
                                // Continue to load new opponent below
                            } else {
                                // Same skin - just update the nametag if needed
                                console.log('🏷️ Updating existing opponent nametag');
                                if (window.gameState) {
                                    window.gameState.otherPlayerUsername = opponentUsername;
                                    window.gameState.otherPlayerLevel = level;
                                }
                                // Try to update nametag
                                if (window.updateOpponentNametagInLobby) {
                                    window.updateOpponentNametagInLobby(opponentUsername, level);
                                }
                                return;
                            }
                        }
                    } else {
                        // 2v2 mode - check if this specific player already added
                        if (playerId) {
                            const existingPlayer = menuScene.getObjectByName('opponent_' + playerId);
                            if (existingPlayer) {
                                console.log('⚠️ Player already in menu scene:', playerId);
                                return;
                            }
                        }
                        
                        // Max 3 opponents in 2v2
                        if (menuCharacterCount >= 3) {
                            console.log('⚠️ Max opponents reached (3)');
                            return;
                        }
                    }
                    
                    // Get position for this character
                    const pos = menuCharacterPositions[menuCharacterCount] || { x: 2, y: 0, z: 0 };
                    
                    // Get skin configuration
                    const skinConfig = window.SKIN_CONFIG ? window.SKIN_CONFIG[skin] : null;
                    // Use modelFbx if available (for skeleton), otherwise use fbx
                    const fbxPath = skinConfig ? (skinConfig.modelFbx || skinConfig.fbx) : './RifleIdle.fbx';
                    const modelScale = skinConfig ? skinConfig.scale : 0.012;
                    
                    console.log('📦 Loading opponent with skin:', skin, 'FBX:', fbxPath);
                    
                    // Load opponent character at offset position
                    loader.load(fbxPath, function(opponentObject) {
                        // Handle preserveMaterials for skeleton
                        if (skinConfig && skinConfig.preserveMaterials) {
                            console.log('🎨 Preserving original materials for opponent:', skin);
                            opponentObject.traverse(function(child) {
                                if (child.isMesh) {
                                    child.castShadow = true;
                                    child.receiveShadow = true;
                                    child.frustumCulled = false;
                                    if (child.material) {
                                        child.material.side = THREE.DoubleSide;
                                        if (child.isSkinnedMesh) child.material.skinning = true;
                                        child.material.needsUpdate = true;
                                    }
                                }
                            });
                        } else if (skinConfig && skinConfig.proceduralMaterials && skinConfig.meshMaterials) {
                            // Procedural materials
                            console.log('🎨 Loading procedural materials for opponent:', skin);
                            let meshIndex = 0;
                            opponentObject.traverse(function(child) {
                                if (child.isMesh) {
                                    child.castShadow = true;
                                    child.receiveShadow = true;
                                    const matConfig = skinConfig.meshMaterials[meshIndex % skinConfig.meshMaterials.length];
                                    const newMaterial = new THREE.MeshStandardMaterial({
                                        color: matConfig.color,
                                        roughness: matConfig.roughness !== undefined ? matConfig.roughness : 0.5,
                                        metalness: matConfig.metalness !== undefined ? matConfig.metalness : 0.1,
                                        side: THREE.DoubleSide
                                    });
                                    if (child.isSkinnedMesh) newMaterial.skinning = true;
                                    child.material = newMaterial;
                                    meshIndex++;
                                }
                            });
                        } else if (skinConfig && skinConfig.textures) {
                            // Multiple textures (briefcase/Pyramid Head skin)
                            console.log('🎨 Loading multiple textures for opponent:', skin);
                            console.log('  Body:', skinConfig.textures.body);
                            console.log('  Hands:', skinConfig.textures.hands);
                            console.log('  Helmet:', skinConfig.textures.helmet);
                            
                            const bodyTex = texLoader.load(skinConfig.textures.body, () => console.log('✅ Body texture loaded'));
                            const handsTex = texLoader.load(skinConfig.textures.hands, () => console.log('✅ Hands texture loaded'));
                            const helmetTex = texLoader.load(skinConfig.textures.helmet, () => console.log('✅ Helmet texture loaded'));
                            
                            [bodyTex, handsTex, helmetTex].forEach(tex => {
                                tex.encoding = THREE.sRGBEncoding;
                                tex.flipY = true;
                                tex.wrapS = THREE.RepeatWrapping;
                                tex.wrapT = THREE.RepeatWrapping;
                            });
                            
                            let meshIndex = 0;
                            const textureArray = [helmetTex, bodyTex, handsTex];
                            const textureNames = ['helmet', 'body', 'hands'];
                            
                            opponentObject.traverse(function(child) {
                                if (child.isMesh) {
                                    child.castShadow = true;
                                    child.receiveShadow = true;
                                    
                                    const texIndex = meshIndex % textureArray.length;
                                    const selectedTex = textureArray[texIndex];
                                    console.log('📦 Opponent Mesh:', child.name, '-> Texture:', textureNames[texIndex]);
                                    
                                    // Create material - MeshBasicMaterial ignores lighting (always bright)
                                    const newMaterial = new THREE.MeshBasicMaterial({
                                        map: selectedTex,
                                        side: THREE.DoubleSide
                                    });
                                    if (child.isSkinnedMesh) newMaterial.skinning = true;
                                    
                                    child.material = newMaterial;
                                    meshIndex++;
                                }
                            });
                            console.log('✅ Opponent textures applied, total meshes:', meshIndex);
                        } else {
                            // Single texture (default soldier)
                            console.log('🎨 Loading single texture for opponent:', skin);
                            const texturePath = skinConfig ? skinConfig.texture : './T_PostalDude.png';
                            const opponentTexture = texLoader.load(texturePath, () => console.log('✅ Opponent texture loaded:', texturePath));
                            opponentTexture.encoding = THREE.sRGBEncoding;
                            opponentObject.traverse(function(child) {
                                if (child.isMesh) {
                                    child.castShadow = true;
                                    child.receiveShadow = true;
                                    // Use MeshBasicMaterial (unlit) so it won't react to emote lighting
                                    const newMaterial = new THREE.MeshBasicMaterial({
                                        map: opponentTexture,
                                        side: THREE.DoubleSide
                                    });
                                    if (child.isSkinnedMesh) newMaterial.skinning = true;
                                    child.material = newMaterial;
                                }
                            });
                        }
                        
                        // Scale and position
                        opponentObject.scale.set(modelScale, modelScale, modelScale);
                        opponentObject.position.set(pos.x, pos.y, pos.z);
                        
                        // All skins use same rotation logic to face center (no extra rotation for skeleton)
                        opponentObject.rotation.y = pos.x > 0 ? -Math.PI / 6 : Math.PI / 6;
                        
                        // Store skin name on object for later updates
                        opponentObject.userData.skin = skin;
                        
                        // Find head bone for nametag
                        let opponentHeadBone = null;
                        opponentObject.traverse((child) => {
                            if (child.isBone) {
                                const boneName = child.name.toLowerCase();
                                if (boneName.includes('head') && !opponentHeadBone) {
                                    opponentHeadBone = child;
                                    console.log('🦴 Found opponent head bone:', child.name);
                                }
                            }
                        });
                        
                        // If no head bone found, use the root object
                        if (!opponentHeadBone) {
                            console.log('⚠️ No head bone found for opponent, using root object');
                        }
                        
                        const opponentTagParent = opponentHeadBone ? opponentHeadBone : opponentObject;
                        
                        // Store opponent data in gameState
                        if (window.gameState) {
                            window.gameState.otherPlayerUsername = opponentUsername;
                            window.gameState.otherPlayerLevel = level;
                            window.gameState.otherPlayerSkin = skin;
                        }
                        
                        // Create nametag for opponent with their level - use skin-specific settings
                        console.log('🏷️ Creating opponent nametag:', opponentUsername, 'Level:', level, 'Skin:', skin);
                        const opponentSprite = createNameSprite(opponentUsername || 'OPPONENT', level);
                        
                        // Apply skin-specific nametag scale and position
                        if (skinConfig && skinConfig.nametagScale) {
                            console.log('🏷️ Using skin nametag scale:', skinConfig.nametagScale);
                            opponentSprite.scale.set(skinConfig.nametagScale.x, skinConfig.nametagScale.y, skinConfig.nametagScale.z);
                        } else {
                            console.log('🏷️ Using default nametag scale (50, 12, 1)');
                            opponentSprite.scale.set(50, 12, 1);
                        }
                        
                        // Use opponent-specific nametag position (higher than host's)
                        const nametagPos = (skinConfig && skinConfig.opponentNametagPos) || (skinConfig && skinConfig.nametagPos) || { x: 0, y: 25, z: 0 };
                        console.log('🏷️ Using opponent nametag pos:', nametagPos);
                        opponentSprite.position.set(nametagPos.x, nametagPos.y, nametagPos.z);
                        
                        // Make sure sprite is visible
                        opponentSprite.visible = true;
                        opponentSprite.renderOrder = 999; // Render on top
                        
                        opponentTagParent.add(opponentSprite);
                        console.log('✅ Opponent nametag added to:', opponentHeadBone ? 'head bone' : 'object root', '| Scale:', opponentSprite.scale, '| Pos:', opponentSprite.position);
                        
                        // Start animation - handle separate animation files for skeleton
                        // Debug bones for skeleton
                        if (skin === 'skeleton') {
                            console.log('💀 OPPONENT SKELETON MODEL BONES:');
                            opponentObject.traverse((child) => {
                                if (child.isBone) {
                                    console.log('   🦴', child.name);
                                }
                            });
                        }
                        
                        // For skeleton, ALWAYS load from separate animation file (ignore embedded)
                        if (skin === 'skeleton' && skinConfig && skinConfig.fbx) {
                            console.log('💀 Loading skeleton animation from:', skinConfig.fbx);
                            const animLoader = new FBXLoader();
                            animLoader.load(skinConfig.fbx, function(animObject) {
                                console.log('💀 Skeleton animation loaded! Clips:', animObject.animations.length);
                                
                                if (animObject.animations && animObject.animations.length > 0) {
                                    const oppMixer = new THREE.AnimationMixer(opponentObject);
                                    let clip = animObject.animations[0];
                                    
                                    // Sanitize - remove scale tracks
                                    clip = sanitizeAnimationClip(clip);
                                    
                                    // Try retargeting if needed
                                    clip = retargetAnimationClip(clip, opponentObject);
                                    
                                    const action = oppMixer.clipAction(clip);
                                    action.play();
                                    opponentObject.userData.mixer = oppMixer;
                                    console.log('💀 Skeleton animation playing');
                                }
                            }, undefined, function(err) {
                                console.error('❌ Failed to load skeleton animation:', err);
                            });
                        } else if (opponentObject.animations && opponentObject.animations.length > 0) {
                            // Non-skeleton: Use embedded animations if available
                            console.log('💀 Opponent model has embedded animations:', opponentObject.animations.length);
                            const oppMixer = new THREE.AnimationMixer(opponentObject);
                            const action = oppMixer.clipAction(opponentObject.animations[0]);
                            action.play();
                            opponentObject.userData.mixer = oppMixer;
                            console.log('💀 Playing opponent embedded animation');
                        } else if (skinConfig && skinConfig.modelFbx && skinConfig.fbx && skinConfig.fbx !== skinConfig.modelFbx) {
                            // Other skins with separate animation files
                            console.log('💀 Loading separate animation from:', skinConfig.fbx);
                            const animLoader = new FBXLoader();
                            animLoader.load(skinConfig.fbx, function(animObject) {
                                console.log('💀 Animation loaded! Clips:', animObject.animations.length);
                                
                                if (animObject.animations && animObject.animations.length > 0) {
                                    const oppMixer = new THREE.AnimationMixer(opponentObject);
                                    let clip = animObject.animations[0];
                                    
                                    // Try retargeting if needed
                                    clip = retargetAnimationClip(clip, opponentObject);
                                    
                                    const action = oppMixer.clipAction(clip);
                                    action.play();
                                    opponentObject.userData.mixer = oppMixer;
                                    console.log('💀 Animation playing');
                                }
                            }, undefined, function(err) {
                                console.error('❌ Failed to load animation:', err);
                            });
                        }
                        
                        // Store reference with unique name
                        if (gameMode === '1v1') {
                            opponentObject.name = 'opponentCharacter';
                        } else {
                            opponentObject.name = playerId ? 'opponent_' + playerId : 'opponent_' + menuCharacterCount;
                        }
                        
                        menuScene.add(opponentObject);
                        menuCharacterCount++;
                        
                        // Adjust camera to show all characters
                        if (menuCharacterCount === 1) {
                            menuCamera.position.set(3.5, 1.5, 5);
                            controls.target.set(1, 1.0, 0);
                        } else if (menuCharacterCount >= 2) {
                            menuCamera.position.set(0, 2, 7);
                            controls.target.set(0, 1.0, 0);
                        }
                        controls.update();
                        
                        // Update HTML squad list
                        updateSquadListPanel();
                        
                        console.log('✅ Opponent character added to menu scene:', opponentUsername, 'Total:', menuCharacterCount);
                        
                    }, undefined, function(err) { 
                        console.error('Failed to load opponent character:', err); 
                    });
                }
                
                // ============================================
                // FPS TACTICAL SQUAD LIST
                // ============================================
                let lobbyCountdown = null;
                
                function updateSquadListPanel() {
                    const lobbyList = document.getElementById('lobbySquadList');
                    if (!lobbyList) return;
                    
                    // HIDE during gameplay - only show in lobby/menu
                    if (window.gameState && window.gameState.started) {
                        lobbyList.style.display = 'none';
                        return;
                    }
                    
                    // Show the lobby list (only in lobby)
                    lobbyList.style.display = 'flex';
                    
                    // Get player names
                    const usernameInput = document.getElementById('usernameInput');
                    const myName = (usernameInput && usernameInput.value.trim()) || 'Player';
                    
                    // Check Game Mode & Host
                    const gameMode = window.gameMode || '1v1';
                    const amIHost = window.isHost || false;
                    const myTeam = window.myTeam || 1;
                    
                    // Get my profile picture and level
                    const myAvatar = ProfilePicture.get() || ProfilePicture.getInitialsAvatar(myName);
                    const myLevel = LevelSystem.data.level || 1;
                    
                    let players = [];
                    
                    // 1. Add Me
                    players.push({
                        name: myName,
                        isMe: true,
                        isHost: amIHost,
                        team: myTeam,
                        ping: Math.floor(Math.random() * 20) + 5,
                        avatar: myAvatar,
                        level: myLevel
                    });
                    
                    // 2. Add Others
                    if (gameMode === '2v2') {
                        const roomPlayers = window.roomPlayers || [];
                        const squadData = window.squadData || new Map();
                        
                        roomPlayers.forEach(pid => {
                            const pData = squadData.get(pid) || {};
                            const pName = pData.username || 'Player ' + pid.substring(0,4);
                            players.push({
                                name: pName,
                                isMe: false,
                                isHost: false, 
                                team: pData.team || (amIHost ? 2 : 1),
                                ping: Math.floor(Math.random() * 40) + 20,
                                avatar: pData.avatar || ProfilePicture.getInitialsAvatar(pName),
                                level: pData.level || 1
                            });
                        });
                    } else {
                        // 1v1 Fallback
                        const opponentName = (window.gameState && window.gameState.otherPlayerUsername) || null;
                        if (opponentName) {
                            const opponentAvatar = (window.gameState && window.gameState.otherPlayerAvatar) || ProfilePicture.getInitialsAvatar(opponentName);
                            const opponentLevel = (window.gameState && window.gameState.otherPlayerLevel) || 1;
                            players.push({
                                name: opponentName,
                                isMe: false,
                                isHost: !amIHost,
                                team: myTeam === 1 ? 2 : 1,
                                ping: Math.floor(Math.random() * 40) + 20,
                                avatar: opponentAvatar,
                                level: opponentLevel
                            });
                        }
                    }
                    
                    const playerCount = players.length;
                    
                    // Build HTML
                    let html = \`
                        <div class="lobby-header">
                            SQUAD
                            <span class="count">[\${playerCount}/4]</span>
                        </div>
                    \`;
                    
                    players.forEach(p => {
                        const status = p.isHost ? 'LEADER' : 'READY';
                        let playerClass = 'is-enemy';
                        
                        if (p.isMe) {
                            playerClass = 'is-me';
                        } else if (gameMode === '2v2' && p.team === myTeam) {
                             // Teammate - using 'is-me' style (white) to indicate friendly
                             playerClass = 'is-me'; 
                        }
                        
                        // Avatar click handler for own avatar - use data attribute
                        const avatarAttrs = p.isMe ? 'data-editable="true" style="cursor: pointer;" title="Click to change avatar"' : '';
                        
                        html += \`
                            <div class="lobby-player \${playerClass}">
                                <div class="player-avatar" \${avatarAttrs}>
                                    <img src="\${p.avatar}" alt="\${escapeHtml(p.name)}">
                                    <span class="level-badge-mini">\${p.level}</span>
                                    \${p.isMe ? '<div class="avatar-edit-icon">✎</div>' : ''}
                                </div>
                                <div class="player-info">
                                    <div class="player-name">\${escapeHtml(p.name)}</div>
                                </div>
                                <div class="player-status-container">
                                    <div class="player-status">\${status}</div>
                                    <div class="player-ping">\${p.ping}ms</div>
                                </div>
                            </div>
                        \`;
                    });
                    
                    // Empty Slots
                    for (let i = playerCount; i < 4; i++) {
                        html += \`
                            <div class="lobby-player" style="opacity: 0.2;">
                                <div class="player-avatar" style="opacity: 0.3;">
                                    <div style="width: 100%; height: 100%; background: #333; border-radius: 50%;"></div>
                                </div>
                                <div class="player-info">
                                    <div class="player-name" style="color: #555;">EMPTY</div>
                                </div>
                                <div class="player-status-container">
                                    <div class="player-status">...</div>
                                </div>
                            </div>
                        \`;
                    }
                    
                    lobbyList.innerHTML = html;
                    
                    // Add click handlers for editable avatars
                    lobbyList.querySelectorAll('.player-avatar[data-editable="true"]').forEach(avatar => {
                        avatar.addEventListener('click', function() {
                            const fileInput = document.getElementById('profilePictureInput');
                            if (fileInput) fileInput.click();
                        });
                    });
                }
                
                function escapeHtml(text) {
                    if (!text) return text;
                    return text
                        .replace(/&/g, "&amp;")
                        .replace(/</g, "&lt;")
                        .replace(/>/g, "&gt;")
                        .replace(/"/g, "&quot;")
                        .replace(/'/g, "&#039;");
                }
                
                // Function to hide lobby squad list
                function hideLobbySquadList() {
                    const lobbyList = document.getElementById('lobbySquadList');
                    if (lobbyList) lobbyList.style.display = 'none';
                    if (lobbyCountdown) {
                        clearInterval(lobbyCountdown);
                        lobbyCountdown = null;
                    }
                }
                
                // Function to update opponent's nametag in the menu scene
                function updateOpponentNametag(newName, newLevel) {
                    console.log('🏷️ updateOpponentNametag called:', newName, 'Level:', newLevel);
                    const opponent = menuScene.getObjectByName('opponentCharacter');
                    if (opponent) {
                        // Get skin config for scale
                        const skin = opponent.userData.skin || 'soldier';
                        const skinConfig = window.SKIN_CONFIG?.[skin] || window.SKIN_CONFIG?.soldier;
                        const nametagScale = skinConfig?.nametagScale || {x: 65, y: 16, z: 1};
                        // Use opponent-specific position (higher)
                        const nametagPos = skinConfig?.opponentNametagPos || skinConfig?.nametagPos || {x: 0, y: 15, z: 0};
                        
                        // Find and update the nametag
                        let foundNametag = false;
                        opponent.traverse((child) => {
                            if (child.isSprite && child.name === 'playerNametag') {
                                foundNametag = true;
                                // Remove old sprite
                                const parent = child.parent;
                                parent.remove(child);
                                
                                // Create new sprite with updated name and level
                                const newSprite = createNameSprite(newName || 'OPPONENT', newLevel || 1);
                                newSprite.scale.set(nametagScale.x, nametagScale.y, nametagScale.z);
                                newSprite.position.set(nametagPos.x, nametagPos.y, nametagPos.z);
                                newSprite.renderOrder = 999;
                                parent.add(newSprite);
                                console.log('✅ Updated existing nametag');
                            }
                        });
                        
                        // If no nametag found, ADD one
                        if (!foundNametag) {
                            console.log('⚠️ No existing nametag found, creating new one');
                            // Find head bone
                            let headBone = null;
                            opponent.traverse((child) => {
                                if (child.isBone && (child.name.toLowerCase().includes('head') || 
                                    child.name.toLowerCase().includes('neck'))) {
                                    if (!headBone || child.name.toLowerCase().includes('head')) {
                                        headBone = child;
                                    }
                                }
                            });
                            
                            const newSprite = createNameSprite(newName || 'OPPONENT', newLevel || 1);
                            newSprite.scale.set(nametagScale.x, nametagScale.y, nametagScale.z);
                            newSprite.position.set(nametagPos.x, nametagPos.y, nametagPos.z);
                            newSprite.renderOrder = 999;
                            
                            if (headBone) {
                                headBone.add(newSprite);
                                console.log('✅ Added new nametag to head bone:', headBone.name);
                            } else {
                                // Attach to model root if no head bone
                                opponent.add(newSprite);
                                newSprite.position.y = 180; // Higher position for root attachment
                                console.log('✅ Added new nametag to opponent root');
                            }
                        }
                    } else {
                        console.log('⚠️ No opponent in scene yet for nametag update');
                    }
                    
                    // Also update HTML squad list
                    if (window.gameState) {
                        window.gameState.otherPlayerUsername = newName;
                        if (newLevel) window.gameState.otherPlayerLevel = newLevel;
                    }
                    updateSquadListPanel();
                }
                
                // Function to update opponent's skin in the menu scene
                function updateOpponentSkin(newSkin) {
                    console.log('👔 Updating opponent skin to:', newSkin);
                    
                    // Store the skin for when opponent loads (in case they haven't loaded yet)
                    if (window.gameState) {
                        window.gameState.otherPlayerSkin = newSkin;
                    }
                    
                    const opponent = menuScene.getObjectByName('opponentCharacter');
                    if (!opponent) {
                        console.warn('⚠️ No opponent in menu scene yet - skin will be applied when they load');
                        return;
                    }
                    
                    // Check if skin is actually different
                    if (opponent.userData.skin === newSkin) {
                        console.log('👔 Opponent already has this skin:', newSkin);
                        return;
                    }
                    
                    // Get opponent's username and level
                    const opponentName = window.gameState?.otherPlayerUsername || 'OPPONENT';
                    const opponentLevel = window.gameState?.otherPlayerLevel || 1;
                    
                    // Remove old opponent
                    menuScene.remove(opponent);
                    menuCharacterCount = Math.max(0, menuCharacterCount - 1);
                    
                    console.log('👔 Re-adding opponent with new skin:', newSkin);
                    // Re-add opponent with new skin (addOpponent will increment menuCharacterCount)
                    addOpponent(opponentName, opponentLevel, newSkin);
                }
                
                // Opponent emote system - swap model approach
                let opponentEmoteAudio = null;
                let opponentEmoteCharacter = null;
                let opponentEmoteMixer = null;
                let savedOpponentIdle = null;
                let isOpponentEmoting = false;
                
                function playOpponentEmote(skin) {
                    console.log('💃 playOpponentEmote called with skin:', skin);
                    
                    const opponent = menuScene.getObjectByName('opponentCharacter');
                    console.log('💃 Found opponent:', opponent ? opponent.name : 'NOT FOUND');
                    console.log('💃 menuScene children:', menuScene.children.map(c => c.name).join(', '));
                    
                    if (!opponent) {
                        console.log('❌ No opponent to emote - looking for any opponent...');
                        // Try to find any opponent character
                        const allOpponents = menuScene.children.filter(c => c.name && c.name.includes('opponent'));
                        console.log('💃 All opponents found:', allOpponents.map(o => o.name));
                        if (allOpponents.length === 0) {
                            return;
                        }
                    }
                    
                    if (isOpponentEmoting) {
                        console.log('⚠️ Opponent already emoting');
                        return;
                    }
                    
                    const skinConfig = window.SKIN_CONFIG?.[skin];
                    console.log('💃 Skin config for', skin, ':', skinConfig ? 'found' : 'NOT FOUND');
                    console.log('💃 Emote config:', skinConfig?.emote ? 'found' : 'NOT FOUND');
                    
                    if (!skinConfig || !skinConfig.emote) {
                        console.log('❌ No emote for skin:', skin);
                        return;
                    }
                    
                    console.log('💃 Playing opponent emote for skin:', skin);
                    isOpponentEmoting = true;
                    
                    // Play emote music (lower volume for opponent)
                    if (skinConfig.emote.music) {
                        opponentEmoteAudio = new Audio(skinConfig.emote.music);
                        const opponentEmoteRouted = ensureMediaElementThroughTrauma(opponentEmoteAudio);
                        if (opponentEmoteRouted && opponentEmoteRouted.gainNode) {
                            opponentEmoteRouted.gainNode.gain.value = 0.3;
                            opponentEmoteAudio.volume = 1;
                        } else {
                            opponentEmoteAudio.volume = 0.3;
                        }
                        opponentEmoteAudio.play().catch(e => console.log('Opponent audio play failed:', e));
                    }
                    
                    // Save opponent reference
                    savedOpponentIdle = opponent;
                    const currentPos = opponent.position.clone();
                    const currentRot = opponent.rotation.clone();
                    const modelScale = skinConfig.scale || 1.09;
                    
                    // REMOVE opponent from scene (not just hide)
                    menuScene.remove(opponent);
                    console.log('💃 Removed opponent idle from scene');
                    
                    // Load emote model - USE EMBEDDED TEXTURES (like player emote)
                    const emoteLoader = new FBXLoader();
                    emoteLoader.load(skinConfig.emote.fbx, function(emoteObject) {
                        console.log('✅ Opponent emote FBX loaded');
                        
                        // Convert materials to MeshBasicMaterial (unlit, like player)
                        emoteObject.traverse(function(child) {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                                
                                // Get the existing texture from embedded material
                                const oldMat = child.material;
                                let texture = null;
                                if (oldMat && oldMat.map) {
                                    texture = oldMat.map;
                                }
                                
                                // Create unlit material
                                const newMat = new THREE.MeshBasicMaterial({
                                    map: texture,
                                    side: THREE.DoubleSide
                                });
                                if (child.isSkinnedMesh) newMat.skinning = true;
                                child.material = newMat;
                                
                                console.log('💃 Opponent mesh:', child.name, '- converted to MeshBasicMaterial');
                            }
                        });
                        
                        // Apply scale - IMPORTANT: dance.fbx is 100x larger, so use 1% scale
                        const emoteScale = modelScale * 0.01;
                        emoteObject.scale.set(emoteScale, emoteScale, emoteScale);
                        
                        // Position at opponent's location
                        emoteObject.position.set(currentPos.x, currentPos.y, currentPos.z);
                        emoteObject.rotation.set(currentRot.x, currentRot.y, currentRot.z);
                        emoteObject.name = 'opponentEmoteCharacter';
                        
                        // Start animation - REMOVE ROOT MOTION
                        if (emoteObject.animations && emoteObject.animations.length > 0) {
                            opponentEmoteMixer = new THREE.AnimationMixer(emoteObject);
                            
                            const clip = emoteObject.animations[0];
                            
                            // Remove position tracks that cause movement
                            const tracksToKeep = clip.tracks.filter(track => {
                                const trackName = track.name.toLowerCase();
                                if (trackName.includes('position') && (trackName.includes('root') || trackName.includes('hips') || trackName.startsWith('.'))) {
                                    console.log('💃 Removing opponent root motion track:', track.name);
                                    return false;
                                }
                                return true;
                            });
                            
                            const cleanClip = new THREE.AnimationClip(clip.name, clip.duration, tracksToKeep);
                            
                            const action = opponentEmoteMixer.clipAction(cleanClip);
                            action.setLoop(THREE.LoopRepeat);
                            action.play();
                            console.log('💃 Opponent emote animation playing');
                        }
                        
                        // Find head bone for nametag tracking
                        let opponentEmoteHeadBone = null;
                        emoteObject.traverse(function(child) {
                            if (child.isBone && child.name === 'mixamorigHead') {
                                opponentEmoteHeadBone = child;
                            }
                        });
                        window.opponentEmoteHeadBone = opponentEmoteHeadBone;
                        
                        // Create opponent nametag for emote - use gameState for opponent info
                        const opponentName = (window.gameState && window.gameState.otherPlayerUsername) || 'OPPONENT';
                        const opponentLevel = (window.gameState && window.gameState.otherPlayerLevel) || 1;
                        
                        const opponentEmoteNametag = createNameSprite(opponentName, opponentLevel);
                        opponentEmoteNametag.name = 'opponentEmoteNametag';
                        opponentEmoteNametag.scale.set(0.7, 0.17, 1);
                        opponentEmoteNametag.position.set(currentPos.x, currentPos.y + 2.2, currentPos.z);
                        menuScene.add(opponentEmoteNametag);
                        window.opponentEmoteNametag = opponentEmoteNametag;
                        window.opponentEmoteBasePos = currentPos.clone();
                        
                        opponentEmoteCharacter = emoteObject;
                        menuScene.add(emoteObject);
                        console.log('💃 Opponent emote model added at', currentPos);
                    }, undefined, function(err) {
                        console.error('❌ Failed to load opponent emote FBX:', err);
                        isOpponentEmoting = false;
                        // Add opponent back if failed
                        if (savedOpponentIdle) {
                            menuScene.add(savedOpponentIdle);
                        }
                    });
                }
                
                function stopOpponentEmote() {
                    if (!isOpponentEmoting) return;
                    
                    console.log('💃 Stopping opponent emote');
                    isOpponentEmoting = false;
                    
                    if (opponentEmoteAudio) {
                        opponentEmoteAudio.pause();
                        opponentEmoteAudio.currentTime = 0;
                        opponentEmoteAudio = null;
                    }
                    
                    // Remove emote character
                    if (opponentEmoteCharacter) {
                        menuScene.remove(opponentEmoteCharacter);
                        opponentEmoteCharacter = null;
                        opponentEmoteMixer = null;
                    }
                    
                    // Remove opponent emote nametag
                    if (window.opponentEmoteNametag) {
                        menuScene.remove(window.opponentEmoteNametag);
                        window.opponentEmoteNametag = null;
                        window.opponentEmoteHeadBone = null;
                        window.opponentEmoteBasePos = null;
                    }
                    
                    // Add idle opponent back to scene
                    if (savedOpponentIdle) {
                        menuScene.add(savedOpponentIdle);
                        console.log('💃 Opponent idle added back to scene');
                    }
                }
                
                // Update opponent emote mixer in animation loop
                window.updateOpponentEmoteMixer = (delta) => {
                    if (opponentEmoteMixer) {
                        opponentEmoteMixer.update(delta);
                    }
                    
                    // Update opponent emote nametag to follow head
                    if (window.opponentEmoteNametag && window.opponentEmoteHeadBone) {
                        const headWorldPos = new THREE.Vector3();
                        window.opponentEmoteHeadBone.getWorldPosition(headWorldPos);
                        window.opponentEmoteNametag.position.set(
                            headWorldPos.x,
                            headWorldPos.y + 0.35,
                            headWorldPos.z
                        );
                    }
                };
                
                window.playOpponentEmote = playOpponentEmote;
                window.stopOpponentEmote = stopOpponentEmote;
                
                // Expose functions to global scope
                window.addOpponentToMenuScene = addOpponent;
                window.updateLobbySquadList = updateSquadListPanel;
                window.updateOpponentNametagInLobby = updateOpponentNametag;
                window.updateOpponentSkinInLobby = updateOpponentSkin;
                window.hideLobbySquadList = hideLobbySquadList;
                
                // Hide menu scene when game starts
                return {
                    hide: () => {
                        menuCanvas.style.display = 'none';
                        hideLobbySquadList(); // Also hide the squad list
                    },
                    addOpponent: addOpponent,
                    updateSquadList: updateSquadListPanel
                };
            }

            // Initialize menu scene and expose to global scope
            window.menuSceneController = initMenuScene();
        `;
        document.head.appendChild(menuModuleScript);

        // Auto-initialize game engine immediately for loading screen
        // This pre-loads assets while showing the loading screen
        setTimeout(function () {
            if (!window.gameInitialized) {
                console.log('Auto-initializing game engine...');
                initGame();
            }
        }, 100);

        function initGame() {
            // Prevent double initialization
            if (window.gameInitialized) {
                console.log('Game already initialized');
                return;
            }
            window.gameInitialized = true;
            console.log('Initializing game...');

            // Unlock all audio (user gesture happened)
            if (typeof resumeGlobalAudio === 'function') resumeGlobalAudio();
            if (window._unlockFootstepAudio) window._unlockFootstepAudio();

            // ==================== REGISTER ALL ASSETS FOR LOADING ====================
            if (window.LoadingScreen) {
                LoadingScreen.setStatus('REGISTERING ASSETS...');

                // Core engine
                LoadingScreen.registerAsset('renderer');
                LoadingScreen.registerAsset('scene');
                LoadingScreen.registerAsset('shaders');
                LoadingScreen.registerAsset('lighting');

                // Environment
                LoadingScreen.registerAsset('hdr_environment');
                LoadingScreen.registerAsset('asphalt_diffuse');
                LoadingScreen.registerAsset('asphalt_normal');
                LoadingScreen.registerAsset('asphalt_roughness');

                // Map objects
                LoadingScreen.registerAsset('barriers');
                LoadingScreen.registerAsset('floor');
                LoadingScreen.registerAsset('walls');

                // Weapon models
                LoadingScreen.registerAsset('rifle_model');

                // Audio - Gun sounds
                LoadingScreen.registerAsset('sound_death');
                LoadingScreen.registerAsset('sound_ak47');
                LoadingScreen.registerAsset('sound_awp');
                LoadingScreen.registerAsset('sound_deagle');

                // Audio - Body/headshot sounds
                LoadingScreen.registerAsset('sound_body1');
                LoadingScreen.registerAsset('sound_body2');
                LoadingScreen.registerAsset('sound_body3');
                LoadingScreen.registerAsset('sound_body4');
                LoadingScreen.registerAsset('sound_killed');
                LoadingScreen.registerAsset('sound_killedmedal');
                LoadingScreen.registerAsset('sound_headshot1');
                LoadingScreen.registerAsset('sound_headshot2');

                // Menu assets
                LoadingScreen.registerAsset('menu_model');
                LoadingScreen.registerAsset('menu_texture');
                LoadingScreen.registerAsset('speaker_icon');

                // UI/Final
                LoadingScreen.registerAsset('ui_ready');

                console.log('📦 Registered', LoadingScreen.totalAssets, 'assets to load');
            }

            // Load death sound - delayed until audio context is ready
            function loadSounds() {
                if (DISABLE_WEBAUDIO_MP3_DECODE) {
                    if (window.LoadingScreen) LoadingScreen.setStatus('LOADING AUDIO...');

                    // Build media pools (safe mode)
                    deathSoundMedia = createMediaSoundPool('diesound.mp3', 2);
                    ak47SoundMedia = createMediaSoundPool('gun/ak47.mp3', 6);
                    awpSoundMedia = createMediaSoundPool('gun/awp.mp3', 4);
                    deagleSoundMedia = createMediaSoundPool('gun/deagle.mp3', 6);

                    for (let i = 1; i <= 4; i++) {
                        const index = i - 1;
                        bodyShotSoundMedias[index] = createMediaSoundPool(`bodyheadshots/${i}.mp3`, 4);
                    }

                    killedSoundMedia = createMediaSoundPool('bodyheadshots/killed.mp3', 3);
                    killedMedalSoundMedia = createMediaSoundPool('bodyheadshots/killedmedal.mp3', 3);
                    headshotDead1SoundMedia = createMediaSoundPool('bodyheadshots/headshotdead1.mp3', 3);
                    headshotDead2SoundMedia = createMediaSoundPool('bodyheadshots/headshotdead2.mp3', 3);

                    // Bullet sounds (incoming bullets from enemies)
                    bulletHitSoundMedias[0] = createMediaSoundPool('bulletssounds/hit.mp3', 3);
                    bulletHitSoundMedias[1] = createMediaSoundPool('bulletssounds/hit2.mp3', 3);
                    for (let i = 0; i < 5; i++) {
                        bulletMissedSoundMedias[i] = createMediaSoundPool(`bulletssounds/missed${i}.mp3`, 3);
                    }

                    // Level-up sound pool (used by LevelSystem)
                    window.mcLevelUpSoundMedia = createMediaSoundPool('Minecraft xp sound effect.mp3', 2);

                    // Mark assets as loaded so the loading screen can proceed
                    if (window.LoadingScreen) {
                        LoadingScreen.assetLoaded('sound_death');
                        LoadingScreen.assetLoaded('sound_ak47');
                        LoadingScreen.assetLoaded('sound_awp');
                        LoadingScreen.assetLoaded('sound_deagle');
                        LoadingScreen.assetLoaded('sound_body1');
                        LoadingScreen.assetLoaded('sound_body2');
                        LoadingScreen.assetLoaded('sound_body3');
                        LoadingScreen.assetLoaded('sound_body4');
                        LoadingScreen.assetLoaded('sound_killed');
                        LoadingScreen.assetLoaded('sound_killedmedal');
                        LoadingScreen.assetLoaded('sound_headshot1');
                        LoadingScreen.assetLoaded('sound_headshot2');
                    }

                    console.log('🔊 MP3 decodeAudioData disabled (Electron/Windows safe mode)');
                    return;
                }

                const ctx = ensureAudioContext();
                if (!ctx) {
                    console.warn('AudioContext not available, sounds disabled');
                    // Mark all sound assets as loaded anyway to continue
                    if (window.LoadingScreen) {
                        LoadingScreen.assetLoaded('sound_death');
                        LoadingScreen.assetLoaded('sound_ak47');
                        LoadingScreen.assetLoaded('sound_awp');
                        LoadingScreen.assetLoaded('sound_deagle');
                        LoadingScreen.assetLoaded('sound_body1');
                        LoadingScreen.assetLoaded('sound_body2');
                        LoadingScreen.assetLoaded('sound_body3');
                        LoadingScreen.assetLoaded('sound_body4');
                        LoadingScreen.assetLoaded('sound_killed');
                        LoadingScreen.assetLoaded('sound_killedmedal');
                        LoadingScreen.assetLoaded('sound_headshot1');
                        LoadingScreen.assetLoaded('sound_headshot2');
                    }
                    return;
                }

                if (window.LoadingScreen) LoadingScreen.setStatus('LOADING AUDIO...');

                fetch('diesound.mp3')
                    .then(response => {
                        if (!response.ok) throw new Error('Sound file not found');
                        return response.arrayBuffer();
                    })
                    .then(arrayBuffer => ctx.decodeAudioData(arrayBuffer))
                    .then(audioBuffer => {
                        deathSoundBuffer = audioBuffer;
                        console.log('Death sound loaded!');
                        if (window.LoadingScreen) LoadingScreen.assetLoaded('sound_death');
                    })
                    .catch(e => {
                        console.warn('Death sound not available (optional):', e.message);
                        if (window.LoadingScreen) LoadingScreen.assetLoaded('sound_death');
                    });

                fetch('gun/ak47.mp3')
                    .then(response => {
                        if (!response.ok) throw new Error('Sound file not found');
                        return response.arrayBuffer();
                    })
                    .then(arrayBuffer => ctx.decodeAudioData(arrayBuffer))
                    .then(audioBuffer => {
                        ak47SoundBuffer = audioBuffer;
                        console.log('AK-47 sound loaded!');
                        if (window.LoadingScreen) LoadingScreen.assetLoaded('sound_ak47');
                    })
                    .catch(e => {
                        console.warn('AK-47 sound not available (optional):', e.message);
                        if (window.LoadingScreen) LoadingScreen.assetLoaded('sound_ak47');
                    });

                fetch('gun/awp.mp3')
                    .then(response => {
                        if (!response.ok) throw new Error('Sound file not found');
                        return response.arrayBuffer();
                    })
                    .then(arrayBuffer => ctx.decodeAudioData(arrayBuffer))
                    .then(audioBuffer => {
                        awpSoundBuffer = audioBuffer;
                        console.log('AWP sound loaded!');
                        if (window.LoadingScreen) LoadingScreen.assetLoaded('sound_awp');
                    })
                    .catch(e => {
                        console.warn('AWP sound not available (optional):', e.message);
                        if (window.LoadingScreen) LoadingScreen.assetLoaded('sound_awp');
                    });

                fetch('gun/deagle.mp3')
                    .then(response => {
                        if (!response.ok) throw new Error('Sound file not found');
                        return response.arrayBuffer();
                    })
                    .then(arrayBuffer => ctx.decodeAudioData(arrayBuffer))
                    .then(audioBuffer => {
                        deagleSoundBuffer = audioBuffer;
                        console.log('Deagle sound loaded!');
                        if (window.LoadingScreen) LoadingScreen.assetLoaded('sound_deagle');
                    })
                    .catch(e => {
                        console.warn('Deagle sound not available (optional):', e.message);
                        if (window.LoadingScreen) LoadingScreen.assetLoaded('sound_deagle');
                    });

                // Load body shot sounds (1.mp3 to 4.mp3 - played in sequence)
                for (let i = 1; i <= 4; i++) {
                    const index = i - 1; // Array index 0-3
                    fetch(`bodyheadshots/${i}.mp3`)
                        .then(response => {
                            if (!response.ok) throw new Error(`Body shot sound ${i}.mp3 not found`);
                            return response.arrayBuffer();
                        })
                        .then(arrayBuffer => ctx.decodeAudioData(arrayBuffer))
                        .then(audioBuffer => {
                            bodyShotSoundBuffers[index] = audioBuffer;
                            console.log(`Body shot sound ${i}.mp3 loaded!`);
                            if (window.LoadingScreen) LoadingScreen.assetLoaded('sound_body' + i);
                        })
                        .catch(e => {
                            console.warn(`Body shot sound ${i}.mp3 not available:`, e.message);
                            if (window.LoadingScreen) LoadingScreen.assetLoaded('sound_body' + i);
                        });
                }

                // Load kill sounds (body shot kills)
                fetch('bodyheadshots/killed.mp3')
                    .then(response => {
                        if (!response.ok) throw new Error('killed.mp3 not found');
                        return response.arrayBuffer();
                    })
                    .then(arrayBuffer => ctx.decodeAudioData(arrayBuffer))
                    .then(audioBuffer => {
                        killedSoundBuffer = audioBuffer;
                        console.log('killed.mp3 loaded!');
                        if (window.LoadingScreen) LoadingScreen.assetLoaded('sound_killed');
                    })
                    .catch(e => {
                        console.warn('killed.mp3 not available:', e.message);
                        if (window.LoadingScreen) LoadingScreen.assetLoaded('sound_killed');
                    });

                fetch('bodyheadshots/killedmedal.mp3')
                    .then(response => {
                        if (!response.ok) throw new Error('killedmedal.mp3 not found');
                        return response.arrayBuffer();
                    })
                    .then(arrayBuffer => ctx.decodeAudioData(arrayBuffer))
                    .then(audioBuffer => {
                        killedMedalSoundBuffer = audioBuffer;
                        console.log('killedmedal.mp3 loaded!');
                        if (window.LoadingScreen) LoadingScreen.assetLoaded('sound_killedmedal');
                    })
                    .catch(e => {
                        console.warn('killedmedal.mp3 not available:', e.message);
                        if (window.LoadingScreen) LoadingScreen.assetLoaded('sound_killedmedal');
                    });

                // Load headshot kill sounds
                fetch('bodyheadshots/headshotdead1.mp3')
                    .then(response => {
                        if (!response.ok) throw new Error('headshotdead1.mp3 not found');
                        return response.arrayBuffer();
                    })
                    .then(arrayBuffer => ctx.decodeAudioData(arrayBuffer))
                    .then(audioBuffer => {
                        headshotDead1SoundBuffer = audioBuffer;
                        console.log('headshotdead1.mp3 loaded!');
                        if (window.LoadingScreen) LoadingScreen.assetLoaded('sound_headshot1');
                    })
                    .catch(e => {
                        console.warn('headshotdead1.mp3 not available:', e.message);
                        if (window.LoadingScreen) LoadingScreen.assetLoaded('sound_headshot1');
                    });

                fetch('bodyheadshots/headshotdead2.mp3')
                    .then(response => {
                        if (!response.ok) throw new Error('headshotdead2.mp3 not found');
                        return response.arrayBuffer();
                    })
                    .then(arrayBuffer => ctx.decodeAudioData(arrayBuffer))
                    .then(audioBuffer => {
                        headshotDead2SoundBuffer = audioBuffer;
                        console.log('headshotdead2.mp3 loaded!');
                        if (window.LoadingScreen) LoadingScreen.assetLoaded('sound_headshot2');
                    })
                    .catch(e => {
                        console.warn('headshotdead2.mp3 not available:', e.message);
                        if (window.LoadingScreen) LoadingScreen.assetLoaded('sound_headshot2');
                    });

                // Load bullet sounds (incoming bullets from enemies)
                // Hit sounds (when player gets hit)
                fetch('bulletssounds/hit.mp3')
                    .then(response => {
                        if (!response.ok) throw new Error('hit.mp3 not found');
                        return response.arrayBuffer();
                    })
                    .then(arrayBuffer => ctx.decodeAudioData(arrayBuffer))
                    .then(audioBuffer => {
                        bulletHitSoundBuffers[0] = audioBuffer;
                        console.log('🔫 Bullet hit sound 1 loaded!');
                    })
                    .catch(e => console.warn('bulletssounds/hit.mp3 not available:', e.message));

                fetch('bulletssounds/hit2.mp3')
                    .then(response => {
                        if (!response.ok) throw new Error('hit2.mp3 not found');
                        return response.arrayBuffer();
                    })
                    .then(arrayBuffer => ctx.decodeAudioData(arrayBuffer))
                    .then(audioBuffer => {
                        bulletHitSoundBuffers[1] = audioBuffer;
                        console.log('🔫 Bullet hit sound 2 loaded!');
                    })
                    .catch(e => console.warn('bulletssounds/hit2.mp3 not available:', e.message));

                // Missed sounds (bullet whizzing by)
                for (let i = 0; i < 5; i++) {
                    fetch(`bulletssounds/missed${i}.mp3`)
                        .then(response => {
                            if (!response.ok) throw new Error(`missed${i}.mp3 not found`);
                            return response.arrayBuffer();
                        })
                        .then(arrayBuffer => ctx.decodeAudioData(arrayBuffer))
                        .then(audioBuffer => {
                            bulletMissedSoundBuffers[i] = audioBuffer;
                            console.log(`🔫 Bullet whiz sound ${i} loaded!`);
                        })
                        .catch(e => console.warn(`bulletssounds/missed${i}.mp3 not available:`, e.message));
                }

                // Load Minecraft level up sound
                fetch('Minecraft xp sound effect.mp3')
                    .then(response => {
                        if (!response.ok) throw new Error('Minecraft XP sound not found');
                        return response.arrayBuffer();
                    })
                    .then(arrayBuffer => ctx.decodeAudioData(arrayBuffer))
                    .then(audioBuffer => {
                        window.mcLevelUpSoundBuffer = audioBuffer;
                        console.log('✅ Minecraft XP level up sound loaded!');
                    })
                    .catch(e => {
                        console.warn('Minecraft XP sound not available:', e.message);
                    });
            }

            // Call loadSounds to actually load the audio files
            loadSounds();

            // Play gun sounds from audio files
            function playShootSound(weaponType, volume = 1) {
                let soundBuffer = null;
                let soundMedia = null;

                // Select the appropriate sound based on weapon type
                if (weaponType === 'rifle') {
                    soundBuffer = ak47SoundBuffer;
                    soundMedia = ak47SoundMedia;
                } else if (weaponType === 'pistol') {
                    soundBuffer = deagleSoundBuffer;
                    soundMedia = deagleSoundMedia;
                } else if (weaponType === 'sniper') {
                    soundBuffer = awpSoundBuffer;
                    soundMedia = awpSoundMedia;
                }

                // Safe-mode media playback (no decodeAudioData)
                if (soundMedia) {
                    soundMedia.play(volume * 0.5);
                    return;
                }

                // Play the sound if loaded
                if (soundBuffer) {
                    playSound(soundBuffer, volume * 0.5); // Reduced volume for balance
                    return;
                }

                // Fallback to synthesized sound if file not loaded yet
                playShootSoundSynthesized(weaponType, volume);
            }

            // Fallback synthesized sound generation
            function playShootSoundSynthesized(weaponType, volume = 1) {
                const ctx = ensureAudioContext();
                if (!ctx) return;
                const now = ctx.currentTime;

                // Create noise buffer for realistic gunshot
                const bufferSize = ctx.sampleRate * 0.5;
                const noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const output = noiseBuffer.getChannelData(0);

                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1;
                }

                const noise = ctx.createBufferSource();
                noise.buffer = noiseBuffer;

                const noiseFilter = ctx.createBiquadFilter();
                const noiseGain = ctx.createGain();

                noise.connect(noiseFilter);
                noiseFilter.connect(noiseGain);
                noiseGain.connect(ctx.destination);

                if (weaponType === 'rifle') {
                    // AK-47 sound: Sharp crack with bass rumble
                    noiseFilter.type = 'bandpass';
                    noiseFilter.frequency.setValueAtTime(800, now);
                    noiseFilter.frequency.exponentialRampToValueAtTime(200, now + 0.05);
                    noiseFilter.Q.value = 1;

                    noiseGain.gain.setValueAtTime(0.6 * volume, now);
                    noiseGain.gain.exponentialRampToValueAtTime(0.01 * volume, now + 0.15);

                    // Add bass thump
                    const bass = ctx.createOscillator();
                    const bassGain = ctx.createGain();
                    bass.connect(bassGain);
                    bassGain.connect(ctx.destination);
                    bass.frequency.setValueAtTime(80, now);
                    bass.frequency.exponentialRampToValueAtTime(30, now + 0.1);
                    bassGain.gain.setValueAtTime(0.4 * volume, now);
                    bassGain.gain.exponentialRampToValueAtTime(0.01 * volume, now + 0.1);
                    bass.start(now);
                    bass.stop(now + 0.1);

                } else if (weaponType === 'pistol') {
                    // Desert Eagle: Sharp high-frequency crack
                    noiseFilter.type = 'highpass';
                    noiseFilter.frequency.setValueAtTime(1200, now);
                    noiseFilter.frequency.exponentialRampToValueAtTime(400, now + 0.03);

                    noiseGain.gain.setValueAtTime(0.5 * volume, now);
                    noiseGain.gain.exponentialRampToValueAtTime(0.01 * volume, now + 0.08);

                    // Metallic ring
                    const ring = ctx.createOscillator();
                    const ringGain = ctx.createGain();
                    ring.connect(ringGain);
                    ringGain.connect(ctx.destination);
                    ring.frequency.setValueAtTime(2000, now);
                    ring.frequency.exponentialRampToValueAtTime(1000, now + 0.05);
                    ringGain.gain.setValueAtTime(0.15 * volume, now);
                    ringGain.gain.exponentialRampToValueAtTime(0.01 * volume, now + 0.05);
                    ring.start(now);
                    ring.stop(now + 0.05);

                } else if (weaponType === 'sniper') {
                    // AWP: Massive boom with echo
                    noiseFilter.type = 'lowpass';
                    noiseFilter.frequency.setValueAtTime(600, now);
                    noiseFilter.frequency.exponentialRampToValueAtTime(100, now + 0.2);

                    noiseGain.gain.setValueAtTime(0.8 * volume, now);
                    noiseGain.gain.exponentialRampToValueAtTime(0.01 * volume, now + 0.3);

                    // Deep bass boom
                    const boom = ctx.createOscillator();
                    const boomGain = ctx.createGain();
                    boom.connect(boomGain);
                    boomGain.connect(ctx.destination);
                    boom.frequency.setValueAtTime(60, now);
                    boom.frequency.exponentialRampToValueAtTime(20, now + 0.2);
                    boomGain.gain.setValueAtTime(0.6 * volume, now);
                    boomGain.gain.exponentialRampToValueAtTime(0.01 * volume, now + 0.2);
                    boom.start(now);
                    boom.stop(now + 0.2);
                }

                noise.start(now);
                noise.stop(now + 0.3);
            }

            function playReloadSound(volume = 1) {
                const ctx = ensureAudioContext();
                if (!ctx) return;
                const now = ctx.currentTime;

                // Magazine out (metallic click)
                const click1 = ctx.createOscillator();
                const click1Gain = ctx.createGain();
                click1.connect(click1Gain);
                click1Gain.connect(ctx.destination);
                click1.frequency.setValueAtTime(800, now);
                click1.frequency.exponentialRampToValueAtTime(200, now + 0.02);
                click1Gain.gain.setValueAtTime(0.3 * volume, now);
                click1Gain.gain.exponentialRampToValueAtTime(0.01 * volume, now + 0.02);
                click1.start(now);
                click1.stop(now + 0.02);

                // Magazine slide (mechanical noise)
                const bufferSize = ctx.sampleRate * 0.3;
                const noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.3));
                }

                const noise = ctx.createBufferSource();
                noise.buffer = noiseBuffer;
                const noiseFilter = ctx.createBiquadFilter();
                const noiseGain = ctx.createGain();
                noise.connect(noiseFilter);
                noiseFilter.connect(noiseGain);
                noiseGain.connect(ctx.destination);
                noiseFilter.type = 'bandpass';
                noiseFilter.frequency.value = 400;
                noiseGain.gain.setValueAtTime(0.15 * volume, now + 0.3);
                noiseGain.gain.exponentialRampToValueAtTime(0.01 * volume, now + 0.6);
                noise.start(now + 0.3);

                // Magazine in (solid click)
                const click2 = ctx.createOscillator();
                const click2Gain = ctx.createGain();
                click2.connect(click2Gain);
                click2Gain.connect(ctx.destination);
                click2.frequency.setValueAtTime(600, now + 0.7);
                click2.frequency.exponentialRampToValueAtTime(150, now + 0.72);
                click2Gain.gain.setValueAtTime(0.35 * volume, now + 0.7);
                click2Gain.gain.exponentialRampToValueAtTime(0.01 * volume, now + 0.72);
                click2.start(now + 0.7);
                click2.stop(now + 0.72);

                // Bolt/slide rack (metallic scrape)
                const rack = ctx.createOscillator();
                const rackGain = ctx.createGain();
                rack.connect(rackGain);
                rackGain.connect(ctx.destination);
                rack.type = 'sawtooth';
                rack.frequency.setValueAtTime(300, now + 1.0);
                rack.frequency.linearRampToValueAtTime(500, now + 1.15);
                rackGain.gain.setValueAtTime(0.2 * volume, now + 1.0);
                rackGain.gain.exponentialRampToValueAtTime(0.01 * volume, now + 1.15);
                rack.start(now + 1.0);
                rack.stop(now + 1.15);
            }

            // ==========================================
            // BULLET SOUND SYSTEM (Incoming enemy bullets)
            // ==========================================
            
            // Play bullet hit sound (when player gets hit by enemy bullet)
            // Randomly selects from hit.mp3 or hit2.mp3
            function playBulletHitSound(volume = 1) {
                const randomIndex = Math.floor(Math.random() * 2); // 0 or 1
                
                // Try media pool first (safe mode)
                if (bulletHitSoundMedias[randomIndex]) {
                    bulletHitSoundMedias[randomIndex].play(volume);
                    return;
                }
                
                // Try Web Audio buffer
                const buffer = bulletHitSoundBuffers[randomIndex];
                if (buffer) {
                    playSound(buffer, volume);
                    return;
                }
            }
            
            // Play bullet whiz/missed sound (when enemy bullet passes near player)
            // Randomly selects from missed0-4.mp3
            function playBulletWhizSound(volume = 1) {
                const randomIndex = Math.floor(Math.random() * 5); // 0-4
                
                // Try media pool first (safe mode)
                if (bulletMissedSoundMedias[randomIndex]) {
                    bulletMissedSoundMedias[randomIndex].play(volume);
                    return;
                }
                
                // Try Web Audio buffer
                const buffer = bulletMissedSoundBuffers[randomIndex];
                if (buffer) {
                    playSound(buffer, volume);
                    return;
                }
            }

            // Expose for code running in different <script> scopes (e.g., WebRTC handlers)
            window.playBulletHitSound = playBulletHitSound;
            window.playBulletWhizSound = playBulletWhizSound;

            // Play body shot sound (1-4.mp3 in sequence)
            function playBodyShotSound(volume = 1) {
                // Reset the sequence timer
                if (bodyShotResetTimer) {
                    clearTimeout(bodyShotResetTimer);
                }

                // Try to play the current body shot sound from the loaded buffers/media
                const soundMedia = bodyShotSoundMedias[currentBodyShotIndex];
                const soundBuffer = bodyShotSoundBuffers[currentBodyShotIndex];
                if (soundMedia) {
                    soundMedia.play(volume * 1.0);
                    console.log(`🔊 Body shot sound ${currentBodyShotIndex + 1}.mp3 played (media)`);
                } else if (soundBuffer) {
                    playSound(soundBuffer, volume * 1.0); // Full volume for body shots
                    console.log(`🔊 Body shot sound ${currentBodyShotIndex + 1}.mp3 played`);
                } else {
                    // Fallback to synthesized sound if not loaded
                    playHitSoundSynthesized(volume);
                }

                // Advance to next sound in sequence (loop 1->2->3->4->1)
                currentBodyShotIndex = (currentBodyShotIndex + 1) % 4;

                // Reset sequence after 2 seconds of no hits
                bodyShotResetTimer = setTimeout(() => {
                    currentBodyShotIndex = 0;
                    console.log('🔄 Body shot sequence reset');
                }, 2000);
            }

            // Play kill sound (body shot kill)
            function playKillSound(volume = 1) {
                // Randomly choose between killed.mp3 and killedmedal.mp3
                const useKilledMedal = Math.random() < 0.5;
                const soundBuffer = useKilledMedal ? killedMedalSoundBuffer : killedSoundBuffer;
                const soundMedia = useKilledMedal ? killedMedalSoundMedia : killedSoundMedia;

                if (soundMedia) {
                    soundMedia.play(volume * 0.8);
                    console.log(`🔊 Kill sound played (media): ${useKilledMedal ? 'killedmedal.mp3' : 'killed.mp3'}`);
                } else if (soundBuffer) {
                    playSound(soundBuffer, volume * 0.8);
                    console.log(`🔊 Kill sound played: ${useKilledMedal ? 'killedmedal.mp3' : 'killed.mp3'}`);
                }
            }

            // Play headshot kill sound
            function playHeadshotKillSound(volume = 1) {
                // Randomly choose between headshotdead1.mp3 and headshotdead2.mp3
                const useSecond = Math.random() < 0.5;
                const soundBuffer = useSecond ? headshotDead2SoundBuffer : headshotDead1SoundBuffer;
                const soundMedia = useSecond ? headshotDead2SoundMedia : headshotDead1SoundMedia;

                if (soundMedia) {
                    soundMedia.play(volume * 0.8);
                    console.log(`🔊 Headshot kill sound played (media): ${useSecond ? 'headshotdead2.mp3' : 'headshotdead1.mp3'}`);
                } else if (soundBuffer) {
                    playSound(soundBuffer, volume * 0.8);
                    console.log(`🔊 Headshot kill sound played: ${useSecond ? 'headshotdead2.mp3' : 'headshotdead1.mp3'}`);
                }
            }

            // Original synthesized hit sound (fallback)
            function playHitSoundSynthesized(volume = 1) {
                const ctx = ensureAudioContext();
                if (!ctx) return;

                const oscillator = ctx.createOscillator();
                const gainNode = ctx.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(ctx.destination);

                oscillator.frequency.setValueAtTime(800, ctx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(400, ctx.currentTime + 0.05);
                gainNode.gain.setValueAtTime(0.2 * volume, ctx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01 * volume, ctx.currentTime + 0.05);

                oscillator.start(ctx.currentTime);
                oscillator.stop(ctx.currentTime + 0.05);
            }

            // Main hit sound function - now uses body shot sounds
            function playHitSound(volume = 1) {
                playBodyShotSound(volume);
            }

            // Expose sound functions to window scope for use in handleNetworkData
            window.playKillSound = playKillSound;
            window.playHeadshotKillSound = playHeadshotKillSound;
            window.playBodyShotSound = playBodyShotSound;
            window.playHitSound = playHitSound;

            // Distance-based volume calculation function
            function calculateDistanceVolume(sourcePosition, maxDistance = 30, minVolume = 0.05) {
                if (!sourcePosition) return 1; // Default to full volume if no position

                const distance = camera.position.distanceTo(sourcePosition);
                // Use more aggressive exponential falloff for quieter distant sounds
                const falloffRate = 2.5; // Higher value = faster falloff
                let volume = Math.exp(-(distance / maxDistance) * falloffRate);
                volume = Math.max(minVolume, Math.min(1, volume)); // Clamp volume between minVolume and 1

                return volume;
            }

            // Real-time enemy sound volume updates
            function updateEnemySoundVolumes() {
                if (!enemy || !enemy.visible) return;

                const distance = camera.position.distanceTo(enemy.position);
                const volume = calculateDistanceVolume(enemy.position);

                // Store the current volume for enemy sounds
                if (!gameState.enemySoundVolume) {
                    gameState.enemySoundVolume = volume;
                } else {
                    // Smooth volume transitions to avoid abrupt changes
                    gameState.enemySoundVolume = THREE.MathUtils.lerp(gameState.enemySoundVolume, volume, 0.1);
                }
            }

            function playFootstepSound(volume = 1) {
                const ctx = ensureAudioContext();
                if (!ctx) return;

                const oscillator = ctx.createOscillator();
                const gainNode = ctx.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(ctx.destination);

                // Use 'sawtooth' instead of 'brown' (which is not valid)
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(80, ctx.currentTime);
                gainNode.gain.setValueAtTime(0.05 * volume, ctx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01 * volume, ctx.currentTime + 0.1);

                oscillator.start(ctx.currentTime);
                oscillator.stop(ctx.currentTime + 0.1);
            }

            function playSlideSound(volume = 1) {
                const ctx = ensureAudioContext();
                if (!ctx) return;

                const oscillator = ctx.createOscillator();
                const gainNode = ctx.createGain();
                const filter = ctx.createBiquadFilter();

                oscillator.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(ctx.destination);

                oscillator.type = 'sawtooth';
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(300, ctx.currentTime);
                filter.frequency.linearRampToValueAtTime(150, ctx.currentTime + 0.8);

                oscillator.frequency.setValueAtTime(60, ctx.currentTime);
                gainNode.gain.setValueAtTime(0.15 * volume, ctx.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.08 * volume, ctx.currentTime + 0.8);
                gainNode.gain.exponentialRampToValueAtTime(0.01 * volume, ctx.currentTime + 0.9);

                oscillator.start(ctx.currentTime);
                oscillator.stop(ctx.currentTime + 0.9);
            }

            // Weapon System - BALANCED for longer fights
            const weapons = {
                rifle: {
                    name: 'AK-47',
                    damage: 8,  // Reduced from 30 - needs ~12 shots to kill
                    fireRate: 100,
                    maxAmmo: 30,
                    reserveAmmo: 90,
                    reloadTime: 2000,
                    type: 'rifle'
                },
                pistol: {
                    name: 'Desert Eagle',
                    damage: 15,  // Reduced from 50 - needs ~7 shots to kill
                    fireRate: 300,
                    maxAmmo: 7,
                    reserveAmmo: 35,
                    reloadTime: 1500,
                    type: 'pistol'
                },
                sniper: {
                    name: 'AWP',
                    damage: 35,  // Reduced from 100 - needs 3 shots to kill
                    fireRate: 1000,
                    maxAmmo: 5,
                    reserveAmmo: 20,
                    reloadTime: 2500,
                    type: 'sniper'
                },
                smg: {
                    name: 'MP5',
                    damage: 6,  // Reduced from 22 - needs ~17 shots to kill
                    fireRate: 75,
                    maxAmmo: 30,
                    reserveAmmo: 120,
                    reloadTime: 1800,
                    type: 'smg'
                }
            };

            // Enhanced Camera Shake System with Perlin Noise (Realistic Settings)
            const cameraShake = {
                intensity: 0,
                targetIntensity: 0,
                decay: 0.88, // Faster decay for more realistic feel
                offsetX: 0,
                offsetY: 0,
                offsetZ: 0,
                rotationX: 0,
                rotationY: 0,
                time: 0,
                shakePattern: 'default', // 'default', 'rifle', 'pistol', 'sniper'
                smoothOffsetX: 0,
                smoothOffsetY: 0,
                smoothOffsetZ: 0,
                smoothRotationX: 0,
                smoothRotationY: 0
            };

            // Simple Perlin-like noise for smooth shake
            function noise(x, y) {
                const n = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
                return (n - Math.floor(n)) * 2 - 1;
            }

            // Smooth interpolation
            function lerp(a, b, t) {
                return a + (b - a) * t;
            }

            function applyCameraShake(intensity, pattern = 'default') {
                // Camera shake disabled
                return;
            }

            function updateCameraShake(deltaTime) {
                // Camera shake disabled
                return;

                // Only increment time when there's actual shake happening (slower for realism)
                if (cameraShake.intensity > 0.001) {
                    cameraShake.time += deltaTime * 15; // Reduced from 20 for more natural feel

                    // Use Perlin-like noise for smoother shake
                    const noiseX = noise(cameraShake.time, 0);
                    const noiseY = noise(0, cameraShake.time);
                    const noiseZ = noise(cameraShake.time * 0.5, cameraShake.time * 0.5);
                    const noiseRotX = noise(cameraShake.time * 1.5, 0);
                    const noiseRotY = noise(0, cameraShake.time * 1.5);

                    // Weapon-specific shake patterns (more realistic, less exaggerated)
                    let shakeMultiplier = 1.0;
                    let rotationMultiplier = 1.0;
                    let frequency = 1.0;

                    switch (cameraShake.shakePattern) {
                        case 'rifle':
                            // Moderate, controlled shake for rifle
                            frequency = 1.2;
                            shakeMultiplier = 0.6;
                            rotationMultiplier = 0.5;
                            break;
                        case 'pistol':
                            // Quick, snappy but subtle shake
                            frequency = 1.5;
                            shakeMultiplier = 0.5;
                            rotationMultiplier = 0.6;
                            break;
                        case 'sniper':
                            // Heavy but controlled shake
                            frequency = 0.6;
                            shakeMultiplier = 0.8;
                            rotationMultiplier = 0.7;
                            break;
                        default:
                            // Default subtle shake
                            frequency = 1.0;
                            shakeMultiplier = 0.4;
                            rotationMultiplier = 0.4;
                            break;
                    }

                    // Calculate shake offsets with smooth noise (reduced multipliers for realism)
                    const targetOffsetX = noiseX * cameraShake.intensity * shakeMultiplier * frequency * 0.6;
                    const targetOffsetY = noiseY * cameraShake.intensity * shakeMultiplier * frequency * 0.6;
                    const targetOffsetZ = noiseZ * cameraShake.intensity * 0.3 * shakeMultiplier;
                    const targetRotX = noiseRotX * cameraShake.intensity * 0.015 * rotationMultiplier;
                    const targetRotY = noiseRotY * cameraShake.intensity * 0.015 * rotationMultiplier;

                    // Smooth interpolation for less jittery shake (more responsive for realism)
                    cameraShake.smoothOffsetX = lerp(cameraShake.smoothOffsetX, targetOffsetX, 0.4);
                    cameraShake.smoothOffsetY = lerp(cameraShake.smoothOffsetY, targetOffsetY, 0.4);
                    cameraShake.smoothOffsetZ = lerp(cameraShake.smoothOffsetZ, targetOffsetZ, 0.4);
                    cameraShake.smoothRotationX = lerp(cameraShake.smoothRotationX, targetRotX, 0.4);
                    cameraShake.smoothRotationY = lerp(cameraShake.smoothRotationY, targetRotY, 0.4);

                    // Apply smoothed values
                    cameraShake.offsetX = cameraShake.smoothOffsetX;
                    cameraShake.offsetY = cameraShake.smoothOffsetY;
                    cameraShake.offsetZ = cameraShake.smoothOffsetZ;
                    cameraShake.rotationX = cameraShake.smoothRotationX;
                    cameraShake.rotationY = cameraShake.smoothRotationY;

                    // Exponential decay with curve
                    const decayRate = cameraShake.decay + (1 - cameraShake.decay) * (1 - cameraShake.intensity);
                    cameraShake.intensity *= decayRate;
                    cameraShake.targetIntensity *= decayRate;
                } else {
                    // Force immediate reset when intensity is zero
                    cameraShake.smoothOffsetX = lerp(cameraShake.smoothOffsetX, 0, 0.5);
                    cameraShake.smoothOffsetY = lerp(cameraShake.smoothOffsetY, 0, 0.5);
                    cameraShake.smoothOffsetZ = lerp(cameraShake.smoothOffsetZ, 0, 0.5);
                    cameraShake.smoothRotationX = lerp(cameraShake.smoothRotationX, 0, 0.5);
                    cameraShake.smoothRotationY = lerp(cameraShake.smoothRotationY, 0, 0.5);

                    cameraShake.offsetX = cameraShake.smoothOffsetX;
                    cameraShake.offsetY = cameraShake.smoothOffsetY;
                    cameraShake.offsetZ = cameraShake.smoothOffsetZ;
                    cameraShake.rotationX = cameraShake.smoothRotationX;
                    cameraShake.rotationY = cameraShake.smoothRotationY;

                    // Force zero when close enough
                    if (Math.abs(cameraShake.offsetX) < 0.0001 &&
                        Math.abs(cameraShake.offsetY) < 0.0001 &&
                        Math.abs(cameraShake.offsetZ) < 0.0001 &&
                        Math.abs(cameraShake.rotationX) < 0.0001 &&
                        Math.abs(cameraShake.rotationY) < 0.0001) {
                        cameraShake.intensity = 0;
                        cameraShake.targetIntensity = 0;
                        cameraShake.time = 0;
                        cameraShake.offsetX = 0;
                        cameraShake.offsetY = 0;
                        cameraShake.offsetZ = 0;
                        cameraShake.rotationX = 0;
                        cameraShake.rotationY = 0;
                        cameraShake.smoothOffsetX = 0;
                        cameraShake.smoothOffsetY = 0;
                        cameraShake.smoothOffsetZ = 0;
                        cameraShake.smoothRotationX = 0;
                        cameraShake.smoothRotationY = 0;
                    }
                }
            }

            // Game State - preserve existing lobby data (playerUsername, otherPlayerUsername, etc.)
            const preservedUsername = gameState?.playerUsername || '';
            const preservedOtherUsername = gameState?.otherPlayerUsername || '';
            const preservedOtherLevel = gameState?.otherPlayerLevel || 1;
            const preservedOtherAvatar = gameState?.otherPlayerAvatar || null;
            const preservedOtherSkin = gameState?.otherPlayerSkin || 'soldier';

            gameState = {
                started: false,
                paused: false,
                isDying: false,
                deathTimer: 0,
                pendingFadeTimeout: null,
                playerHealth: 100,
                enemyHealth: 100,
                playerScore: 0,
                enemyScore: 0,
                currentWeapon: 'rifle',
                currentAmmo: 30,
                reserveAmmo: 90,
                maxAmmo: 30,
                isReloading: false,
                canShoot: true,
                isMoving: false,
                wasMoving: false,
                movementSpeed: 0,
                targetMovementSpeed: 0,
                headBob: 0,
                headBobPhase: 0,
                footstepTimer: 0,
                landingTimer: 0,
                baseHeight: 1.7,
                currentHeight: 1.7,
                velocityY: 0,
                onGround: true,
                lean: 0,
                leanTarget: 0,
                isJumping: false,
                velocityY: 0,
                isSprinting: false,
                playerUsername: preservedUsername,
                otherPlayerUsername: preservedOtherUsername,
                otherPlayerLevel: preservedOtherLevel,
                otherPlayerAvatar: preservedOtherAvatar,
                otherPlayerSkin: preservedOtherSkin,
                isSliding: false,
                slideTimer: 0,
                slideDuration: 0.9,
                slideSpeed: 16,
                slideDirection: null, // Will be set after THREE is confirmed loaded
                slideCooldown: 0,
                slideStartHeight: 1.7,
                targetSlideHeight: 0.5,
                isRecoveringFromSlide: false,
                slideRecoveryTimer: 0,
                slideRecoveryStartHeight: 0.5,
                slideVelocity: 0,
                preSlideMomentum: 0,
                slideCameraTilt: 0,
                slideHeadBob: 0,
                deathPosition: null, // Will be set after THREE is confirmed loaded
                killerPosition: null, // Will be set after THREE is confirmed loaded
                killerGlowMeshes: null,
                killerGlowSource: null,
                weaponVisible: true,
                // Uncharted 3 Near-Death Effect state
                trauma: 0,
                traumaTarget: 0,
                healingDelay: 0
            };

            // Initialize THREE.Vector3 properties after confirming THREE is loaded
            if (typeof THREE !== 'undefined') {
                gameState.slideDirection = new THREE.Vector3();
                gameState.deathPosition = new THREE.Vector3();
                gameState.killerPosition = new THREE.Vector3();
            }

            console.log('🎮 Game state initialized');

            // Three.js Setup with Ultra Graphics
            scene = new THREE.Scene();
            console.log('🎮 Scene created');

            // Run any tasks that were scheduled before initGame created the scene
            _flushSceneReadyQueue();

            if (window.LoadingScreen) {
                LoadingScreen.assetLoaded('scene');
                LoadingScreen.setStatus('INITIALIZING RENDERER...');
            }

            scene.fog = new THREE.Fog(0x87CEEB, 30, 150); // Light blue fog for outdoor feel
            // Background will be set by HDR environment loader

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            window.camera = camera; // Expose for voice chat distance calculation

            /* =========================================
               DYNAMIC AMBIENCE SYSTEM
               ========================================= */
            const AmbienceSystem = {
                listener: null,
                _started: false,
                tracks: {
                    base: { path: 'sound-effects/01HX9E95F7WZ9QWERBKSCRJFPT.mp3', audio: null, maxVol: 0.35, loop: true },
                    zoneA: { path: 'sound-effects/01HX9JD4QCXEGBW5H5KDS1GW23.mp3', audio: null, maxVol: 0.35, loop: true, pos: new THREE.Vector3(60, 0, 80) },
                    zoneB: { path: 'sound-effects/01HYDYMA5SBT21XZV380EM8S12.mp3', audio: null, maxVol: 0.35, loop: true, pos: new THREE.Vector3(-60, 0, -80) }
                },
                init: function (cam) {
                    this.listener = new THREE.AudioListener();
                    cam.add(this.listener);
                    const loader = new THREE.AudioLoader();
                    
                    const load = (key, autoplay) => {
                        const t = this.tracks[key];
                        loader.load(t.path, (buffer) => {
                            const sound = new THREE.Audio(this.listener);
                            sound.setBuffer(buffer);
                            sound.setLoop(t.loop);
                            sound.setVolume(0);
                            t.audio = sound;
                            console.log(`🎵 Ambience loaded: ${key}`);
                        });
                    };
                    
                    // Load and start all (volumes controlled by update)
                    load('base', false);
                    load('zoneA', false);
                    load('zoneB', false);
                },
                _ensurePlaying: function() {
                    if (this._started) return;
                    for (const key in this.tracks) {
                        const t = this.tracks[key];
                        if (t && t.audio && !t.audio.isPlaying) {
                            try { t.audio.play(); } catch (e) { }
                        }
                    }
                    this._started = true;
                },
                update: function (camPos) {
                    if (!this.tracks.base.audio || !this.tracks.zoneA.audio || !this.tracks.zoneB.audio) return;
                    
                    // Zone Influence Logic: Simple smooth Proximity
                    const radius = 90; // Overlap radius
                    
                    // Distances
                    const distA = camPos.distanceTo(this.tracks.zoneA.pos);
                    const distB = camPos.distanceTo(this.tracks.zoneB.pos);
                    
                    // Calculate raw weights (0 to 1)
                    let wA = Math.max(0, 1 - (distA / radius));
                    let wB = Math.max(0, 1 - (distB / radius));
                    
                    // Smoothstep for "very smooth" feel
                    wA = wA * wA * (3 - 2 * wA);
                    wB = wB * wB * (3 - 2 * wB);
                    
                    // Base acts as the "filler" or "night sound" when not in special zones
                    let wBase = Math.max(0, 1.0 - (wA + wB)); 
                    
                    this.tracks.base.audio.setVolume(wBase * this.tracks.base.maxVol);
                    this.tracks.zoneA.audio.setVolume(wA * this.tracks.zoneA.maxVol);
                    this.tracks.zoneB.audio.setVolume(wB * this.tracks.zoneB.maxVol);
                },
                resume: function() {
                    if (this.listener && this.listener.context.state === 'suspended') {
                        this.listener.context.resume().then(() => this._ensurePlaying()).catch(() => {});
                    } else {
                        this._ensurePlaying();
                    }
                }
            };
            window.AmbienceSystem = AmbienceSystem;
            // Init immediately
            AmbienceSystem.init(camera);

            /* =========================================
               UI SOUND SYSTEM (MENU)
               ========================================= */
            const UISoundSystem = {
                hoverSound: new Audio('menu-sound/01HYAG2FJGXVK4G544HXB2EP2D.mp3'),
                clickSound: new Audio('menu-sound/01HYAG2FS4FM00HS3T2YGJT9FQ.mp3'),
                init: function() {
                    this.hoverSound.volume = 0.25;
                    this.clickSound.volume = 0.4;
                    
                    // Simple debounce for hover to prevent rapid firing
                    let lastHoverTime = 0;
                    
                    // Event Delegation
                    const handleEvent = (e, type) => {
                        // Check if target matches desired UI elements
                        if (e.target.closest('button, .menu-button, input, select, .map-option, .skin-option, .emote-button')) {
                            // Only trigger once per element hover (mouseover bubbles, so closest ensures we stay on main element)
                            // But for mouseover we need to be careful not to spam when moving between children
                            
                            if (type === 'hover') {
                                const now = performance.now();
                                if (now - lastHoverTime > 50) { // 50ms throttle
                                    this.hoverSound.currentTime = 0;
                                    this.hoverSound.play().catch(() => {});
                                    lastHoverTime = now;
                                }
                            } else if (type === 'click') {
                                this.clickSound.currentTime = 0;
                                this.clickSound.play().catch(() => {});
                            }
                        }
                    };

                    document.body.addEventListener('mouseover', (e) => handleEvent(e, 'hover'));
                    document.body.addEventListener('click', (e) => handleEvent(e, 'click'));
                    
                    console.log('🔊 UI Sound System Initialized');
                }
            };
            UISoundSystem.init();

            // High-quality renderer setup
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                powerPreference: "high-performance",
                alpha: false,
                stencil: false
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            // Optimized shadows - manual update only when needed
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.shadowMap.autoUpdate = false; // PERF: Manual updates only
            renderer.shadowMap.needsUpdate = true; // Initial update

            // HDR Tone Mapping for realistic lighting
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2; // Slightly brighter for outdoor HDR
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.body.appendChild(renderer.domElement);

            // Update loading progress
            if (window.LoadingScreen) {
                LoadingScreen.assetLoaded('renderer');
                LoadingScreen.setStatus('LOADING ENVIRONMENT...');
            }

            // Load HDR Environment Map for realistic lighting and reflections
            const exrLoader = new THREE.EXRLoader();
            exrLoader.load('minedump_flats_2k.exr', function (texture) {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                // Keep HDR for lighting/reflections but don't show as background
                // scene.background = texture; // HIDDEN - using gray background instead
                scene.environment = texture; // Keep for realistic lighting
                console.log('✅ HDR Environment loaded (lighting only, gray background)');
                if (window.LoadingScreen) {
                    LoadingScreen.assetLoaded('hdr_environment');
                    LoadingScreen.setStatus('COMPILING SHADERS...');
                }
            }, undefined, function (error) {
                console.warn('⚠️ Failed to load HDR, using fallback sky color');
                scene.background = new THREE.Color(0x87CEEB); // Sky blue fallback
                if (window.LoadingScreen) {
                    LoadingScreen.assetLoaded('hdr_environment');
                    LoadingScreen.setStatus('COMPILING SHADERS...');
                }
            });

            // Depth of Field System
            let previousCameraPosition = new THREE.Vector3();
            let previousCameraQuaternion = new THREE.Quaternion();

            // Create render targets for post-processing
            const renderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat,
                stencilBuffer: false
            });

            const depthRenderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, {
                minFilter: THREE.NearestFilter,
                magFilter: THREE.NearestFilter,
                format: THREE.RGBAFormat
            });

            // Custom Depth of Field + Motion Blur Shader + Near-Death Effect (Uncharted 3 Style)
            const postProcessMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    tDiffuse: { value: null },
                    tDepth: { value: null },
                    cameraNear: { value: camera.near },
                    cameraFar: { value: camera.far },
                    focusDistance: { value: 20.0 },
                    focalLength: { value: 0.03 },
                    bokehScale: { value: 0.6 },
                    enableDOF: { value: 0.0 },
                    resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                    // Uncharted 3 Near-Death Effect uniforms
                    uTrauma: { value: 0.0 },
                    uTime: { value: 0.0 }
                },
                vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
                fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform sampler2D tDepth;
                uniform float cameraNear;
                uniform float cameraFar;
                uniform float focusDistance;
                uniform float focalLength;
                uniform float bokehScale;
                uniform float enableDOF;
                uniform vec2 resolution;
                // Uncharted 3 Near-Death Effect
                uniform float uTrauma;
                uniform float uTime;
                varying vec2 vUv;
                
                // Noise functions for effects
                float rand(vec2 n) { return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }
                float noise(vec2 p) {
                    vec2 ip = floor(p);
                    vec2 u = fract(p);
                    u = u*u*(3.0-2.0*u);
                    float res = mix(
                        mix(rand(ip), rand(ip+vec2(1.0,0.0)), u.x),
                        mix(rand(ip+vec2(0.0,1.0)), rand(ip+vec2(1.0,1.0)), u.x), u.y);
                    return res*res;
                }
                
                // Film grain / numb noise effect
                float filmGrain(vec2 uv, float time) {
                    float grain = rand(uv * 1000.0 + fract(time * 24.0));
                    return grain;
                }
                
                // Correct depth unpacking from depth texture
                float readDepth(vec2 uv) {
                    vec4 depthColor = texture2D(tDepth, uv);
                    float depth = depthColor.r;
                    
                    // Convert from normalized depth to linear depth
                    float z = depth * 2.0 - 1.0;
                    float linearDepth = (2.0 * cameraNear * cameraFar) / (cameraFar + cameraNear - z * (cameraFar - cameraNear));
                    return linearDepth;
                }
                
                float getBlurAmount(float depth) {
                    float diff = abs(depth - focusDistance);
                    float blur = diff * focalLength;
                    return clamp(blur, 0.0, bokehScale);
                }
                
                vec4 applyDOF(vec2 uv, vec4 originalColor) {
                    if (enableDOF < 0.5) {
                        return originalColor;
                    }
                    
                    float centerDepth = readDepth(uv);
                    float blur = getBlurAmount(centerDepth);
                    
                    // Only blur if blur amount is significant
                    if (blur < 0.05) {
                        return originalColor;
                    }
                    
                    vec4 color = vec4(0.0);
                    float total = 0.0;
                    float radius = blur * 0.005;
                    
                    // Simple blur pattern
                    for (float angle = 0.0; angle < 6.28318; angle += 0.785) {
                        for (float dist = 0.2; dist <= 1.0; dist += 0.4) {
                            vec2 offset = vec2(cos(angle), sin(angle)) * radius * dist;
                            color += texture2D(tDiffuse, uv + offset);
                            total += 1.0;
                        }
                    }
                    
                    color += originalColor * 2.0;
                    total += 2.0;
                    
                    return color / total;
                }
                
                void main() {
                    // Start with original color
                    vec4 color = texture2D(tDiffuse, vUv);
                    
                    // Apply Depth of Field
                    color = applyDOF(vUv, color);
                    
                    // ========== UNCHARTED 3 NEAR-DEATH EFFECT ==========
                    // Matches the iconic Uncharted 3 near-death visual style
                    float tFactor = smoothstep(0.40, 1.0, uTrauma); // Starts LATER (at ~60 health) instead of 80
                    
                    if (tFactor > 0.01) {
                        // Distance from screen center
                        vec2 distVec = vUv - 0.5;
                        float dist = length(distVec);
                        
                        // Luminance for desaturation
                        float luma = dot(color.rgb, vec3(0.299, 0.587, 0.114));
                        vec3 grey = vec3(luma);
                        
                        // 1. HEAVY GLOBAL DESATURATION - like Uncharted 3
                        // Stronger desaturation at edges, but also affects center
                        float centerProtect = smoothstep(0.0, 0.35, dist); // Protect center slightly
                        float globalDesat = tFactor * 0.70; // LESS AGGRESSIVE GRAYSCALE (was 0.90)
                        float edgeDesat = smoothstep(0.2, 0.6, dist) * tFactor * 0.18; // Slightly more at edges
                        float totalDesat = globalDesat * (0.5 + centerProtect * 0.5) + edgeDesat;
                        totalDesat = clamp(totalDesat, 0.0, 0.75); // Cap max desat (was 0.97)
                        color.rgb = mix(color.rgb, grey, totalDesat);
                        
                        // 2. DARK RED BLOOD VIGNETTE - creeping from edges
                        float bloodNoise = noise(vUv * 6.0 + uTime * 0.02);
                        float bloodNoise2 = noise(vUv * 12.0 - uTime * 0.03);
                        
                        // Organic blood shape that creeps inward with more trauma
                        float bloodEdge = 0.55 - tFactor * 0.25; // Blood creeps further in as trauma increases
                        float bloodShape = smoothstep(bloodEdge, 0.75, dist + bloodNoise * 0.12 + bloodNoise2 * 0.08);
                        
                        // Dark, desaturated blood red (like Uncharted 3)
                        vec3 bloodColor = vec3(0.35, 0.02, 0.02);
                        
                        // Blood intensity increases with trauma
                        // REDUCED OPACITY for "less aggressive" look
                        float bloodAlpha = bloodShape * tFactor * 0.40;
                        bloodAlpha = clamp(bloodAlpha, 0.0, 0.45);
                        
                        // Blend blood - multiply for darker edges
                        color.rgb = mix(color.rgb, color.rgb * bloodColor * 2.5, bloodAlpha * 0.35);
                        color.rgb = mix(color.rgb, bloodColor, bloodAlpha * 0.25);
                        
                        // 3. CONTRAST REDUCTION - washed out feel
                        float contrastLoss = tFactor * 0.15;
                        color.rgb = mix(color.rgb, vec3(0.5), contrastLoss);
                        
                        // 4. EDGE DARKNESS - tunnel vision
                        float darkVignette = smoothstep(0.3, 0.8, dist) * tFactor * 0.4;
                        color.rgb *= (1.0 - darkVignette);
                        
                        // 5. HEARTBEAT PULSE when critically low (trauma > 60%)
                        if (uTrauma > 0.6) {
                            float heartbeat = pow(sin(uTime * 4.0) * 0.5 + 0.5, 8.0); // Sharp pulse
                            float pulseIntensity = (uTrauma - 0.6) * heartbeat * 0.08;
                            // Pulse darkens and slightly reddens
                            color.rgb *= (1.0 - pulseIntensity);
                            color.r += pulseIntensity * 0.06;
                        }
                    }
                    // ========== END NEAR-DEATH EFFECT ==========
                    
                    gl_FragColor = color;
                }
            `
            });

            // Screen quad for post-processing
            const postProcessQuad = new THREE.Mesh(
                new THREE.PlaneGeometry(2, 2),
                postProcessMaterial
            );
            const postProcessScene = new THREE.Scene();
            postProcessScene.add(postProcessQuad);
            const postProcessCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

            // Depth material for depth pass
            const depthMaterial = new THREE.MeshDepthMaterial();
            depthMaterial.depthPacking = THREE.RGBADepthPacking;
            depthMaterial.blending = THREE.NoBlending;

            // Update loading progress - shaders compiled
            console.log('✅ Shaders compiled');
            if (window.LoadingScreen) {
                LoadingScreen.assetLoaded('shaders');
                LoadingScreen.setStatus('SETTING UP LIGHTING...');
            }

            // Separate scene and camera for weapon rendering (overlay)
            weaponScene = new THREE.Scene();
            // NO BACKGROUND - transparent so main scene shows through
            weaponScene.background = null;

            weaponCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 10);

            // CRITICAL: Add weapon camera to weapon scene so its children render!
            weaponScene.add(weaponCamera);

            // If a weapon switch happened before weaponCamera existed, replay it now
            if (_pendingWeaponType) {
                const pendingType = _pendingWeaponType;
                _pendingWeaponType = null;
                try {
                    switchWeaponModel(pendingType);
                } catch (e) {
                    console.warn('⚠️ Deferred weapon switch failed:', e);
                }
            }

            // Add lights to weapon scene for proper lighting
            const weaponLight = new THREE.DirectionalLight(0xffffff, 1.5);
            weaponLight.position.set(1, 1, 1);
            weaponScene.add(weaponLight);

            const weaponAmbient = new THREE.AmbientLight(0xffffff, 0.6);
            weaponScene.add(weaponAmbient);

            // Bright, Visible Lighting System
            const ambientLight = new THREE.AmbientLight(0xffeedd, 0.4);  // Warm ambient
            scene.add(ambientLight);

            // Main directional light - warm sun-like
            const mainLight = new THREE.DirectionalLight(0xfff5e6, 1.5);
            mainLight.position.set(10, 25, 10);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            mainLight.shadow.camera.near = 0.5;
            mainLight.shadow.camera.far = 100;
            mainLight.shadow.camera.left = -35;
            mainLight.shadow.camera.right = 35;
            mainLight.shadow.camera.top = 35;
            mainLight.shadow.camera.bottom = -35;
            mainLight.shadow.bias = -0.0001;
            scene.add(mainLight);

            // Secondary directional light for fill - cooler
            const fillDirectional = new THREE.DirectionalLight(0xe6f0ff, 0.5);
            fillDirectional.position.set(-10, 20, -10);
            scene.add(fillDirectional);

            // Warm warehouse ceiling lights - industrial orange glow
            const ceilingLight1 = new THREE.PointLight(0xffaa55, 2.5, 45);
            ceilingLight1.position.set(-15, 10, -15);
            ceilingLight1.castShadow = true;
            ceilingLight1.shadow.mapSize.width = 1024;
            ceilingLight1.shadow.mapSize.height = 1024;
            scene.add(ceilingLight1);

            const ceilingLight2 = new THREE.PointLight(0xffaa55, 2.5, 45);
            ceilingLight2.position.set(15, 10, 15);
            ceilingLight2.castShadow = true;
            ceilingLight2.shadow.mapSize.width = 1024;
            ceilingLight2.shadow.mapSize.height = 1024;
            scene.add(ceilingLight2);

            const ceilingLight3 = new THREE.PointLight(0xfff0dd, 2.0, 50);
            ceilingLight3.position.set(0, 12, 0);
            ceilingLight3.castShadow = true;
            ceilingLight3.shadow.mapSize.width = 1024;
            ceilingLight3.shadow.mapSize.height = 1024;
            scene.add(ceilingLight3);

            // Additional fill lights for better visibility
            const fillLight1 = new THREE.PointLight(0x8888ff, 2.0, 40);
            fillLight1.position.set(-20, 8, 0);
            scene.add(fillLight1);

            const fillLight2 = new THREE.PointLight(0xff8888, 2.0, 40);
            fillLight2.position.set(20, 8, 0);
            scene.add(fillLight2);

            // Ground fill light to prevent dark floor
            const groundLight = new THREE.PointLight(0xaaaaaa, 1.5, 60);
            groundLight.position.set(0, 2, 0);
            scene.add(groundLight);

            // Add visible light sources
            const lightSphere1 = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0xffaa44 })
            );
            lightSphere1.position.copy(ceilingLight1.position);
            scene.add(lightSphere1);

            const lightSphere2 = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0xffaa44 })
            );
            lightSphere2.position.copy(ceilingLight2.position);
            scene.add(lightSphere2);

            const lightSphere3 = new THREE.Mesh(
                new THREE.SphereGeometry(0.4, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            lightSphere3.position.copy(ceilingLight3.position);
            scene.add(lightSphere3);

            // Update loading progress - lighting setup complete
            console.log('✅ Lighting setup complete');
            if (window.LoadingScreen) {
                LoadingScreen.assetLoaded('lighting');
                LoadingScreen.setStatus('LOADING MAP...');
            }

            // Arrays for collision detection (must be declared before map creation)
            const boxes = [];
            const walls = [];
            let floor = null; // Will be set by map creation

            // Store map objects for potential cleanup
            let mapObjects = [];

            // OBJ map collision meshes (for raycasting)
            let objCollisionMeshes = [];
            let mapBounds = { minX: -30, maxX: 30, minZ: -30, maxZ: 30 }; // Default warehouse bounds

            // Raycaster for OBJ collision detection
            const collisionRaycaster = new THREE.Raycaster();
            // PERF: Cached direction vectors for raycasting
            const _collisionDownVec = new THREE.Vector3(0, -1, 0);
            const _collisionRayOrigin = new THREE.Vector3();

            // Function to load OBJ map (map1)
            function loadOBJMap(mapPath, onComplete) {
                console.log('🗺️ Loading OBJ map from:', mapPath);

                const mtlLoader = new THREE.MTLLoader();
                mtlLoader.setPath(mapPath + '/source/');

                mtlLoader.load('unityexport.mtl', function (materials) {
                    materials.preload();
                    console.log('📦 MTL materials loaded');

                    const objLoader = new THREE.OBJLoader();
                    objLoader.setMaterials(materials);
                    objLoader.setPath(mapPath + '/source/');

                    objLoader.load('unityexport.obj', function (object) {
                        console.log('✅ OBJ map loaded successfully');

                        // Scale and position the map (Unity scale may need adjustment)
                        object.scale.set(1, 1, 1);
                        object.position.set(0, 0, 0);

                        // Calculate map bounds from geometry
                        const boundingBox = new THREE.Box3();

                        // Define nice materials for the map
                        const orangeMaterial = new THREE.MeshStandardMaterial({
                            color: 0xff8800,
                            roughness: 0.6,
                            metalness: 0.1
                        });
                        const greyMaterial = new THREE.MeshStandardMaterial({
                            color: 0x888888,
                            roughness: 0.8,
                            metalness: 0.05
                        });
                        const floorMaterial = new THREE.MeshStandardMaterial({
                            color: 0xcccccc,
                            roughness: 0.9,
                            metalness: 0.0
                        });

                        // Enable shadows and apply materials
                        object.traverse(function (child) {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;

                                // Compute bounding box for this mesh
                                child.geometry.computeBoundingBox();
                                const meshBox = child.geometry.boundingBox.clone();
                                meshBox.applyMatrix4(child.matrixWorld);
                                boundingBox.union(meshBox);

                                // Apply materials based on material name or position
                                const matName = child.material ? child.material.name : '';
                                if (matName.toLowerCase().includes('orange')) {
                                    child.material = orangeMaterial;
                                } else if (matName.toLowerCase().includes('grey') || matName.toLowerCase().includes('gray')) {
                                    child.material = greyMaterial;
                                } else {
                                    // Check if it's a floor (mostly horizontal, low Y position)
                                    const center = new THREE.Vector3();
                                    meshBox.getCenter(center);
                                    if (center.y < 1) {
                                        child.material = floorMaterial;
                                    } else {
                                        // Random variation for walls/objects
                                        const hue = 0.08 + Math.random() * 0.05; // Orange-ish
                                        child.material = new THREE.MeshStandardMaterial({
                                            color: new THREE.Color().setHSL(hue, 0.7, 0.5),
                                            roughness: 0.7,
                                            metalness: 0.1
                                        });
                                    }
                                }

                                // Add to OBJ collision meshes for raycasting
                                objCollisionMeshes.push(child);
                                mapObjects.push(child);
                            }
                        });

                        // Set map bounds based on geometry (with some padding inward)
                        mapBounds = {
                            minX: boundingBox.min.x + 1,
                            maxX: boundingBox.max.x - 1,
                            minZ: boundingBox.min.z + 1,
                            maxZ: boundingBox.max.z - 1
                        };
                        console.log('📐 Map bounds calculated:', mapBounds);

                        scene.add(object);
                        loadedMapMesh = object;
                        mapObjects.push(object);

                        // Don't create a separate floor - the OBJ should have its own floor
                        // But we need a large invisible floor for raycasting ground detection
                        const objFloorGeometry = new THREE.PlaneGeometry(200, 200);
                        const objFloorMaterial = new THREE.MeshBasicMaterial({
                            visible: false // Invisible floor for ground detection only
                        });
                        floor = new THREE.Mesh(objFloorGeometry, objFloorMaterial);
                        floor.rotation.x = -Math.PI / 2;
                        floor.position.y = 0;
                        floor.name = 'groundPlane';
                        scene.add(floor);
                        mapObjects.push(floor);

                        if (onComplete) onComplete();

                    }, function (xhr) {
                        console.log('Loading OBJ: ' + (xhr.loaded / xhr.total * 100).toFixed(0) + '%');
                    }, function (error) {
                        console.error('❌ Error loading OBJ map:', error);
                        // Fallback to default map
                        createDefaultMap();
                        if (onComplete) onComplete();
                    });

                }, function (xhr) {
                    console.log('Loading MTL: ' + (xhr.loaded / xhr.total * 100).toFixed(0) + '%');
                }, function (error) {
                    console.error('❌ Error loading MTL, trying OBJ without materials:', error);
                    // Try loading OBJ without MTL
                    const objLoader = new THREE.OBJLoader();
                    objLoader.setPath(mapPath + '/source/');

                    objLoader.load('unityexport.obj', function (object) {
                        object.scale.set(1, 1, 1);
                        object.position.set(0, 0, 0);

                        // Calculate map bounds from geometry
                        const boundingBox = new THREE.Box3();

                        // Define nice materials for the map
                        const materials = [
                            new THREE.MeshStandardMaterial({ color: 0xff6600, roughness: 0.6, metalness: 0.1 }), // Orange
                            new THREE.MeshStandardMaterial({ color: 0xcc5500, roughness: 0.6, metalness: 0.1 }), // Dark orange
                            new THREE.MeshStandardMaterial({ color: 0xffaa00, roughness: 0.5, metalness: 0.15 }), // Yellow-orange
                            new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.8, metalness: 0.05 }), // Grey
                        ];
                        const floorMaterial = new THREE.MeshStandardMaterial({
                            color: 0xdddddd, roughness: 0.9, metalness: 0.0
                        });

                        let meshIndex = 0;
                        object.traverse(function (child) {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;

                                // Compute bounding box
                                child.geometry.computeBoundingBox();
                                const meshBox = child.geometry.boundingBox.clone();
                                meshBox.applyMatrix4(child.matrixWorld);
                                boundingBox.union(meshBox);

                                // Check if it's a floor (mostly horizontal, low Y position)
                                const center = new THREE.Vector3();
                                meshBox.getCenter(center);
                                if (center.y < 0.5) {
                                    child.material = floorMaterial;
                                } else {
                                    // Cycle through materials for variety
                                    child.material = materials[meshIndex % materials.length];
                                    meshIndex++;
                                }

                                objCollisionMeshes.push(child);
                                mapObjects.push(child);
                            }
                        });

                        // Set map bounds
                        mapBounds = {
                            minX: boundingBox.min.x + 1,
                            maxX: boundingBox.max.x - 1,
                            minZ: boundingBox.min.z + 1,
                            maxZ: boundingBox.max.z - 1
                        };

                        scene.add(object);
                        loadedMapMesh = object;
                        mapObjects.push(object);

                        // Create invisible floor
                        const objFloorGeometry = new THREE.PlaneGeometry(200, 200);
                        const objFloorMaterial = new THREE.MeshBasicMaterial({ visible: false });
                        floor = new THREE.Mesh(objFloorGeometry, objFloorMaterial);
                        floor.rotation.x = -Math.PI / 2;
                        floor.name = 'groundPlane';
                        scene.add(floor);
                        mapObjects.push(floor);

                        if (onComplete) onComplete();
                    }, undefined, function (error) {
                        console.error('❌ Complete failure loading map:', error);
                        createDefaultMap();
                        if (onComplete) onComplete();
                    });
                });
            }

            // Function to create the default map - Menu style!
            function createDefaultMap() {
                console.log('🏭 Creating menu-style map with gray floor and grid');

                // Update loading progress
                if (window.LoadingScreen) {
                    LoadingScreen.setProgress(50, 'CREATING TERRAIN...');
                }

                // Mark texture assets as loaded (we're not using them anymore)
                if (window.LoadingScreen) {
                    LoadingScreen.assetLoaded('asphalt_diffuse');
                    LoadingScreen.assetLoaded('asphalt_normal');
                    LoadingScreen.assetLoaded('asphalt_roughness');
                }

                // Change scene background and fog to match menu
                scene.background = new THREE.Color(0xa0a0a0);
                scene.fog = new THREE.Fog(0xa0a0a0, 30, 120);

                // Create simple gray floor like menu
                const floorGeometry = new THREE.PlaneGeometry(200, 200);
                const floorMaterial = new THREE.MeshBasicMaterial({
                    color: 0x999999
                });
                floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.position.y = 0;
                scene.add(floor);
                mapObjects.push(floor);

                // Add grid helper for visual reference (like menu)
                const grid = new THREE.GridHelper(200, 50, 0x000000, 0x000000);
                grid.material.opacity = 0.2;
                grid.material.transparent = true;
                grid.position.y = 0.01; // Slightly above floor
                scene.add(grid);

                console.log('✅ Menu-style floor and grid created');
                if (window.LoadingScreen) {
                    LoadingScreen.assetLoaded('floor');
                    LoadingScreen.assetLoaded('walls');
                    LoadingScreen.assetLoaded('barriers');
                    LoadingScreen.setStatus('LOADING WEAPONS...');
                }
            }

            // Load the selected map
            if (selectedMap === 'map1') {
                loadOBJMap('map1', function () {
                    console.log('✅ Map1 loaded and ready');
                });
            } else {
                createDefaultMap();
            }

            // Create Cover Boxes helper functions (collision detection)
            function checkCollision(newPosition, playerRadius = 0.5, playerHeight = 1.7) {
                // For OBJ maps - DISABLE collision detection (map geometry is complex)
                // Only enforce outer boundaries
                if (selectedMap === 'map1') {
                    // Simple boundary check only - no wall collision for OBJ maps
                    if (newPosition.x < -28 || newPosition.x > 28 ||
                        newPosition.z < -28 || newPosition.z > 28) {
                        return { type: 'boundary' };
                    }
                    return null; // No collision - free movement in OBJ map
                }

                // First, check map bounds (prevent going outside the map)
                if (newPosition.x < mapBounds.minX || newPosition.x > mapBounds.maxX ||
                    newPosition.z < mapBounds.minZ || newPosition.z > mapBounds.maxZ) {
                    return { type: 'boundary' }; // Hit map boundary
                }

                // For default map, use box-based collision (original method)
                const allObjects = [...boxes, ...walls];

                for (let obj of allObjects) {
                    // Get object dimensions and position
                    if (!obj.geometry || !obj.geometry.parameters) continue; // Skip non-box geometries

                    const objGeometry = obj.geometry;
                    const objWidth = objGeometry.parameters.width || 1;
                    const objHeight = objGeometry.parameters.height || 1;
                    const objDepth = objGeometry.parameters.depth || 1;

                    const objX = obj.position.x;
                    const objY = obj.position.y;
                    const objZ = obj.position.z;

                    // Calculate object bounds with padding
                    const objMinX = objX - objWidth / 2 - playerRadius;
                    const objMaxX = objX + objWidth / 2 + playerRadius;
                    const objMinZ = objZ - objDepth / 2 - playerRadius;
                    const objMaxZ = objZ + objDepth / 2 + playerRadius;
                    const objMinY = objY - objHeight / 2;
                    const objMaxY = objY + objHeight / 2;

                    // Check if player collides with this object
                    if (newPosition.x >= objMinX && newPosition.x <= objMaxX &&
                        newPosition.z >= objMinZ && newPosition.z <= objMaxZ &&
                        newPosition.y < objMaxY && newPosition.y + playerHeight > objMinY) {
                        return obj; // Collision detected
                    }
                }
                return null; // No collision
            }

            // Ground detection for OBJ maps (for walking on ramps, stairs, etc.)
            function getGroundHeight(position) {
                if (objCollisionMeshes.length === 0) return 0; // Default map uses flat floor

                // Cast ray downward from player position - PERF: Reuse cached vectors
                _collisionRayOrigin.set(position.x, position.y + 5, position.z);
                collisionRaycaster.set(_collisionRayOrigin, _collisionDownVec);
                collisionRaycaster.far = 20;

                const intersects = collisionRaycaster.intersectObjects(objCollisionMeshes, true);
                if (intersects.length > 0) {
                    return intersects[0].point.y;
                }
                return 0; // Fallback to ground level
            }

            // Get safe spawn position based on selected map
            function getSpawnPosition(isPlayerSide = true) {
                if (selectedMap === 'map1') {
                    // Map1 (Arena) - spawn at ground level (Y=1.7 is eye height, floor is at Y=0-1)
                    // Map center is around 0,0 - spawn near center
                    if (isPlayerSide) {
                        return { x: 5, y: 1.7, z: 5 }; // One corner
                    } else {
                        return { x: -5, y: 1.7, z: -5 }; // Opposite corner
                    }
                } else {
                    // Default warehouse spawn positions
                    if (isPlayerSide) {
                        return { x: 0, y: 1.7, z: -20 }; // Player side spawn
                    } else {
                        return { x: 0, y: 1.7, z: 20 }; // Enemy side spawn
                    }
                }
            }

            // Spawn player at safe position
            function spawnPlayer(isPlayerSide = true) {
                const spawn = getSpawnPosition(isPlayerSide);
                camera.position.set(spawn.x, spawn.y, spawn.z);
                console.log('🎮 Player spawned at:', spawn, 'Map:', selectedMap);
            }

            // Player Setup - spawn position
            // In multiplayer, host spawns on player side (z = -20), client spawns on enemy side (z = 20)
            // In single player, always spawn on player side (z = -20)
            // Note: isHost might not be set yet, so we'll set spawn position when connection is established
            spawnPlayer(true); // Default to player side
            const playerVelocity = new THREE.Vector3();
            const playerDirection = new THREE.Vector3();
            let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
            let canJump = true;

            // Add local player username display
            let localPlayerUsernameSprite = null;
            function createLocalPlayerUsernameDisplay() {
                console.log('Creating local player username display...');
                console.log('Camera position:', camera.position);
                console.log('Player username:', gameState.playerUsername);

                if (localPlayerUsernameSprite) {
                    scene.remove(localPlayerUsernameSprite);
                }

                const username = gameState.playerUsername || 'Player';
                const playerLevel = LevelSystem.data.level;
                const xpNeeded = LevelSystem.getXPForLevel(playerLevel);
                const xpProgress = LevelSystem.data.currentXP / xpNeeded;
                localPlayerUsernameSprite = createUsernameSprite(username, playerLevel, xpProgress);
                // Position above camera's initial position
                localPlayerUsernameSprite.position.set(camera.position.x, camera.position.y + 0.8, camera.position.z);
                scene.add(localPlayerUsernameSprite);

                console.log('Username sprite created and added to scene at:', localPlayerUsernameSprite.position);
                console.log('Sprite visible:', localPlayerUsernameSprite.visible);
                console.log('Sprite scale:', localPlayerUsernameSprite.scale);
            }

            // ==================== ANIMATED WEAPON MODELS ====================
            // Weapon state is global (used by systems defined outside initGame)
            currentWeaponMesh = null;
            weaponBobOffset = 0;
            weaponRecoilOffset = 0;
            weaponAnimationMixer = null;
            weaponAnimations = {};
            loadedWeaponModels = {}; // Cache loaded models
            if (weaponPhysics) {
                weaponPhysics.sway.x = 0;
                weaponPhysics.sway.y = 0;
                weaponPhysics.recoil.kick = 0;
                weaponPhysics.recoil.rot = 0;
                weaponPhysics.lastMouseX = 0;
                weaponPhysics.lastMouseY = 0;
            }

            // ==================== 10X GAMEPLAY ENHANCEMENTS ====================

            // --- PARTICLE SYSTEM ---
            const activeParticles = [];
            const activeCasings = [];
            const activeTracers = [];

            // Create bullet tracer
            // PERF: Cached tracer geometry and material - reuse instead of creating new each shot
            let _cachedTracerGeometry = null;
            let _cachedTracerMaterial = null;
            let _cachedGlowGeometry = null;
            let _cachedGlowMaterial = null;
            
            function createBulletTracer(startPos, endPos, isRemote = false) {
                // PERF: Use pre-allocated vectors
                _tracerDirection.subVectors(endPos, startPos);
                const distance = _tracerDirection.length();
                const clampedDistance = Math.min(distance, 15);

                // PERF: Create geometry/material once and reuse
                if (!_cachedTracerGeometry) {
                    _cachedTracerGeometry = new THREE.CylinderGeometry(0.008, 0.008, 1, 6); // Unit height, will scale
                    _cachedTracerMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffdd44,
                        transparent: true,
                        opacity: 0.9
                    });
                    _cachedGlowGeometry = new THREE.CylinderGeometry(0.02, 0.02, 1, 6);
                    _cachedGlowMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffaa00,
                        transparent: true,
                        opacity: 0.3
                    });
                }
                
                // PERF: Share geometry (don't clone), only clone material (needed for per-tracer opacity fade)
                const tracer = new THREE.Mesh(_cachedTracerGeometry, _cachedTracerMaterial.clone());
                tracer.scale.y = clampedDistance; // Scale to correct length

                // PERF: Use pre-allocated vector for midpoint calculation
                _tracerMidPoint.addVectors(startPos, endPos).multiplyScalar(0.5);
                tracer.position.copy(_tracerMidPoint);
                tracer.lookAt(endPos);
                tracer.rotateX(Math.PI / 2);

                // Add glow effect - share geometry, clone material for opacity
                const glow = new THREE.Mesh(_cachedGlowGeometry, _cachedGlowMaterial.clone());
                glow.scale.y = clampedDistance;
                tracer.add(glow);

                scene.add(tracer);

                activeTracers.push({
                    mesh: tracer,
                    lifetime: 0,
                    maxLifetime: 0.08 // Very brief flash
                });

                // Create ultra-realistic smoke trail!
                createBulletSmokeTrail(startPos, endPos, isRemote);

                return tracer;
            }

            // Expose for multiplayer handlers (which can run outside init scope)
            window.createBulletTracer = createBulletTracer;

            // ========================================================================
            // ULTRA-REALISTIC SMOKE TRAIL - Undulating Line (like reference image)
            // Follows bullet path but waves up and down naturally
            // ========================================================================

            const smokeTrails = [];
            const MAX_SMOKE_TRAILS = 50;
            let smokeLineTexture = null;

            // Create wispy smoke texture with realistic noise
            function createSmokeLineTexture() {
                if (smokeLineTexture) return smokeLineTexture;

                const width = 512;
                const height = 128;
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, width, height);

                // Simple pseudo-noise function
                function noise(x, y, seed) {
                    const n = Math.sin(x * 12.9898 + y * 78.233 + seed) * 43758.5453;
                    return n - Math.floor(n);
                }

                // Multi-octave noise for cloud-like effect
                function fbm(x, y, octaves = 4) {
                    let value = 0;
                    let amplitude = 0.5;
                    let frequency = 1;
                    for (let i = 0; i < octaves; i++) {
                        value += amplitude * noise(x * frequency, y * frequency, i * 100);
                        amplitude *= 0.5;
                        frequency *= 2;
                    }
                    return value;
                }

                // Generate smoky cloud texture
                const imageData = ctx.createImageData(width, height);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const i = (y * width + x) * 4;

                        // Normalized coordinates
                        const nx = x / width;
                        const ny = y / height;

                        // Soft edge falloff (vertical)
                        const edgeFalloff = Math.sin(ny * Math.PI);

                        // Cloud noise
                        const cloudNoise = fbm(nx * 8, ny * 4);

                        // Wispy horizontal streaks
                        const streaks = Math.sin(nx * 20 + cloudNoise * 5) * 0.3 + 0.7;

                        // Combine for final alpha
                        let alpha = edgeFalloff * cloudNoise * streaks;
                        alpha = Math.pow(alpha, 0.7) * 0.9; // Soft contrast

                        // Slightly blue-gray tint for realistic smoke
                        const gray = 180 + cloudNoise * 40;
                        imageData.data[i] = gray - 10;     // R (slightly less)
                        imageData.data[i + 1] = gray - 5;  // G
                        imageData.data[i + 2] = gray + 5;  // B (slightly more - blue tint)
                        imageData.data[i + 3] = Math.floor(alpha * 255);
                    }
                }
                ctx.putImageData(imageData, 0, 0);

                smokeLineTexture = new THREE.CanvasTexture(canvas);
                smokeLineTexture.wrapS = THREE.RepeatWrapping;
                smokeLineTexture.wrapT = THREE.ClampToEdgeWrapping;
                return smokeLineTexture;
            }

            // Create undulating smoke line along bullet path
            function createBulletSmokeTrail(startPos, endPos, isRemote = false) {
                // PERF: Use pre-allocated vectors instead of creating new ones each shot
                if (!isRemote) {
                    camera.getWorldDirection(_smokeCamDirTrail);
                    _smokeCamRightTrail.crossVectors(_smokeCamDirTrail, _smokeUpVec).normalize();

                    // PERF: Calculate muzzle start without cloning
                    _smokeMuzzleStart.copy(startPos);
                    _smokeMuzzleStart.addScaledVector(_smokeCamDirTrail, 0.4);   // Forward
                    _smokeMuzzleStart.addScaledVector(_smokeCamRightTrail, 0.23); // Right
                    _smokeMuzzleStart.y -= 0.16; // Down
                } else {
                    // Remote trails must not use *our* camera/gun; start exactly at provided startPos
                    _smokeMuzzleStart.copy(startPos);
                }

                _smokeVec.subVectors(endPos, _smokeMuzzleStart);
                const len = _smokeVec.length();

                if (len < 0.5) return;

                // PERF: Use pre-allocated direction vector
                _smokeDirection.copy(_smokeVec).normalize();
                // PERF: Reduced segment count - still looks good but much faster
                const numSegments = Math.max(12, Math.min(Math.floor(len * 2), 20));
                const points = _smokePoints;
                points.length = numSegments + 1;

                // UNIQUE wave parameters - multiple overlapping waves for organic look
                const wave1Freq = 1.5 + Math.random() * 3;    // Primary wave
                const wave1Amp = 0.02 + Math.random() * 0.06;
                const wave1Phase = Math.random() * Math.PI * 2;

                const wave2Freq = 3 + Math.random() * 4;      // Secondary faster wave
                const wave2Amp = 0.01 + Math.random() * 0.03;
                const wave2Phase = Math.random() * Math.PI * 2;

                // PERF: Removed third wave - two waves look nearly identical, saves CPU

                // Random overall tilt angle for this smoke trail
                const tiltAngle = (Math.random() - 0.5) * 0.3; // -0.15 to +0.15 radians

                // PERF: Use pre-allocated vectors for perpendicular directions
                _smokeRight.crossVectors(_smokeDirection, _smokeUpVec).normalize();
                _smokePerpUp.crossVectors(_smokeRight, _smokeDirection).normalize();

                for (let i = 0; i <= numSegments; i++) {
                    const t = i / numSegments;
                    // PERF: Reuse point vectors to avoid per-shot allocations
                    let pos = _smokePointVecs[i];
                    if (!pos) {
                        pos = new THREE.Vector3();
                        _smokePointVecs[i] = pos;
                    }
                    pos.lerpVectors(_smokeMuzzleStart, endPos, t);

                    // Combine two waves (reduced from 3)
                    const wave1 = Math.sin(t * len * wave1Freq + wave1Phase) * wave1Amp;
                    const wave2 = Math.sin(t * len * wave2Freq + wave2Phase) * wave2Amp;
                    const totalWave = wave1 + wave2;

                    // PERF: Apply offset directly without cloning
                    pos.x += _smokePerpUp.x * totalWave;
                    pos.y += _smokePerpUp.y * totalWave + tiltAngle * t * len * 0.02;
                    pos.z += _smokePerpUp.z * totalWave;

                    points[i] = pos;
                }

                // Create smooth curve through points
                const curve = new THREE.CatmullRomCurve3(points);
                const tubeRadius = 0.012 + Math.random() * 0.008;
                // PERF: Reduced radial segments from 8 to 4 (50% fewer triangles, still looks smooth)
                const tubeGeo = new THREE.TubeGeometry(curve, numSegments, tubeRadius, 4, false);

                const tubeMat = new THREE.MeshBasicMaterial({
                    map: createSmokeLineTexture(),
                    transparent: true,
                    opacity: 0.6,
                    side: THREE.DoubleSide,
                    depthWrite: false,
                    depthTest: true,
                    blending: THREE.NormalBlending,
                    alphaTest: 0.01, // Discard very transparent pixels
                    fog: true
                });

                const tubeMesh = new THREE.Mesh(tubeGeo, tubeMat);
                scene.add(tubeMesh);

                smokeTrails.push({
                    mesh: tubeMesh,
                    age: 0,
                    maxAge: 3 + Math.random() * 3, // 3-6 seconds (fast fade)
                    initialOpacity: tubeMat.opacity,
                    phase: wave1Phase,
                    isRemote: !!isRemote
                });

                // PERF: Use simple length check instead of while loop
                if (smokeTrails.length > MAX_SMOKE_TRAILS) {
                    const old = smokeTrails.shift();
                    scene.remove(old.mesh);
                    old.mesh.geometry.dispose();
                    old.mesh.material.dispose();
                }
            }

            // PERF: Pre-allocated vectors for smoke update
            const _smokeCamDir = new THREE.Vector3();
            const _smokeCamRight = new THREE.Vector3();
            const _smokeMuzzle = new THREE.Vector3();
            const _smokeUp = new THREE.Vector3(0, 1, 0);

            // Update smoke - subtle movement, gun-following start, and fade
            // PERF: Added frame budget system - only update subset of trails per frame
            let _smokeUpdateIndex = 0;
            const SMOKE_UPDATE_BATCH = 5; // Update max 5 trails per frame for turbulence
            
            function updateBulletSmokeParticles(deltaTime) {
                const time = performance.now() * 0.001;

                // Get current gun muzzle position for smoke start following - PERF: reuse vectors
                camera.getWorldDirection(_smokeCamDir);
                _smokeCamRight.crossVectors(_smokeCamDir, _smokeUp).normalize();
                _smokeMuzzle.copy(camera.position);
                _smokeMuzzle.addScaledVector(_smokeCamDir, 0.7);
                _smokeMuzzle.addScaledVector(_smokeCamRight, 0.23);
                _smokeMuzzle.y -= 0.1;

                // PERF: Track how many trails we've done turbulence on this frame
                let turbulenceCount = 0;

                for (let i = smokeTrails.length - 1; i >= 0; i--) {
                    const trail = smokeTrails[i];
                    trail.age += deltaTime;

                    const lifeProgress = trail.age / trail.maxAge;

                    if (lifeProgress >= 1) {
                        scene.remove(trail.mesh);
                        trail.mesh.geometry.dispose();
                        trail.mesh.material.dispose();
                        smokeTrails.splice(i, 1);
                        continue;
                    }

                    // PERF: Only do expensive turbulence for a few trails per frame (round-robin)
                    const positions = trail.mesh.geometry.attributes.position;
                    
                    if (turbulenceCount < SMOKE_UPDATE_BATCH) {
                        // REALISTIC 3D TURBULENCE - 'Boiling' smoke effect (but limited per frame)
                        // PERF: Process every 3rd vertex instead of every vertex
                        for (let v = 0; v < positions.count; v += 3) {
                            const seed = v * 0.1 + trail.phase;
                            const t = time * 0.4;

                            const noiseX = Math.sin(t + seed) * Math.cos(t * 0.5 + seed * 2);
                            const noiseY = Math.sin(t * 1.2 + seed * 1.5) * Math.cos(t * 0.7 + seed);
                            const noiseZ = Math.sin(t * 0.8 + seed * 3) * Math.cos(t + seed * 0.5);

                            const intensity = 0.0005 * (1 - lifeProgress);

                            positions.setX(v, positions.getX(v) + noiseX * intensity);
                            positions.setY(v, positions.getY(v) + noiseY * intensity);
                            positions.setZ(v, positions.getZ(v) + noiseZ * intensity);
                        }
                        turbulenceCount++;
                    }

                    // START FOLLOWS GUN - only for newest trails (first 2)
                    // PERF: Limit gun-following to only the 2 newest trails
                    if (!trail.isRemote && i >= smokeTrails.length - 2) {
                        const pullStrength = 1.0;
                        // PERF: Reduced from 30 to 15 vertices
                        for (let v = 0; v < Math.min(positions.count, 15); v++) {
                            const vertexWeight = Math.pow(1 - (v / 15), 2);
                            const x = positions.getX(v);
                            const y = positions.getY(v);
                            const z = positions.getZ(v);

                            const followSpeed = 50;

                            if (v === 0) {
                                positions.setX(v, _smokeMuzzle.x);
                                positions.setY(v, _smokeMuzzle.y);
                                positions.setZ(v, _smokeMuzzle.z);
                            } else {
                                positions.setX(v, x + (_smokeMuzzle.x - x) * pullStrength * vertexWeight * deltaTime * followSpeed);
                                positions.setY(v, y + (_smokeMuzzle.y - y) * pullStrength * vertexWeight * deltaTime * followSpeed);
                                positions.setZ(v, z + (_smokeMuzzle.z - z) * pullStrength * vertexWeight * deltaTime * followSpeed);
                            }
                        }
                    }
                    
                    positions.needsUpdate = true;

                    // Fast fade from start
                    const opacity = trail.initialOpacity * (1 - lifeProgress);
                    trail.mesh.material.opacity = Math.max(0, opacity);
                }
            }

            // Create impact sparks
            // PERF: Pre-cached spark geometry and materials
            let _cachedSparkGeometry = null;
            const _cachedSparkMaterials = [];
            
            // PERF: Vector3 pool for particle velocities
            const _particleVelocityPool = [];
            const _particleVelocityPoolMax = 100;
            function _getParticleVelocity(x, y, z) {
                let vel = _particleVelocityPool.pop();
                if (!vel) vel = new THREE.Vector3();
                return vel.set(x, y, z);
            }
            function _recycleParticleVelocity(vel) {
                if (_particleVelocityPool.length < _particleVelocityPoolMax) {
                    _particleVelocityPool.push(vel);
                }
            }
            
            function createImpactSparks(position, normal, count = 8) {
                // PERF: Reduce spark count for better performance
                const actualCount = Math.min(count, 5);
                
                // PERF: Cache geometry once
                if (!_cachedSparkGeometry) {
                    _cachedSparkGeometry = new THREE.SphereGeometry(0.025, 3, 3); // Reduced segments
                    _cachedSparkMaterials.push(new THREE.MeshBasicMaterial({
                        color: 0xffaa00,
                        transparent: true,
                        opacity: 1
                    }));
                    _cachedSparkMaterials.push(new THREE.MeshBasicMaterial({
                        color: 0xffff88,
                        transparent: true,
                        opacity: 1
                    }));
                }
                
                for (let i = 0; i < actualCount; i++) {
                    // PERF: Clone cached geometry/material instead of creating new
                    const spark = new THREE.Mesh(
                        _cachedSparkGeometry, 
                        _cachedSparkMaterials[i % 2].clone()
                    );
                    // SAFETY: geometry is cached/shared
                    spark.userData.sharedGeometry = true;
                    spark.position.copy(position);

                    // Random velocity based on surface normal - PERF: Use pooled vector
                    const velocity = _getParticleVelocity(
                        (Math.random() - 0.5) * 8 + normal.x * 3,
                        Math.random() * 6 + normal.y * 3,
                        (Math.random() - 0.5) * 8 + normal.z * 3
                    );

                    scene.add(spark);
                    activeParticles.push({
                        mesh: spark,
                        velocity: velocity,
                        lifetime: 0,
                        maxLifetime: 0.3 + Math.random() * 0.3,
                        gravity: 15,
                        fadeOut: true
                    });
                }
            }

            // ========================================================================
            // FOOTSTEP DUST SYSTEM ("Walking Trail")
            // ========================================================================
            const footstepParticles = [];
            
            // PERF: Cached footstep dust geometry and material
            let _cachedDustGeometry = null;
            let _cachedDustMaterial = null;

            // Spawn dust puff at feet
            function createFootstepDust(position) {
                // PERF: Cache geometry and material
                if (!_cachedDustGeometry) {
                    _cachedDustGeometry = new THREE.PlaneGeometry(0.25, 0.25);
                    _cachedDustMaterial = new THREE.MeshBasicMaterial({
                        color: 0x888888,
                        transparent: true,
                        opacity: 0.3,
                        side: THREE.DoubleSide
                    });
                }
                
                const dust = new THREE.Mesh(_cachedDustGeometry, _cachedDustMaterial.clone());
                // SAFETY: geometry is cached/shared
                dust.userData.sharedGeometry = true;

                // Position at feet height (random scatter)
                dust.position.copy(position);
                dust.position.x += (Math.random() - 0.5) * 0.4;
                dust.position.z += (Math.random() - 0.5) * 0.4;
                dust.position.y = 0.15 + Math.random() * 0.1; // Slightly above ground

                // Random rotation
                dust.rotation.x = -Math.PI / 2; // Flat on ground usually
                dust.rotation.z = Math.random() * Math.PI * 2;

                scene.add(dust);

                footstepParticles.push({
                    mesh: dust,
                    velocity: _getParticleVelocity((Math.random() - 0.5) * 0.2, Math.random() * 0.2, (Math.random() - 0.5) * 0.2),
                    age: 0,
                    maxAge: 0.8 + Math.random() * 0.4 // 0.8-1.2s lifetime
                });
            }

            // Update footstep dust
            function updateFootstepDust(deltaTime) {
                for (let i = footstepParticles.length - 1; i >= 0; i--) {
                    const particle = footstepParticles[i];
                    particle.age += deltaTime;

                    if (particle.age >= particle.maxAge) {
                        scene.remove(particle.mesh);
                        // PERF: Recycle velocity back to pool
                        if (particle.velocity) _recycleParticleVelocity(particle.velocity);
                        // SAFETY: geometry is cached/shared
                        particle.mesh.material.dispose();
                        footstepParticles.splice(i, 1);
                        continue;
                    }

                    // Simple expansion and fade
                    const life = particle.age / particle.maxAge;
                    particle.mesh.scale.setScalar(1 + life * 1.5); // Grow
                    particle.mesh.material.opacity = 0.3 * (1 - life); // Fade

                    // Tiny movement
                    particle.mesh.position.addScaledVector(particle.velocity, deltaTime);
                    particle.mesh.rotation.z += deltaTime * 0.5;
                }
            }

            // PERF: Pre-allocated geometry and material for debris particles
            let _debrisBaseGeometry = null;
            let _debrisBaseMaterial = null;
            
            // Create debris particles
            function createDebrisParticles(position, count = 5) {
                // PERF: Create base geometry/material once
                if (!_debrisBaseGeometry) {
                    _debrisBaseGeometry = new THREE.BoxGeometry(0.04, 0.04, 0.04); // Use max size
                    _debrisBaseMaterial = new THREE.MeshStandardMaterial({
                        color: 0x666666,
                        roughness: 0.9
                    });
                }
                
                for (let i = 0; i < count; i++) {
                    const size = 0.02 + Math.random() * 0.04;
                    const sizeScale = size / 0.04; // Scale from base size
                    const debris = new THREE.Mesh(_debrisBaseGeometry, _debrisBaseMaterial.clone()); // Clone material for individual opacity
                    // SAFETY: geometry is cached/shared
                    debris.userData.sharedGeometry = true;
                    debris.scale.setScalar(sizeScale);
                    debris.position.copy(position);

                    // PERF: Use pooled velocity vector
                    const velocity = _getParticleVelocity(
                        (Math.random() - 0.5) * 5,
                        Math.random() * 4,
                        (Math.random() - 0.5) * 5
                    );

                    scene.add(debris);
                    activeParticles.push({
                        mesh: debris,
                        velocity: velocity,
                        lifetime: 0,
                        maxLifetime: 1.5 + Math.random() * 0.5,
                        gravity: 12,
                        fadeOut: true,
                        rotation: _getParticleVelocity(Math.random() * 5, Math.random() * 5, Math.random() * 5)
                    });
                }
            }

            // PERF: Pre-allocated vector for blood splatter direction
            const _bloodSplatterCamDir = new THREE.Vector3();
            
            // Create blood splatter from bullet impact (uses permanent blood system)
            function createBloodSplatter(position, intensity = 1, isHeadshot = false) {
                // Get bullet direction (from camera forward) - PERF: Reuse vector
                camera.getWorldDirection(_bloodSplatterCamDir);

                // Create realistic splatter using the new system
                createBloodSplatterFromImpact(position, _bloodSplatterCamDir, intensity, isHeadshot);
            }

            // === PERFORMANCE: POOLED RESOURCES ===
            // Reusing geometry and material massively reduces memory overhead and GC pauses
            const shellCasingGeometry = new THREE.CylinderGeometry(0.008, 0.006, 0.025, 8);
            const shellCasingMaterial = new THREE.MeshStandardMaterial({
                color: 0xc9a227,
                metalness: 0.9,
                roughness: 0.2
            });

            // Pre-loaded muzzle flash assets
            const flashAssets = [];
            const flashVideos = ['shotfire.mp4', 'shotfire2.mp4', 'shotfire3.mp4', 'shotfire4.mp4'];

            // Initialize flash assets (called at startup)
            function initFlashAssets() {
                flashVideos.forEach(src => {
                    const video = document.createElement('video');
                    video.src = src;
                    video.muted = true;
                    video.playsInline = true;
                    video.preload = 'auto'; // Force buffer
                    video.load();

                    // Create texture once
                    const texture = new THREE.VideoTexture(video);
                    texture.minFilter = THREE.LinearFilter;
                    texture.magFilter = THREE.LinearFilter;

                    // Create material once
                    const material = new THREE.SpriteMaterial({
                        map: texture,
                        blending: THREE.AdditiveBlending,
                        transparent: true,
                        opacity: 3.0,
                        depthTest: false,
                        depthWrite: false
                    });

                    flashAssets.push({
                        video: video,
                        texture: texture,
                        material: material,
                        busy: false // Simple flag if we wanted to limit concurrency (not strictly needed with clones via Sprite, but video element is unique)
                    });
                });
            }

            // Call init straight away
            initFlashAssets();

            // PERF: Pre-allocated vectors for shell casing creation (moved from inside function)
            const _casingUpVec = new THREE.Vector3(0, 1, 0);
            
            // Create shell casing
            function createShellCasing() {
                const casing = new THREE.Mesh(shellCasingGeometry, shellCasingMaterial);

                // PERF/SAFETY: shellCasingGeometry/material are shared; never dispose per instance
                casing.userData.sharedGeometry = true;
                casing.userData.sharedMaterial = true;

                // Position near weapon (right side) - PERF: Reuse global vectors
                camera.getWorldPosition(_reusableVec3A);
                camera.getWorldDirection(_reusableVec3B);
                _reusableVec3B.cross(_casingUpVec).normalize();
                _reusableVec3A.add(_reusableVec3B.multiplyScalar(0.3));
                _reusableVec3A.y -= 0.1;

                casing.position.copy(_reusableVec3A);

                // Eject velocity (right and up) - PERF: Create velocity vec directly in object (unavoidable)
                camera.getWorldDirection(_reusableVec3C);
                _reusableVec3C.cross(_casingUpVec).normalize();
                const velX = _reusableVec3C.x * (3 + Math.random() * 2);
                const velY = 2 + Math.random() * 2;
                const velZ = _reusableVec3C.z * (3 + Math.random() * 2);

                scene.add(casing);
                activeCasings.push({
                    mesh: casing,
                    velocity: new THREE.Vector3(velX, velY, velZ), // This allocation is unavoidable - stored per casing
                    lifetime: 0,
                    maxLifetime: 3,
                    gravity: 12,
                    rotation: new THREE.Vector3( // This allocation is unavoidable - stored per casing
                        (Math.random() - 0.5) * 20,
                        (Math.random() - 0.5) * 20,
                        (Math.random() - 0.5) * 20
                    ),
                    bounces: 0
                });
            }

            // Update all particles
            // PERF: Pre-allocated vector for particle updates
            const _particleTempVec = new THREE.Vector3();
            
            // PERF: Batched particle removal - collect indices then remove in one pass
            const _particlesToRemove = [];
            const _tracersToRemove = [];
            const _casingsToRemove = [];

            function updateParticles(deltaTime) {
                // Clear removal arrays
                _tracersToRemove.length = 0;
                _particlesToRemove.length = 0;
                _casingsToRemove.length = 0;
                
                // Update tracers
                for (let i = activeTracers.length - 1; i >= 0; i--) {
                    const tracer = activeTracers[i];
                    tracer.lifetime += deltaTime;

                    // Fade out
                    const fadeProgress = tracer.lifetime / tracer.maxLifetime;
                    tracer.mesh.material.opacity = 1 - fadeProgress;

                    if (tracer.lifetime >= tracer.maxLifetime) {
                        scene.remove(tracer.mesh);
                        // PERF: Don't dispose shared geometry (_cachedTracerGeometry)
                        // Only dispose material (which was cloned per tracer)
                        tracer.mesh.material.dispose();
                        // Dispose glow child's material too
                        if (tracer.mesh.children[0]) {
                            tracer.mesh.children[0].material.dispose();
                        }
                        _tracersToRemove.push(i);
                    }
                }
                
                // PERF: Batch remove tracers (reverse order to maintain indices)
                for (let i = 0; i < _tracersToRemove.length; i++) {
                    activeTracers.splice(_tracersToRemove[i], 1);
                }

                // Update particles (sparks, debris, blood)
                for (let i = activeParticles.length - 1; i >= 0; i--) {
                    const particle = activeParticles[i];
                    particle.lifetime += deltaTime;

                    // Apply physics - PERF: reuse vector
                    particle.velocity.y -= particle.gravity * deltaTime;
                    _particleTempVec.copy(particle.velocity).multiplyScalar(deltaTime);
                    particle.mesh.position.add(_particleTempVec);

                    // Apply rotation if exists
                    if (particle.rotation) {
                        particle.mesh.rotation.x += particle.rotation.x * deltaTime;
                        particle.mesh.rotation.y += particle.rotation.y * deltaTime;
                        particle.mesh.rotation.z += particle.rotation.z * deltaTime;
                    }

                    // Fade out
                    if (particle.fadeOut) {
                        const fadeProgress = particle.lifetime / particle.maxLifetime;
                        particle.mesh.material.opacity = 1 - fadeProgress;
                    }

                    // Floor collision
                    if (particle.mesh.position.y < 0.02) {
                        particle.mesh.position.y = 0.02;
                        particle.velocity.y *= -0.3;
                        particle.velocity.x *= 0.8;
                        particle.velocity.z *= 0.8;
                    }

                    // Mark for removal
                    if (particle.lifetime >= particle.maxLifetime) {
                        scene.remove(particle.mesh);
                        // PERF: Recycle velocity vector back to pool
                        if (particle.velocity) _recycleParticleVelocity(particle.velocity);
                        if (particle.rotation) _recycleParticleVelocity(particle.rotation);
                        // SAFETY: Some particles use cached/shared geometry/material
                        if (!particle.mesh.userData.sharedGeometry) {
                            particle.mesh.geometry.dispose();
                        }
                        if (!particle.mesh.userData.sharedMaterial) {
                            particle.mesh.material.dispose();
                        }
                        _particlesToRemove.push(i);
                    }
                }
                
                // PERF: Batch remove particles
                for (let i = 0; i < _particlesToRemove.length; i++) {
                    activeParticles.splice(_particlesToRemove[i], 1);
                }

                // Update shell casings
                for (let i = activeCasings.length - 1; i >= 0; i--) {
                    const casing = activeCasings[i];
                    casing.lifetime += deltaTime;

                    // Apply physics - PERF: reuse vector
                    casing.velocity.y -= casing.gravity * deltaTime;
                    _particleTempVec.copy(casing.velocity).multiplyScalar(deltaTime);
                    casing.mesh.position.add(_particleTempVec);

                    // Apply rotation
                    casing.mesh.rotation.x += casing.rotation.x * deltaTime;
                    casing.mesh.rotation.y += casing.rotation.y * deltaTime;
                    casing.mesh.rotation.z += casing.rotation.z * deltaTime;

                    // Floor collision with bounce
                    if (casing.mesh.position.y < 0.02 && casing.bounces < 3) {
                        casing.mesh.position.y = 0.02;
                        casing.velocity.y *= -0.4;
                        casing.velocity.x *= 0.7;
                        casing.velocity.z *= 0.7;
                        casing.rotation.multiplyScalar(0.5);
                        casing.bounces++;

                        // Casing hit sound (very quiet)
                        if (casing.bounces === 1) {
                            playCasingSound(casing.mesh.position);
                        }
                    }

                    // Mark for removal
                    if (casing.lifetime >= casing.maxLifetime) {
                        scene.remove(casing.mesh);
                        // SAFETY: shell casing geo/mat are shared
                        if (!casing.mesh.userData.sharedGeometry) {
                            casing.mesh.geometry.dispose();
                        }
                        if (!casing.mesh.userData.sharedMaterial) {
                            casing.mesh.material.dispose();
                        }
                        _casingsToRemove.push(i);
                    }
                }
                
                // PERF: Batch remove casings
                for (let i = 0; i < _casingsToRemove.length; i++) {
                    activeCasings.splice(_casingsToRemove[i], 1);
                }
            }

            // Shell casing hit sound
            function playCasingSound(position) {
                const ctx = ensureAudioContext();
                if (!ctx) return;

                const volume = calculateDistanceVolume(position, 20, 0.02);
                if (volume < 0.01) return;

                // High-pitched metallic ping
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);

                osc.frequency.setValueAtTime(4000 + Math.random() * 2000, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(800, ctx.currentTime + 0.05);
                gain.gain.setValueAtTime(volume, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.05);

                osc.start(ctx.currentTime);
                osc.stop(ctx.currentTime + 0.05);
            }

            // --- FOOTSTEP SYSTEM (CONTINUOUS LOOP) ---
            // The walk.mp3 is a 12-second continuous walking sound that should LOOP while moving
            
            let _footstepElement = null;
            let _footstepReady = false;
            let _footstepPlaying = false;
            let _footstepUnlocked = false;
            let _footstepDebugLogged = false;
            let _footstepStopGraceTimer = 0; // Debounce timer to prevent flickering
            
            const FOOTSTEP_AUDIO_URLS = ['walk.mp3', '../../walk.mp3'];
            const FOOTSTEP_STOP_GRACE_PERIOD = 0.15; // Don't stop for 150ms (prevents flicker)
            const FOOTSTEP_VOLUME_WALK = 0.7;  // Loud and clear
            const FOOTSTEP_VOLUME_SPRINT = 0.9; // Even louder when sprinting

            // Preload and setup the looping footstep audio
            (function _preloadFootstepAudio() {
                _footstepElement = new Audio();
                _footstepElement.preload = 'auto';
                _footstepElement.loop = true; // CRITICAL: Loop continuously while walking
                _footstepElement.volume = FOOTSTEP_VOLUME_WALK;
                
                _footstepElement.addEventListener('canplaythrough', () => {
                    _footstepReady = true;
                    console.log('👣 walk.mp3 loaded! Duration:', _footstepElement.duration.toFixed(1) + 's');
                }, { once: true });
                
                _footstepElement.addEventListener('error', (e) => {
                    console.error('👣 walk.mp3 FAILED to load:', FOOTSTEP_AUDIO_URLS[0], e.target.error);
                    // Try alternate path
                    if (_footstepElement.src.indexOf('../../') === -1) {
                        _footstepElement.src = FOOTSTEP_AUDIO_URLS[1];
                    }
                });
                
                // Track playing state (no spam logging)
                _footstepElement.addEventListener('play', () => { _footstepPlaying = true; });
                _footstepElement.addEventListener('pause', () => { _footstepPlaying = false; });
                
                _footstepElement.src = FOOTSTEP_AUDIO_URLS[0];
            })();

            // Unlock footstep audio on first user gesture
            window._unlockFootstepAudio = function() {
                if (_footstepUnlocked || !_footstepElement) return;
                
                // Play very briefly then pause to unlock
                _footstepElement.volume = 0.001;
                _footstepElement.currentTime = 0;
                const p = _footstepElement.play();
                if (p && typeof p.then === 'function') {
                    p.then(() => {
                        _footstepElement.pause();
                        _footstepElement.currentTime = 0;
                        _footstepElement.volume = FOOTSTEP_VOLUME_WALK;
                        _footstepUnlocked = true;
                        console.log('👣 walk.mp3 UNLOCKED!');
                    }).catch((err) => {
                        console.warn('👣 walk.mp3 unlock failed:', err.message);
                    });
                }
            };

            // Start playing footsteps (called when player starts moving)
            function startFootstepLoop() {
                if (!_footstepElement || !_footstepReady) return;
                if (_footstepPlaying) return; // Already playing
                
                // Try to unlock if not yet unlocked
                if (!_footstepUnlocked && window._unlockFootstepAudio) {
                    window._unlockFootstepAudio();
                }
                
                // Set volume based on sprint state
                _footstepElement.volume = gameState.isSprinting ? FOOTSTEP_VOLUME_SPRINT : FOOTSTEP_VOLUME_WALK;
                
                // Set playback rate (faster footsteps when sprinting)
                _footstepElement.playbackRate = gameState.isSprinting ? 1.3 : 1.0;
                
                const playPromise = _footstepElement.play();
                if (playPromise && typeof playPromise.catch === 'function') {
                    playPromise.catch((err) => {
                        console.warn('👣 walk.mp3 play failed:', err.message);
                    });
                }
                
                if (!_footstepDebugLogged) {
                    _footstepDebugLogged = true;
                    console.log('👣 Footsteps started - volume:', _footstepElement.volume);
                }
            }
            
            // Stop playing footsteps (called when player stops moving)
            function stopFootstepLoop() {
                if (!_footstepElement || !_footstepPlaying) return;
                
                try {
                    _footstepElement.pause();
                } catch (e) { }
            }
            
            // Update footstep playback state based on movement
            function updateFootsteps(deltaTime) {
                if (!gameState.started || gameState.paused || gameState.isDying) {
                    stopFootstepLoop();
                    _footstepStopGraceTimer = 0;
                    return;
                }

                // Check if player should have footsteps
                const shouldPlayFootsteps = gameState.isMoving && 
                                            !gameState.isSliding && 
                                            gameState.onGround &&
                                            gameState.movementSpeed > 0.1;
                
                if (shouldPlayFootsteps) {
                    // Reset grace timer when moving
                    _footstepStopGraceTimer = 0;
                    
                    // Start or continue playing
                    if (!_footstepPlaying) {
                        startFootstepLoop();
                    }
                    
                    // Update volume/speed based on sprint state (smooth transitions)
                    if (_footstepElement && _footstepPlaying) {
                        const targetVol = gameState.isSprinting ? FOOTSTEP_VOLUME_SPRINT : FOOTSTEP_VOLUME_WALK;
                        const targetRate = gameState.isSprinting ? 1.3 : 1.0;
                        
                        _footstepElement.volume += (targetVol - _footstepElement.volume) * 0.1;
                        _footstepElement.playbackRate += (targetRate - _footstepElement.playbackRate) * 0.1;
                    }
                } else {
                    // Use grace period to prevent flickering (don't stop immediately)
                    if (_footstepPlaying) {
                        _footstepStopGraceTimer += deltaTime;
                        if (_footstepStopGraceTimer >= FOOTSTEP_STOP_GRACE_PERIOD) {
                            stopFootstepLoop();
                            _footstepStopGraceTimer = 0;
                        }
                    }
                }
            }

            // --- DUST PARTICLES ---
            // PERF: Pre-allocated geometry and material for dust particles
            let _dustBaseGeometry = null;
            let _dustBaseMaterial = null;
            
            function createDustParticle() {
                if (!gameState.isMoving) return;
                if (Math.random() > (gameState.isSprinting ? 0.4 : 0.15)) return;

                // PERF: Create base geometry/material once, clone material for opacity changes
                if (!_dustBaseGeometry) {
                    _dustBaseGeometry = new THREE.SphereGeometry(0.05, 4, 4); // Use max size, scale down
                    _dustBaseMaterial = new THREE.MeshBasicMaterial({
                        color: 0x998877,
                        transparent: true,
                        opacity: 0.3
                    });
                }
                
                const dust = new THREE.Mesh(_dustBaseGeometry, _dustBaseMaterial.clone());
                // SAFETY: geometry is cached/shared
                dust.userData.sharedGeometry = true;
                const sizeScale = (0.03 + Math.random() * 0.05) / 0.05; // Scale from base size
                dust.scale.setScalar(sizeScale);

                // Position near feet
                dust.position.copy(camera.position);
                dust.position.y = 0.1;
                dust.position.x += (Math.random() - 0.5) * 0.5;
                dust.position.z += (Math.random() - 0.5) * 0.5;

                scene.add(dust);
                activeParticles.push({
                    mesh: dust,
                    velocity: new THREE.Vector3( // Unavoidable - unique per particle
                        (Math.random() - 0.5) * 0.5,
                        0.3 + Math.random() * 0.5,
                        (Math.random() - 0.5) * 0.5
                    ),
                    lifetime: 0,
                    maxLifetime: 0.8 + Math.random() * 0.4,
                    gravity: -0.5, // Slowly rises
                    fadeOut: true
                });
            }

            // ========================================================================
            // HYPER-REALISTIC BLOOD PHYSICS SYSTEM - PERMANENT BLOOD THAT STAYS
            // ========================================================================

            const bloodDrips = [];
            const permanentBloodPools = []; // PERMANENT - NEVER FADES
            const MAX_PERMANENT_POOLS = 100; // PERF: Reduced from 500 to prevent memory buildup
            const MAX_BLOOD_DRIPS = 50; // PERF: Limit active blood drips
            let enemyBloodTimer = 0;
            let lastEnemyPosition = null;
            let bloodTexture = null;

            // PERF: Reusable vectors for enemy blood logic (avoid per-frame allocations)
            const _enemyDripPos = new THREE.Vector3();
            const _enemyTrailPos = new THREE.Vector3();

            // PERF/SAFETY: Permanent blood pooling
            // The old approach created+disposed lots of CircleGeometry and MeshStandardMaterial while at MAX_PERMANENT_POOLS,
            // which can trigger big GC + WebGL driver stalls (shows up as longtasks + huge rAF gaps during shooting).
            const _bloodPoolGeomCache = new Map(); // segments -> Array<CircleGeometry>
            const _bloodPoolRecycle = [];
            const _bloodSplatRecycle = [];
            let _bloodPoolMatTemplate = null;
            let _bloodSplatMatTemplate = null;
            let _bloodSplatGeometry = null;

            function _ensureBloodPermanentAssets() {
                if (!_bloodPoolMatTemplate) {
                    _bloodPoolMatTemplate = new THREE.MeshStandardMaterial({
                        map: createBloodTexture(),
                        color: _bloodColorFresh.getHex(),
                        transparent: true,
                        opacity: 0.95,
                        roughness: 0.25,
                        metalness: 0.02,
                        side: THREE.DoubleSide
                    });
                }
                if (!_bloodSplatMatTemplate) {
                    _bloodSplatMatTemplate = new THREE.MeshStandardMaterial({
                        color: _bloodColorFresh.getHex(),
                        transparent: true,
                        opacity: 0.9,
                        roughness: 0.3,
                        metalness: 0.02,
                        side: THREE.DoubleSide
                    });
                }
                if (!_bloodSplatGeometry) {
                    _bloodSplatGeometry = new THREE.CircleGeometry(1, 6);
                }
            }

            function _getDistortedBloodPoolGeometry(segments) {
                let bucket = _bloodPoolGeomCache.get(segments);
                if (!bucket) {
                    bucket = [];
                    // Build a small library of distorted unit circles for this segment count
                    for (let g = 0; g < 6; g++) {
                        const geo = new THREE.CircleGeometry(1, segments);
                        const pos = geo.attributes.position;
                        for (let i = 1; i < pos.count; i++) {
                            pos.setX(i, pos.getX(i) * (0.6 + Math.random() * 0.8));
                            pos.setZ(i, pos.getZ(i) * (0.6 + Math.random() * 0.8));
                        }
                        geo.computeVertexNormals();
                        bucket.push(geo);
                    }
                    _bloodPoolGeomCache.set(segments, bucket);
                }
                return bucket[(Math.random() * bucket.length) | 0];
            }

            function _allocPermanentBloodMesh(kind) {
                _ensureBloodPermanentAssets();

                if (kind === 'pool') {
                    const mesh = _bloodPoolRecycle.pop() || new THREE.Mesh(_getDistortedBloodPoolGeometry(16), _bloodPoolMatTemplate.clone());
                    mesh.userData.bloodKind = 'pool';
                    mesh.userData.sharedGeometry = true;
                    mesh.receiveShadow = true;
                    return mesh;
                }

                const mesh = _bloodSplatRecycle.pop() || new THREE.Mesh(_bloodSplatGeometry, _bloodSplatMatTemplate.clone());
                mesh.userData.bloodKind = 'splat';
                mesh.userData.sharedGeometry = true;
                mesh.receiveShadow = true;
                return mesh;
            }

            function _recyclePermanentBloodEntry(entry) {
                if (!entry || !entry.mesh) return;
                scene.remove(entry.mesh);
                const kind = entry.mesh.userData.bloodKind;
                if (kind === 'pool') _bloodPoolRecycle.push(entry.mesh);
                else _bloodSplatRecycle.push(entry.mesh);
            }

            // PERF: Pre-allocated geometry and material for blood drops (object pooling)
            let _bloodDropGeometry = null;
            let _bloodDropMaterialTemplate = null;
            function getBloodDropGeometry() {
                if (!_bloodDropGeometry) {
                    _bloodDropGeometry = new THREE.SphereGeometry(0.025, 4, 4); // Reduced segments
                }
                return _bloodDropGeometry;
            }

            // Create wet blood texture
            function createBloodTexture() {
                if (bloodTexture) return bloodTexture;
                const size = 128;
                const canvas = document.createElement('canvas');
                canvas.width = size; canvas.height = size;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#550000';
                ctx.fillRect(0, 0, size, size);
                for (let i = 0; i < 60; i++) {
                    const x = Math.random() * size, y = Math.random() * size;
                    const r = Math.random() * 12 + 4;
                    const grad = ctx.createRadialGradient(x, y, 0, x, y, r);
                    grad.addColorStop(0, Math.random() > 0.5 ? 'rgba(100,0,0,0.3)' : 'rgba(30,0,0,0.4)');
                    grad.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill();
                }
                for (let i = 0; i < 10; i++) {
                    const x = Math.random() * size, y = Math.random() * size;
                    const r = Math.random() * 6 + 2;
                    const grad = ctx.createRadialGradient(x, y, 0, x, y, r);
                    grad.addColorStop(0, 'rgba(255,80,80,0.12)');
                    grad.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill();
                }
                bloodTexture = new THREE.CanvasTexture(canvas);
                return bloodTexture;
            }

            // PERF: Pre-allocated colors for blood color calculation
            const _bloodColorFresh = new THREE.Color(0x8B0000);
            const _bloodColorOld = new THREE.Color(0x2D0000);
            const _bloodColorResult = new THREE.Color();
            
            // Blood color with age (fresh=bright, old=dark maroon)
            function getBloodColor(age = 0) {
                // PERF: Copy and lerp into pre-allocated result color instead of clone()
                _bloodColorResult.copy(_bloodColorFresh).lerp(_bloodColorOld, Math.min(age, 1));
                return _bloodColorResult;
            }

            // Create falling blood drop - OPTIMIZED with pooling
            function createBloodDrip(position, velocity = null, size = null) {
                // PERF: Limit active blood drips
                if (bloodDrips.length >= MAX_BLOOD_DRIPS) {
                    // Remove oldest drip
                    const oldest = bloodDrips.shift();
                    if (oldest && oldest.mesh) {
                        scene.remove(oldest.mesh);
                        // SAFETY: blood drops use shared geometry
                        oldest.mesh.material.dispose();
                    }
                }

                const dropSize = size || (0.015 + Math.random() * 0.03);
                // PERF: Use shared geometry, scale for size variation
                const geo = getBloodDropGeometry();
                const mat = new THREE.MeshBasicMaterial({ // PERF: BasicMaterial instead of Standard
                    color: _bloodColorFresh.getHex(), transparent: true, opacity: 0.9
                });
                const drop = new THREE.Mesh(geo, mat);
                // SAFETY: blood drop geometry is shared
                drop.userData.sharedGeometry = true;
                drop.scale.setScalar(dropSize / 0.025); // Scale from base size
                drop.position.copy(position);
                const vel = velocity || _reusableVec3A.set(
                    (Math.random() - 0.5) * 0.4, -0.5 - Math.random() * 1.5, (Math.random() - 0.5) * 0.4
                ).clone();
                scene.add(drop);
                bloodDrips.push({ mesh: drop, velocity: vel, lifetime: 0, size: dropSize, hasLanded: false });
            }

            // PERF: Pre-allocated vectors for blood splatter creation
            const _bloodSplatterPos = new THREE.Vector3();
            const _bloodSplatterVel = new THREE.Vector3();
            
            // PERF: Vector3 pool for blood drip velocities (avoids per-particle allocation)
            const _bloodVelocityPool = [];
            const _bloodVelocityPoolMax = 50;
            function _getBloodVelocity(x, y, z) {
                let vel = _bloodVelocityPool.pop();
                if (!vel) vel = new THREE.Vector3();
                return vel.set(x, y, z);
            }
            function _recycleBloodVelocity(vel) {
                if (_bloodVelocityPool.length < _bloodVelocityPoolMax) {
                    _bloodVelocityPool.push(vel);
                }
            }
            
            // Blood splatter from bullet impact
            function createBloodSplatterFromImpact(position, direction, intensity = 1, isHeadshot = false) {
                const count = isHeadshot ? 30 : 12;
                const speed = isHeadshot ? 2.5 : 1.5;
                for (let i = 0; i < count * intensity; i++) {
                    const dropSize = 0.01 + Math.random() * (isHeadshot ? 0.05 : 0.035);
                    // PERF: Use pooled velocity vector instead of new allocation
                    const vel = _getBloodVelocity(
                        direction.x * speed + (Math.random() - 0.5) * 1.5,
                        direction.y * speed + Math.random() * 1.2,
                        direction.z * speed + (Math.random() - 0.5) * 1.5
                    );
                    // PERF: Use temp vector then copy to drip position instead of clone
                    _bloodSplatterPos.copy(position);
                    _bloodSplatterPos.x += (Math.random() - 0.5) * 0.15;
                    _bloodSplatterPos.y += (Math.random() - 0.5) * 0.15;
                    _bloodSplatterPos.z += (Math.random() - 0.5) * 0.15;
                    createBloodDrip(_bloodSplatterPos, vel, dropSize);
                }
                // Arterial spray for headshots
                // PERF: Capture position values now to avoid closure over live object
                if (isHeadshot) {
                    const px = position.x, py = position.y, pz = position.z;
                    for (let i = 0; i < 4; i++) {
                        setTimeout(() => {
                            if (!enemy || !enemy.visible) return;
                            // PERF: Use pooled velocity vector
                            const sprayVel = _getBloodVelocity((Math.random() - 0.5) * 2.5, 1.5 + Math.random() * 1.5, (Math.random() - 0.5) * 2.5);
                            // PERF: Use captured values instead of clone()
                            _bloodSplatterPos.set(px, py, pz);
                            createBloodDrip(_bloodSplatterPos, sprayVel, 0.025 + Math.random() * 0.03);
                        }, i * 40);
                    }
                }
            }

            // Create PERMANENT blood pool (NEVER FADES)
            function createBloodSplatterOnGround(position, size) {
                _ensureBloodPermanentAssets();

                const poolSize = 0.04 + size * 1.2 + Math.random() * 0.06;
                const segments = 12 + Math.floor(Math.random() * 6);

                // Reuse pooled mesh + cached distorted geometry (unit radius, scaled for size)
                const pool = _allocPermanentBloodMesh('pool');
                pool.geometry = _getDistortedBloodPoolGeometry(segments);
                pool.material.map = createBloodTexture();
                pool.material.color.copy(getBloodColor(0));
                pool.material.transparent = true;
                pool.material.opacity = 0.95;
                pool.material.roughness = 0.25;
                pool.material.metalness = 0.02;
                pool.material.side = THREE.DoubleSide;

                pool.position.set(position.x, 0.003 + Math.random() * 0.002, position.z);
                pool.rotation.x = -Math.PI / 2;
                pool.rotation.z = Math.random() * Math.PI * 2;
                pool.receiveShadow = true;
                scene.add(pool);
                pool.scale.set(poolSize * 0.2, poolSize * 0.2, 1);
                permanentBloodPools.push({ mesh: pool, age: 0, baseScale: poolSize, currentScale: 0.2, targetScale: 1, spreading: true });

                // Splatter droplets
                const splatterCount = 3 + Math.floor(Math.random() * 5);
                for (let i = 0; i < splatterCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = poolSize * (1 + Math.random() * 1.5);
                    const sSize = 0.006 + Math.random() * 0.02;
                    const splat = _allocPermanentBloodMesh('splat');
                    splat.geometry = _bloodSplatGeometry;
                    splat.material.color.copy(getBloodColor(0));
                    splat.material.transparent = true;
                    splat.material.opacity = 0.9;
                    splat.material.roughness = 0.3;
                    splat.material.side = THREE.DoubleSide;
                    splat.scale.set(sSize, sSize, 1);
                    splat.position.set(position.x + Math.cos(angle) * dist, 0.002, position.z + Math.sin(angle) * dist);
                    splat.rotation.x = -Math.PI / 2;
                    splat.rotation.z = Math.random() * Math.PI * 2;
                    scene.add(splat);
                    permanentBloodPools.push({ mesh: splat, age: 0, baseScale: sSize, currentScale: 1, targetScale: 1, spreading: false });
                }

                while (permanentBloodPools.length > MAX_PERMANENT_POOLS) {
                    const old = permanentBloodPools.shift();
                    _recyclePermanentBloodEntry(old);
                }
            }

            // Create blood drip sound
            function playBloodDripSound() {
                const ctx = ensureAudioContext();
                if (!ctx) return;

                const now = ctx.currentTime;

                // Wet splat sound
                const bufferSize = ctx.sampleRate * 0.05;
                const noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.15));
                }

                const noise = ctx.createBufferSource();
                noise.buffer = noiseBuffer;
                const filter = ctx.createBiquadFilter();
                const gain = ctx.createGain();
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(ctx.destination);
                filter.type = 'lowpass';
                filter.frequency.value = 800;
                gain.gain.setValueAtTime(0.03, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                noise.start(now);
            }

            // PERF: Pre-allocated vector for blood drip updates (avoids clone() per drip per frame)
            const _bloodDripTempVec = new THREE.Vector3();
            
            function updateBloodDrips(deltaTime) {
                // === Update falling blood drops (realistic gravity) ===
                for (let i = bloodDrips.length - 1; i >= 0; i--) {
                    const drip = bloodDrips[i];
                    drip.lifetime += deltaTime;

                    if (!drip.hasLanded) {
                        // Realistic gravity (9.8 m/s^2)
                        drip.velocity.y -= 9.8 * deltaTime;
                        drip.velocity.x *= 0.995;
                        drip.velocity.z *= 0.995;
                        // PERF: Use addScaledVector instead of clone().multiplyScalar()
                        drip.mesh.position.addScaledVector(drip.velocity, deltaTime);

                        // Teardrop stretch
                        const speed = drip.velocity.length();
                        drip.mesh.scale.y = 1 + speed * 0.06;
                        drip.mesh.scale.x = 1 - speed * 0.015;
                        drip.mesh.scale.z = 1 - speed * 0.015;

                        // Hit ground - create PERMANENT splatter
                        if (drip.mesh.position.y <= 0.01) {
                            drip.hasLanded = true;
                            const impactSpeed = Math.abs(drip.velocity.y);
                            // PERF: Pass position directly, createBloodSplatterOnGround only needs x,z
                            createBloodSplatterOnGround(drip.mesh.position, drip.size * impactSpeed * 0.15);
                            if (Math.random() > 0.65) playBloodDripSound();
                            scene.remove(drip.mesh);
                            // PERF: Recycle velocity back to pool
                            if (drip.velocity) _recycleBloodVelocity(drip.velocity);
                            // SAFETY: blood drops use shared geometry
                            drip.mesh.material.dispose();
                            bloodDrips.splice(i, 1);
                            continue;
                        }
                    }

                    if (drip.lifetime > 8) {
                        scene.remove(drip.mesh);
                        // PERF: Recycle velocity back to pool
                        if (drip.velocity) _recycleBloodVelocity(drip.velocity);
                        // SAFETY: blood drops use shared geometry
                        drip.mesh.material.dispose();
                        bloodDrips.splice(i, 1);
                    }
                }

                // === Update PERMANENT blood pools (spreading + coagulation, NO FADING) ===
                for (let i = 0; i < permanentBloodPools.length; i++) {
                    const pool = permanentBloodPools[i];
                    pool.age += deltaTime;

                    // Spreading (blood expands when fresh)
                    if (pool.spreading && pool.currentScale < pool.targetScale) {
                        pool.currentScale += deltaTime * 0.6;
                        if (pool.currentScale >= pool.targetScale) {
                            pool.currentScale = pool.targetScale;
                            pool.spreading = false;
                        }
                        const base = pool.baseScale || 1;
                        const s = base * pool.currentScale;
                        pool.mesh.scale.set(s, s, 1);
                    }

                    // Coagulation: blood DARKENS over time (never fades!)
                    if (pool.age < 120) {
                        const ageRatio = pool.age / 120;
                        pool.mesh.material.color.copy(getBloodColor(ageRatio));
                        pool.mesh.material.roughness = 0.25 + ageRatio * 0.5; // Gets less glossy (dries)
                    }
                    // Blood stays FOREVER - no removal!
                }

                // === Blood from wounded enemy ===
                if (enemy && enemy.visible && gameState.enemyHealth < 80 && gameState.enemyHealth > 0) {
                    enemyBloodTimer += deltaTime;
                    const woundSeverity = (80 - gameState.enemyHealth) / 80;
                    const dripRate = 0.35 - woundSeverity * 0.28;

                    if (enemyBloodTimer >= dripRate) {
                        _enemyDripPos.copy(enemy.position);
                        _enemyDripPos.y += 0.4 + Math.random() * 0.5;
                        const numDrops = 1 + Math.floor(woundSeverity * 2);
                        for (let d = 0; d < numDrops; d++) {
                            // createBloodDrip copies position, so we can reuse _enemyDripPos
                            createBloodDrip(_enemyDripPos);
                        }
                        enemyBloodTimer = 0;
                    }

                    // Blood trail when wounded enemy moves
                    if (lastEnemyPosition) {
                        const moved = enemy.position.distanceTo(lastEnemyPosition);
                        if (moved > 0.25 && woundSeverity > 0.25) {
                            // Drop small blood trail - PERF: Use temp vector
                            _enemyTrailPos.copy(enemy.position);
                            _enemyTrailPos.x += (Math.random() - 0.5) * 0.3;
                            _enemyTrailPos.z += (Math.random() - 0.5) * 0.3;
                            createBloodSplatterOnGround(_enemyTrailPos, 0.01 + woundSeverity * 0.02);
                        }
                    }
                    // PERF: Lazy-init lastEnemyPosition once, then update in-place
                    if (!lastEnemyPosition) lastEnemyPosition = new THREE.Vector3();
                    lastEnemyPosition.copy(enemy.position);
                }
            }

            // --- ADRENALINE MODE (Unique Feature!) ---
            // Time slows slightly when player health is critical - like a survival instinct
            let adrenalineActive = false;
            let adrenalineTimer = 0;
            const ADRENALINE_THRESHOLD = 25; // Activate below 25 health

            function updateAdrenaline(deltaTime) {
                const shouldBeActive = gameState.playerHealth <= ADRENALINE_THRESHOLD &&
                    gameState.playerHealth > 0 &&
                    gameState.started &&
                    !gameState.isDying;

                if (shouldBeActive && !adrenalineActive) {
                    // Activate adrenaline
                    adrenalineActive = true;
                    adrenalineTimer = 0;
                    console.log('💉 ADRENALINE ACTIVATED - Time slowing...');
                } else if (!shouldBeActive && adrenalineActive) {
                    // Deactivate adrenaline
                    adrenalineActive = false;
                    console.log('💉 Adrenaline fading...');
                }

                if (adrenalineActive) {
                    adrenalineTimer += deltaTime;
                    // Pulse effect on camera FOV
                    const pulse = Math.sin(adrenalineTimer * 4) * 2;
                    camera.fov = 75 + pulse;
                    camera.updateProjectionMatrix();

                    // Return modified deltaTime for slow-mo effect
                    return deltaTime * 0.7; // 30% slower when in adrenaline
                }
                return deltaTime;
            }

            // --- BULLET HOLES (Unique - persistent damage to environment) ---
            const bulletHoles = [];
            const MAX_BULLET_HOLES = 50;
            
            // PERF: Pre-allocated geometry and vector for bullet holes
            let _bulletHoleGeometry = null;
            const _bulletHoleTempVec = new THREE.Vector3();
            const _bulletHoleLookAt = new THREE.Vector3();

            function createBulletHole(position, normal) {
                // PERF: Lazy-init shared geometry
                if (!_bulletHoleGeometry) {
                    _bulletHoleGeometry = new THREE.CircleGeometry(0.04, 8); // Use max size, scale down
                }
                
                const holeMaterial = new THREE.MeshBasicMaterial({
                    color: 0x111111,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });
                const hole = new THREE.Mesh(_bulletHoleGeometry, holeMaterial);
                const sizeScale = (0.03 + Math.random() * 0.02) / 0.04;
                hole.scale.setScalar(sizeScale);

                // Position slightly off surface - PERF: Use addScaledVector
                hole.position.copy(position);
                hole.position.addScaledVector(normal, 0.01);

                // Orient to surface - PERF: Use temp vector instead of clone
                _bulletHoleLookAt.copy(position).add(normal);
                hole.lookAt(_bulletHoleLookAt);

                scene.add(hole);
                bulletHoles.push({
                    mesh: hole,
                    lifetime: 0
                });

                // Remove oldest holes if too many
                while (bulletHoles.length > MAX_BULLET_HOLES) {
                    const old = bulletHoles.shift();
                    scene.remove(old.mesh);
                    // PERF: Don't dispose shared geometry
                    old.mesh.material.dispose();
                }
            }

            // --- COMBAT INTENSITY HEARTBEAT (Unique!) ---
            // Heartbeat sound when in intense combat
            let combatIntensity = 0;
            let lastHeartbeatTime = 0;

            function updateCombatIntensity(deltaTime) {
                // Intensity increases when shooting or taking damage
                // Decays over time
                combatIntensity = Math.max(0, combatIntensity - deltaTime * 0.5);

                // Play heartbeat when intensity is high
                if (combatIntensity > 0.7 || adrenalineActive) {
                    const heartbeatInterval = adrenalineActive ? 0.4 : 0.6;
                    lastHeartbeatTime += deltaTime;

                    if (lastHeartbeatTime >= heartbeatInterval) {
                        playHeartbeatSound();
                        lastHeartbeatTime = 0;
                    }
                }
            }

            function increaseCombatIntensity(amount = 0.3) {
                combatIntensity = Math.min(1, combatIntensity + amount);
            }

            function playHeartbeatSound() {
                const ctx = ensureAudioContext();
                if (!ctx) return;

                const now = ctx.currentTime;
                const volume = adrenalineActive ? 0.15 : 0.08;

                // Double thump heartbeat
                for (let i = 0; i < 2; i++) {
                    const thump = ctx.createOscillator();
                    const thumpGain = ctx.createGain();
                    thump.connect(thumpGain);
                    thumpGain.connect(ctx.destination);

                    thump.frequency.setValueAtTime(50, now + i * 0.12);
                    thump.frequency.exponentialRampToValueAtTime(30, now + i * 0.12 + 0.08);
                    thumpGain.gain.setValueAtTime(volume, now + i * 0.12);
                    thumpGain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.12 + 0.1);
                    thump.start(now + i * 0.12);
                    thump.stop(now + i * 0.12 + 0.1);
                }
            }

            // Load animated weapon model from GLB
            function loadAnimatedWeapon(weaponType, callback) {
                // Only load rifle - all other weapons use procedural fallback
                if (weaponType !== 'rifle') {
                    callback(null);
                    return;
                }

                const modelPath = 'gun/gunmodels/animated_rifle.glb';

                // Perfect rifle positioning
                const perfectScale = 0.95;
                const perfectPos = { x: 0.13, y: -1.52, z: 0.03 };
                const perfectRot = { x: 0, y: 3.1, z: 0 };

                // --- FIXED CLONING FUNCTION ---
                // Maps bones by NAME instead of index for reliable skeleton cloning
                function cloneWithSkeleton(source) {
                    const clone = source.clone(true);

                    // 1. Create a look-up table for the CLONED nodes by name
                    const cloneNodes = {};
                    clone.traverse((node) => {
                        cloneNodes[node.name] = node;
                    });

                    // 2. Find all SkinnedMeshes in the clone and rebind their skeletons
                    clone.traverse((node) => {
                        if (node.isSkinnedMesh) {
                            const originalMesh = source.getObjectByName(node.name);

                            // 3. Map the original bones to the NEW cloned bones by Name
                            if (originalMesh && originalMesh.skeleton) {
                                const originalBones = originalMesh.skeleton.bones;
                                const clonedBones = [];

                                for (let i = 0; i < originalBones.length; i++) {
                                    const boneName = originalBones[i].name;
                                    const newBone = cloneNodes[boneName];

                                    // Critical: If we find the new bone, use it. Otherwise fallback
                                    if (newBone) {
                                        clonedBones.push(newBone);
                                    } else {
                                        console.warn('Bone not found in clone:', boneName);
                                        clonedBones.push(originalBones[i]); // Emergency fallback
                                    }
                                }

                                // 4. Bind the new skeleton to the new mesh
                                const newSkeleton = new THREE.Skeleton(clonedBones, originalMesh.skeleton.boneInverses);
                                node.bind(newSkeleton, originalMesh.bindMatrix);
                            }
                        }
                    });

                    return clone;
                }

                // Check if already loaded
                if (loadedWeaponModels[weaponType]) {
                    console.log('🔫 Using cached rifle model (Fixed Skeleton)');
                    const cached = loadedWeaponModels[weaponType];

                    // Use the FIXED skeleton cloning logic
                    const clonedModel = cloneWithSkeleton(cached.model);

                    // CRITICAL: Re-apply perfect positioning to the clone
                    clonedModel.scale.set(perfectScale, perfectScale, perfectScale);
                    clonedModel.position.set(perfectPos.x, perfectPos.y, perfectPos.z);
                    clonedModel.rotation.set(perfectRot.x, perfectRot.y, perfectRot.z);

                    // Re-apply mesh settings
                    clonedModel.traverse((child) => {
                        if (child.isMesh) {
                            child.frustumCulled = false;
                            if (child.material) child.material.side = THREE.DoubleSide;
                        }
                    });

                    callback(clonedModel, cached.animations);
                    return;
                }

                // Initial Loader
                const loader = new THREE.GLTFLoader();
                loader.load(modelPath, function (gltf) {
                    console.log('✅ Loaded rifle GLB');
                    console.log('   Animations found:', gltf.animations.length);
                    gltf.animations.forEach((anim, i) => {
                        console.log('   - Animation ' + i + ':', anim.name);
                    });

                    const model = gltf.scene;

                    // Apply perfect rifle positioning
                    model.scale.set(perfectScale, perfectScale, perfectScale);
                    model.position.set(perfectPos.x, perfectPos.y, perfectPos.z);
                    model.rotation.set(perfectRot.x, perfectRot.y, perfectRot.z);

                    console.log('🔫 Rifle positioned - scale:', perfectScale, 'pos:', model.position);

                    // Enable proper rendering
                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = false;
                            child.receiveShadow = false;
                            child.frustumCulled = false;
                            if (child.material) {
                                child.material.side = THREE.DoubleSide;
                            }
                        }
                    });

                    // Cache it - save a deep clone
                    loadedWeaponModels[weaponType] = {
                        model: model.clone(true),
                        animations: gltf.animations
                    };

                    // Update loading progress
                    if (window.LoadingScreen) {
                        LoadingScreen.assetLoaded('rifle_model');
                        LoadingScreen.setStatus('INITIALIZING UI...');
                    }

                    callback(model, gltf.animations);

                }, function (xhr) {
                    console.log('Loading rifle: ' + (xhr.loaded / xhr.total * 100).toFixed(0) + '%');
                }, function (error) {
                    console.error('❌ Error loading rifle:', error);
                    // Update loading progress even on error
                    if (window.LoadingScreen) {
                        LoadingScreen.assetLoaded('rifle_model');
                        LoadingScreen.setStatus('INITIALIZING UI...');
                    }
                    callback(null);
                });
            }

            // Play weapon animation - finds matching animation by name (case-insensitive, partial match)
            function playWeaponAnimation(animName) {
                if (!weaponAnimationMixer) {
                    return false;
                }

                // First try exact match
                if (weaponAnimations[animName]) {
                    const action = weaponAnimationMixer.clipAction(weaponAnimations[animName]);
                    action.reset();
                    action.setLoop(THREE.LoopOnce, 1);
                    action.clampWhenFinished = true;
                    action.play();
                    console.log('🎬 Playing animation:', animName);
                    return true;
                }

                // Try case-insensitive and partial match
                const searchName = animName.toLowerCase();
                for (const [name, clip] of Object.entries(weaponAnimations)) {
                    if (name.toLowerCase().includes(searchName) || searchName.includes(name.toLowerCase())) {
                        const action = weaponAnimationMixer.clipAction(clip);
                        action.reset();
                        action.setLoop(THREE.LoopOnce, 1);
                        action.clampWhenFinished = true;
                        action.play();
                        console.log('🎬 Playing animation (matched):', name, 'for', animName);
                        return true;
                    }
                }

                return false;
            }

            // Update weapon animations (call in render loop)
            function updateWeaponAnimations() {
                if (weaponAnimationMixer) {
                    const delta = weaponClock.getDelta();
                    weaponAnimationMixer.update(delta);
                }
            }

            // Fallback: Create detailed AK-47 model (used if GLB fails to load)
            function createAK47() {
                const weaponGroup = new THREE.Group();

                // Receiver (main body)
                const receiverGeo = new THREE.BoxGeometry(0.04, 0.06, 0.35);
                const receiverMat = new THREE.MeshStandardMaterial({
                    color: 0x2a2a2a,
                    metalness: 0.7,
                    roughness: 0.4
                });
                const receiver = new THREE.Mesh(receiverGeo, receiverMat);
                receiver.position.set(0, 0, -0.1);
                weaponGroup.add(receiver);

                // Barrel
                const barrelGeo = new THREE.CylinderGeometry(0.008, 0.008, 0.25, 12);
                const barrelMat = new THREE.MeshStandardMaterial({
                    color: 0x1a1a1a,
                    metalness: 0.9,
                    roughness: 0.2
                });
                const barrel = new THREE.Mesh(barrelGeo, barrelMat);
                barrel.rotation.x = Math.PI / 2;
                barrel.position.set(0, 0.01, -0.35);
                weaponGroup.add(barrel);

                // Gas tube (top of barrel)
                const gasTubeGeo = new THREE.CylinderGeometry(0.006, 0.006, 0.2, 8);
                const gasTube = new THREE.Mesh(gasTubeGeo, barrelMat);
                gasTube.rotation.x = Math.PI / 2;
                gasTube.position.set(0, 0.025, -0.3);
                weaponGroup.add(gasTube);

                // Magazine
                const magGeo = new THREE.BoxGeometry(0.025, 0.12, 0.08);
                const magMat = new THREE.MeshStandardMaterial({
                    color: 0x3a2a1a,
                    metalness: 0.3,
                    roughness: 0.8
                });
                const magazine = new THREE.Mesh(magGeo, magMat);
                magazine.position.set(0, -0.08, -0.05);
                magazine.rotation.x = -0.1;
                weaponGroup.add(magazine);

                // Stock
                const stockGeo = new THREE.BoxGeometry(0.03, 0.04, 0.15);
                const stockMat = new THREE.MeshStandardMaterial({
                    color: 0x4a3a2a,
                    metalness: 0.1,
                    roughness: 0.9
                });
                const stock = new THREE.Mesh(stockGeo, stockMat);
                stock.position.set(0, 0.01, 0.15);
                weaponGroup.add(stock);

                // Pistol grip
                const gripGeo = new THREE.BoxGeometry(0.025, 0.08, 0.04);
                const grip = new THREE.Mesh(gripGeo, stockMat);
                grip.position.set(0, -0.05, 0.02);
                grip.rotation.x = 0.3;
                weaponGroup.add(grip);

                // Front sight
                const sightGeo = new THREE.BoxGeometry(0.015, 0.02, 0.005);
                const sightMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, metalness: 0.8 });
                const frontSight = new THREE.Mesh(sightGeo, sightMat);
                frontSight.position.set(0, 0.04, -0.4);
                weaponGroup.add(frontSight);

                // Rear sight
                const rearSight = new THREE.Mesh(sightGeo, sightMat);
                rearSight.position.set(0, 0.04, 0.05);
                weaponGroup.add(rearSight);

                // Muzzle brake
                const muzzleGeo = new THREE.CylinderGeometry(0.012, 0.01, 0.03, 8);
                const muzzle = new THREE.Mesh(muzzleGeo, barrelMat);
                muzzle.rotation.x = Math.PI / 2;
                muzzle.position.set(0, 0.01, -0.48);
                weaponGroup.add(muzzle);

                weaponGroup.position.set(0.12, -0.12, -0.25);
                weaponGroup.rotation.set(0, 0, 0);

                // Disable shadows for weapon (first-person view)
                weaponGroup.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = false;
                        child.receiveShadow = false;
                    }
                });

                return weaponGroup;
            }

            // Create detailed AWP Sniper
            function createAWP() {
                const weaponGroup = new THREE.Group();

                // Main body (longer, sleeker)
                const bodyGeo = new THREE.BoxGeometry(0.035, 0.05, 0.5);
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: 0x1a3a2a,
                    metalness: 0.6,
                    roughness: 0.3
                });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.set(0, 0, -0.15);
                weaponGroup.add(body);

                // Long barrel
                const barrelGeo = new THREE.CylinderGeometry(0.01, 0.01, 0.4, 16);
                const barrelMat = new THREE.MeshStandardMaterial({
                    color: 0x0a0a0a,
                    metalness: 0.95,
                    roughness: 0.1
                });
                const barrel = new THREE.Mesh(barrelGeo, barrelMat);
                barrel.rotation.x = Math.PI / 2;
                barrel.position.set(0, 0.01, -0.5);
                weaponGroup.add(barrel);

                // Scope
                const scopeBodyGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.15, 16);
                const scopeMat = new THREE.MeshStandardMaterial({
                    color: 0x1a1a1a,
                    metalness: 0.8,
                    roughness: 0.2
                });
                const scopeBody = new THREE.Mesh(scopeBodyGeo, scopeMat);
                scopeBody.rotation.z = Math.PI / 2;
                scopeBody.position.set(0, 0.06, -0.1);
                weaponGroup.add(scopeBody);

                // Scope lens (front)
                const lensGeo = new THREE.CylinderGeometry(0.018, 0.018, 0.01, 16);
                const lensMat = new THREE.MeshStandardMaterial({
                    color: 0x4444aa,
                    metalness: 0.9,
                    roughness: 0.05,
                    emissive: 0x111133
                });
                const frontLens = new THREE.Mesh(lensGeo, lensMat);
                frontLens.rotation.z = Math.PI / 2;
                frontLens.position.set(0, 0.06, -0.175);
                weaponGroup.add(frontLens);

                // Scope lens (rear)
                const rearLens = new THREE.Mesh(lensGeo, lensMat);
                rearLens.rotation.z = Math.PI / 2;
                rearLens.position.set(0, 0.06, -0.025);
                weaponGroup.add(rearLens);

                // Bipod legs
                const bipodGeo = new THREE.CylinderGeometry(0.003, 0.003, 0.08, 6);
                const bipodMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, metalness: 0.7 });
                const bipodLeft = new THREE.Mesh(bipodGeo, bipodMat);
                bipodLeft.position.set(-0.03, -0.05, -0.35);
                bipodLeft.rotation.z = 0.3;
                weaponGroup.add(bipodLeft);

                const bipodRight = new THREE.Mesh(bipodGeo, bipodMat);
                bipodRight.position.set(0.03, -0.05, -0.35);
                bipodRight.rotation.z = -0.3;
                weaponGroup.add(bipodRight);

                // Stock
                const stockGeo = new THREE.BoxGeometry(0.04, 0.05, 0.12);
                const stockMat = new THREE.MeshStandardMaterial({
                    color: 0x3a2a1a,
                    metalness: 0.2,
                    roughness: 0.8
                });
                const stock = new THREE.Mesh(stockGeo, stockMat);
                stock.position.set(0, 0.01, 0.25);
                weaponGroup.add(stock);

                // Cheek rest
                const cheekGeo = new THREE.BoxGeometry(0.035, 0.02, 0.08);
                const cheekRest = new THREE.Mesh(cheekGeo, stockMat);
                cheekRest.position.set(0, 0.045, 0.2);
                weaponGroup.add(cheekRest);

                weaponGroup.position.set(0.15, -0.15, -0.3);
                weaponGroup.rotation.set(0, 0, 0);

                // Disable shadows for weapon (first-person view)
                weaponGroup.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = false;
                        child.receiveShadow = false;
                    }
                });

                return weaponGroup;
            }

            // Create detailed Desert Eagle

            function createDesertEagle() {
                const pistol = new THREE.Group();

                // Slide (top part)
                const slide = new THREE.Mesh(
                    new THREE.BoxGeometry(0.03, 0.04, 0.15),
                    new THREE.MeshStandardMaterial({ color: 0x1a1a1a, metalness: 0.9, roughness: 0.3 })
                );
                slide.position.set(0, 0.02, 0);
                pistol.add(slide);

                // Grip
                const grip = new THREE.Mesh(
                    new THREE.BoxGeometry(0.025, 0.08, 0.04),
                    new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.8 })
                );
                grip.position.set(0, -0.03, -0.03);
                pistol.add(grip);

                // Barrel
                const barrel = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.008, 0.008, 0.08, 8),
                    new THREE.MeshStandardMaterial({ color: 0x0a0a0a, metalness: 1, roughness: 0.2 })
                );
                barrel.rotation.z = Math.PI / 2;
                barrel.position.set(0, 0.01, 0.08);
                pistol.add(barrel);

                // Trigger
                const trigger = new THREE.Mesh(
                    new THREE.BoxGeometry(0.01, 0.02, 0.01),
                    new THREE.MeshStandardMaterial({ color: 0x1a1a1a })
                );
                trigger.position.set(0, -0.01, -0.01);
                pistol.add(trigger);

                pistol.position.set(0.1, -0.1, -0.2);
                return pistol;
            }



            // Weapon sway and animation



            function updateWeaponPosition(deltaTime) {



                if (!currentWeaponMesh) return;

                // Skip all position/rotation updates when position selector is active
                // This allows the selector to have full control
                if (positionSelectorActive) return;

                weaponSwayTime += deltaTime;

                // Get base position from weapon type
                // Check if this is a GLB model (has animations) vs procedural
                const isGLBModel = weaponAnimationMixer !== null;

                let baseX, baseY, baseZ;
                if (isGLBModel && gameState.currentWeapon === 'rifle') {
                    // GLB rifle - user-configured perfect position
                    baseX = 0.13; baseY = -1.52; baseZ = 0.03;
                } else if (gameState.currentWeapon === 'sniper') {
                    baseX = 0.15; baseY = -0.15; baseZ = -0.3;
                } else if (gameState.currentWeapon === 'pistol') {
                    baseX = 0.1; baseY = -0.1; baseZ = -0.2;
                } else {
                    // Default procedural weapon position
                    baseX = 0.12; baseY = -0.12; baseZ = -0.25;
                }

                // Enhanced movement bob with better curves
                let bobX = 0, bobY = 0, bobZ = 0;
                if (gameState.isMoving) {
                    const speed = gameState.movementSpeed;
                    const sprintMultiplier = gameState.isSprinting ? 1.8 : 1;
                    weaponBobOffset += deltaTime * 8 * speed * sprintMultiplier;

                    // More realistic walking bob
                    bobX = Math.sin(weaponBobOffset) * 0.015 * speed;
                    bobY = Math.abs(Math.cos(weaponBobOffset * 0.5)) * 0.02 * speed;
                    bobZ = Math.sin(weaponBobOffset * 0.7) * 0.01 * speed;
                } else {
                    // Smooth return to idle
                    weaponBobOffset = lerp(weaponBobOffset, 0, deltaTime * 5);
                }

                // Idle weapon sway (breathing effect)
                if (!gameState.isMoving && weaponRecoilOffset < 0.01) {
                    weaponIdleSway.x = Math.sin(weaponSwayTime * 0.5) * 0.003;
                    weaponIdleSway.y = Math.cos(weaponSwayTime * 0.7) * 0.002;
                    weaponIdleSway.z = Math.sin(weaponSwayTime * 0.3) * 0.001;
                } else {
                    // Smooth return to zero
                    weaponIdleSway.x = lerp(weaponIdleSway.x, 0, deltaTime * 3);
                    weaponIdleSway.y = lerp(weaponIdleSway.y, 0, deltaTime * 3);
                    weaponIdleSway.z = lerp(weaponIdleSway.z, 0, deltaTime * 3);
                }

                // Physics-based weapon sway (from mouse movement)
                const swayLerpFactor = 0.1;
                const targetSwayX = weaponPhysics.sway.x * 0.001;
                const targetSwayY = -weaponPhysics.sway.y * 0.001;
                weaponPhysics.lastMouseX = lerp(weaponPhysics.lastMouseX, targetSwayX, swayLerpFactor);
                weaponPhysics.lastMouseY = lerp(weaponPhysics.lastMouseY, targetSwayY, swayLerpFactor);

                // Smooth recoil recovery with curve
                if (weaponRecoilOffset > 0) {
                    const recoverySpeed = 6 + weaponRecoilOffset * 10; // Faster recovery when more recoil
                    weaponRecoilOffset -= deltaTime * recoverySpeed;
                    if (weaponRecoilOffset < 0) weaponRecoilOffset = 0;

                    // Recoil rotation (smooth, not random)
                    weaponRecoilRotation.x = weaponRecoilOffset * 0.8;
                    weaponRecoilRotation.y = lerp(weaponRecoilRotation.y, weaponRecoilY, deltaTime * 10);
                } else {
                    // Smooth rotation recovery
                    weaponRecoilRotation.x = lerp(weaponRecoilRotation.x, 0, deltaTime * 8);
                    weaponRecoilRotation.y = lerp(weaponRecoilRotation.y, 0, deltaTime * 8);
                    weaponRecoilY = lerp(weaponRecoilY, 0, deltaTime * 8);
                }

                // Apply physics-based recoil decay (from test file formula)
                if (weaponPhysics.recoil.kick > 0) {
                    weaponPhysics.recoil.kick -= weaponPhysics.recoil.kick * 10 * deltaTime;
                }
                if (weaponPhysics.recoil.rot > 0) {
                    weaponPhysics.recoil.rot -= weaponPhysics.recoil.rot * 10 * deltaTime;
                }

                // Apply all offsets to base position
                currentWeaponMesh.position.x = baseX + bobX + weaponIdleSway.x + weaponPhysics.lastMouseX;
                currentWeaponMesh.position.y = baseY + bobY + weaponIdleSway.y + weaponPhysics.lastMouseY;
                currentWeaponMesh.position.z = baseZ + weaponRecoilOffset + bobZ + weaponIdleSway.z - weaponPhysics.recoil.kick * 0.1;

                // Apply rotations with physics recoil
                // GLB models need base rotation of 3.1 on Y axis
                const baseRotY = isGLBModel ? 3.1 : 0;
                currentWeaponMesh.rotation.x = weaponRecoilRotation.x + weaponRecoilOffset * 0.3 + weaponPhysics.recoil.rot * 0.5;
                currentWeaponMesh.rotation.y = baseRotY + weaponRecoilRotation.y;
                currentWeaponMesh.rotation.z = weaponIdleSway.z * 2;
            }

            // Apply weapon recoil
            function applyWeaponRecoil(amount) {
                weaponRecoilOffset = amount;
                // Set random horizontal recoil direction (only when applying recoil)
                weaponRecoilY = (Math.random() - 0.5) * amount * 0.3;
            }

            // ==========================================
            // KINETIC BLEND MOTION SYSTEM
            // High-fidelity gait transition with smooth damping
            // ==========================================

            // Frame-rate independent interpolation (from preview)
            const kineticDamp = (curr, target, lambda, dt) => {
                return curr + (target - curr) * (1 - Math.exp(-lambda * dt));
            };

            // Kinetic blend state
            const kineticState = {
                // Mouse accumulator (raw input buffer)
                mouseAccumX: 0,
                mouseAccumY: 0,

                // Smoothed rotation (what camera actually uses)
                smoothRotX: 0,
                smoothRotY: 0,

                // Run blend factor (0=walk, 1=run)
                runBlend: 0,

                // Step cycle timer
                stepCycle: 0,

                // Position offsets (applied to camera)
                posOffsetX: 0,
                posOffsetY: 0,

                // Rotation offsets (subtle tilt)
                rotOffsetX: 0,  // Pitch dip
                rotOffsetZ: 0,  // Roll tilt

                // Parameters (from preview - KEEP LOW for non-aggressive)
                posAmt: 0.14,           // Body bob amplitude (meters)
                rotAmt: 0.005,          // Head tilt amplitude (radians) - VERY LOW!
                stepFreqWalk: 8.5,      // Steps per second walking
                stepFreqRun: 15.0,      // Steps per second running
                mouseSmoothLambda: 20,  // Mouse interpolation speed
                posSmoothLambda: 15,    // Position interpolation speed
                rotSmoothLambda: 10     // Rotation interpolation speed
            };

            // Update kinetic blend each frame
            function updateKineticBlend(dt) {
                if (!gameState.started || gameState.paused || gameState.isDying) return;

                // === SMOOTH MOUSE ROTATION (for crosshair deadzone) ===
                kineticState.smoothRotX = kineticDamp(
                    kineticState.smoothRotX,
                    kineticState.mouseAccumX,
                    kineticState.mouseSmoothLambda,
                    dt
                );
                kineticState.smoothRotY = kineticDamp(
                    kineticState.smoothRotY,
                    kineticState.mouseAccumY,
                    kineticState.mouseSmoothLambda,
                    dt
                );

                // === RUN BLEND (Smooth walk/run transition) ===
                const isRunning = gameState.isSprinting && gameState.movementSpeed > 0.5;
                const targetRunBlend = isRunning ? 1.0 : 0.0;
                kineticState.runBlend = kineticDamp(kineticState.runBlend, targetRunBlend, 3.0, dt);

                // === STEP CYCLE (Speed-scaled animation timer) ===
                const currentSpeed = gameState.movementSpeed || 0;
                const walkSpeed = 0.5;  // Normalized walk threshold
                const runSpeed = 1.0;   // Normalized run threshold

                const currentFreq = kineticState.stepFreqWalk +
                    (kineticState.runBlend * (kineticState.stepFreqRun - kineticState.stepFreqWalk));

                if (currentSpeed > 0.1 && gameState.isMoving && gameState.onGround) {
                    // Scale cycle by normalized speed
                    const speedRatio = Math.min(currentSpeed / runSpeed, 1.2);
                    kineticState.stepCycle += dt * currentFreq * speedRatio;
                } else {
                    // Idle - gentle breathing
                    kineticState.stepCycle += dt * 1.0;
                }

                // === GENERATE BOB CURVES ===
                const sineWave = Math.sin(kineticState.stepCycle);
                const cosWave = Math.cos(kineticState.stepCycle * 0.5);

                // Walk bob: soft bounce
                const walkBob = sineWave * sineWave;
                // Run bob: sharper aggressive dip
                const runBob = Math.sin(kineticState.stepCycle + Math.PI / 2);

                // Blend curves
                const finalBobEnvelope = walkBob * (1 - kineticState.runBlend) + runBob * kineticState.runBlend;

                // Speed multiplier (fades out when stopped)
                const speedMultiplier = Math.min(currentSpeed / walkSpeed, 1.2);
                const isMovingAndGrounded = gameState.isMoving && gameState.onGround && currentSpeed > 0.1;

                // === POSITION OFFSETS (Applied to camera Y/X) ===
                const targetPosY = isMovingAndGrounded ? finalBobEnvelope * kineticState.posAmt * speedMultiplier : 0;
                const targetPosX = isMovingAndGrounded ? cosWave * (kineticState.posAmt * 0.5) * speedMultiplier : 0;

                kineticState.posOffsetY = kineticDamp(kineticState.posOffsetY, targetPosY, kineticState.posSmoothLambda, dt);
                kineticState.posOffsetX = kineticDamp(kineticState.posOffsetX, targetPosX, kineticState.posSmoothLambda, dt);

                // === ROTATION OFFSETS (VERY SUBTLE - from preview) ===
                const rotOscillation = Math.cos(kineticState.stepCycle) * (kineticState.rotAmt * (1 + kineticState.runBlend));

                // Bank into turns (strafe tilt)
                let strafeTilt = 0;
                if (typeof moveLeft !== 'undefined' && typeof moveRight !== 'undefined') {
                    if (moveLeft) strafeTilt = 0.015;
                    if (moveRight) strafeTilt = -0.015;
                }

                const targetRotZ = isMovingAndGrounded ? (strafeTilt + rotOscillation * kineticState.runBlend) : 0;
                const targetRotX = isMovingAndGrounded ? Math.abs(sineWave) * (kineticState.rotAmt * 2) * speedMultiplier : 0;

                kineticState.rotOffsetZ = kineticDamp(kineticState.rotOffsetZ, targetRotZ, kineticState.rotSmoothLambda, dt);
                kineticState.rotOffsetX = kineticDamp(kineticState.rotOffsetX, targetRotX, kineticState.rotSmoothLambda, dt);
            }

            // Dynamic Crosshair - Physics-based realistic motion with heat system
            let crosshairElement = null;


            // Crosshair physics state
            const crosshairState = {
                // Direct recoil (applied instantly, decays smoothly)
                recoilKick: 0,
                recoilDrift: 0,
                recoilRotation: 0, // New rotational kick

                // Heat system - accumulates when shooting, decays over time
                heat: 0,

                // Parallax from mouse movement (3D effect)
                parallaxX: 0,
                parallaxY: 0,

                // Smoothed values for display
                smoothX: 0,
                smoothY: 0,
                smoothRot: 0,
                
                // Circle morph state (used for spray/overheat)
                isSprayCircle: false,

                lastTime: 0
            };

            function updateCrosshair() {
                if (!crosshairElement) {
                    crosshairElement = document.getElementById('crosshair');
                }
                if (!crosshairElement) return;

                const now = performance.now();
                const dt = Math.min((now - crosshairState.lastTime) / 1000, 0.05);
                crosshairState.lastTime = now;
                if (dt <= 0) return;

                // === SPRAY DETECTION ===
                // Morph into a circle when the player has been spraying (sustained fire).
                // Use the existing spray accumulator (sprayRecoilMultiplier) + hysteresis.
                const spray = (typeof sprayRecoilMultiplier === 'number' && isFinite(sprayRecoilMultiplier)) ? sprayRecoilMultiplier : 1.0;
                const SPRAY_CIRCLE_ON = 1.75;
                const SPRAY_CIRCLE_OFF = 1.35;
                if (!crosshairState.isSprayCircle) {
                    if (spray >= SPRAY_CIRCLE_ON) crosshairState.isSprayCircle = true;
                } else {
                    if (spray <= SPRAY_CIRCLE_OFF) crosshairState.isSprayCircle = false;
                }
                crosshairElement.classList.toggle('running', crosshairState.isSprayCircle);

                // === RECOIL DECAY ===
                crosshairState.recoilKick *= 0.85;
                crosshairState.recoilDrift *= 0.88; // Slightly looser drift decay
                crosshairState.recoilRotation *= 0.82; // Snappy rotation return

                if (Math.abs(crosshairState.recoilKick) < 0.1) crosshairState.recoilKick = 0;
                if (Math.abs(crosshairState.recoilDrift) < 0.05) crosshairState.recoilDrift = 0;
                if (Math.abs(crosshairState.recoilRotation) < 0.1) crosshairState.recoilRotation = 0;

                // === HEAT DECAY ===
                crosshairState.heat *= 0.96;
                if (crosshairState.heat < 0.01) crosshairState.heat = 0;

                // === WALKING BOB ===
                let walkX = 0;
                let walkY = 0;

                if (typeof gameState !== 'undefined' && gameState.isMoving && gameState.headBobPhase) {
                    const intensity = gameState.isSprinting ? 2.0 : 1.0;
                    walkX = Math.sin(gameState.headBobPhase) * intensity;
                    walkY = Math.abs(Math.sin(gameState.headBobPhase * 2)) * intensity * 0.6;
                }

                // === LEAN ===
                let leanX = 0;
                if (typeof gameState !== 'undefined' && gameState.lean) {
                    leanX = gameState.lean * 6;
                }

                // === RELOAD ===
                let reloadX = 0;
                if (typeof gameState !== 'undefined' && gameState.isReloading) {
                    const reloadTime = (now % 2000) / 2000;
                    reloadX = Math.sin(reloadTime * Math.PI) * 4;
                }

                // === COMBINE ===
                const targetX = walkX + leanX + reloadX + crosshairState.recoilDrift;
                const targetY = walkY + crosshairState.recoilKick;

                // Rotation from movement + Recoil Rotation
                let targetRot = crosshairState.recoilRotation;
                if (typeof gameState !== 'undefined' && gameState.isMoving && gameState.headBobPhase) {
                    targetRot += Math.sin(gameState.headBobPhase * 0.5) * (gameState.isSprinting ? 1.0 : 0.5);
                }

                // === SMOOTH INTERPOLATION ===
                const smoothFactor = 0.12;

                crosshairState.smoothX += (targetX - crosshairState.smoothX) * smoothFactor;
                crosshairState.smoothY += (targetY - crosshairState.smoothY) * smoothFactor;
                crosshairState.smoothRot += (targetRot - crosshairState.smoothRot) * smoothFactor;

                // === COLOR BASED ON HEAT ===
                const heatClamped = Math.min(1, crosshairState.heat);
                const r = 255;
                const g = Math.round(255 * (1 - heatClamped));
                const b = Math.round(255 * (1 - heatClamped));
                const color = `rgb(${r}, ${g}, ${b})`;

                // === KINETIC BLEND: DEADZONE FLOAT ===
                // Crosshair lags behind mouse movement (less aggressive)
                const deadzoneCX = (kineticState.mouseAccumX - kineticState.smoothRotX) * 120;
                const deadzoneCY = (kineticState.mouseAccumY - kineticState.smoothRotY) * 120;

                // === APPLY WITH PARALLAX + DEADZONE ===
                const finalX = crosshairState.smoothX + (crosshairState.parallaxX || 0) - deadzoneCX;
                const finalY = crosshairState.smoothY + (crosshairState.parallaxY || 0) + deadzoneCY;

                crosshairElement.style.transform = `translate(calc(-50% + ${finalX.toFixed(1)}px), calc(-50% - ${finalY.toFixed(1)}px)) rotate(${crosshairState.smoothRot.toFixed(1)}deg)`;

                // Drive colors via CSS variables (no glow)
                crosshairElement.style.setProperty('--dot-color', color);
                crosshairElement.style.setProperty('--circle-border-color', `rgb(${r}, ${g}, ${b})`);
            }

            // Apply recoil impulse - called when shooting
            // Apply recoil impulse - called when shooting
            function applyCrosshairRecoil(amount) {
                // progressiveMultiplier: 0.0 -> 1.0 (Low recoil at start)
                // Scales with heat, starts at 0.3 for precision
                let progression = 0.3 + (crosshairState.heat * 1.5);
                if (progression > 1.8) progression = 1.8; // Cap at nearly double intensity

                // Add heat (accumulates)
                crosshairState.heat += amount * 2.0;
                if (crosshairState.heat > 1.5) crosshairState.heat = 1.5;

                // PROGRESSIVE Vertical kick
                // Starts at ~100 (precise), ramps up to ~500 (aggressive)
                crosshairState.recoilKick += amount * 300 * progression;

                // PROGRESSIVE CHAOS
                // Low heat = almost no spread (precise), High heat = crazy wide
                const chaosMultiplier = Math.max(0.2, crosshairState.heat * 10); // 0.2x to 10x spread
                crosshairState.recoilDrift += (Math.random() - 0.5) * amount * 300 * chaosMultiplier;

                // PROGRESSIVE Twist (reduced for less aggressive tilt)
                crosshairState.recoilRotation += (Math.random() - 0.5) * amount * 200 * chaosMultiplier;
            }

            // Create 3D ammo sprite
            let weaponAmmoSprite = null;

            // === NEW TACTICAL STEALTH GENERATOR ===
            function createHoloTexture(current, max, reserve, weaponName) {
                const w = 256; const h = 128;
                const canvas = document.createElement('canvas');
                canvas.width = w; canvas.height = h;
                const ctx = canvas.getContext('2d');
                const percentage = current / max;

                // Stealth Palette: White on Black
                let mainColor = '#ffffff';
                if (percentage <= 0.25) mainColor = '#ff3333'; // Critical Red

                ctx.clearRect(0, 0, w, h);

                // Disable smoothing for pixelated text effect
                ctx.imageSmoothingEnabled = false;
                ctx.imageSmoothingQuality = 'low';

                // 1. DARK GLASS BACKDROP
                // Dark fill with transparency for "smoked glass" look
                ctx.fillStyle = "rgba(0, 0, 0, 0)";
                ctx.beginPath();
                ctx.moveTo(10, 10); ctx.lineTo(w - 10, 10);
                ctx.lineTo(w - 10, h - 50); ctx.lineTo(w - 50, h - 10); // Cut corner
                ctx.lineTo(10, h - 10); ctx.closePath();
                ctx.fill();

                // 2. BLACK & WHITE DETAILING
                ctx.fillStyle = "rgba(255,255,255,0.05)"; // Faint grid
                for (let i = 20; i < h - 20; i += 4) ctx.fillRect(20, i, w - 40, 1);

                ctx.lineWidth = 4;
                ctx.strokeStyle = "rgba(0, 0, 0, 0.6)"; // Dark Borders (Subtle)
                // ctx.stroke(); // Commented out to remove border outline

                // 3. TEXT DRAWING
                // Sharp white numbers - pixelated font
                ctx.textAlign = "left"; ctx.textBaseline = "middle";
                ctx.fillStyle = mainColor;
                ctx.font = "bold 60px monospace"; // Monospace for pixelated look
                ctx.fillText(current < 10 ? "0" + current : current, 25, 55);

                // Grey Reserve numbers - pixelated
                ctx.fillStyle = "rgba(255,255,255,0.5)";
                ctx.font = "600 25px monospace";
                ctx.fillText("// " + reserve, 95, 60);

                // Weapon Name - pixelated
                ctx.fillStyle = "#ffffff"; ctx.font = "600 14px monospace";
                ctx.letterSpacing = "2px";
                ctx.fillText((weaponName || "WPN").toUpperCase(), 25, 85);

                // 4. SLIM PROGRESS BAR
                ctx.fillStyle = "rgba(255,255,255,0.1)"; ctx.fillRect(25, 98, 206, 2); // Track
                ctx.fillStyle = mainColor; ctx.fillRect(25, 98, 206 * percentage, 2); // Fill

                const texture = new THREE.CanvasTexture(canvas);
                texture.needsUpdate = true;
                texture.magFilter = THREE.NearestFilter; // Pixelated scaling
                texture.minFilter = THREE.NearestFilter;
                return { texture, canvas, ctx }; // PERF: Return canvas for reuse
            }

            // PERF: Cache for ammo display to avoid recreating texture every shot
            let _ammoDisplayCache = { canvas: null, ctx: null, texture: null, lastAmmo: -1, lastReserve: -1 };

            function createWeaponAmmoDisplay(ammo, reserve, weaponName, maxAmmo) {
                const result = createHoloTexture(ammo, maxAmmo, reserve, weaponName);
                _ammoDisplayCache.canvas = result.canvas;
                _ammoDisplayCache.ctx = result.ctx;
                _ammoDisplayCache.texture = result.texture;
                _ammoDisplayCache.lastAmmo = ammo;
                _ammoDisplayCache.lastReserve = reserve;
                const texture = result.texture;

                // PlaneGeometry - bigger for visibility
                const geometry = new THREE.PlaneGeometry(0.08, 0.04);

                const material = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    opacity: 0.9, // More visible
                    blending: THREE.NormalBlending,
                    side: THREE.DoubleSide,
                    depthTest: false // Keep visible over weapon model
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.name = "ammoDisplay";
                return mesh;
            }

            // Update weapon ammo sprite - OPTIMIZED to reuse canvas
            function updateWeaponAmmoSprite() {
                if (!currentWeaponMesh) return;

                // Find the display on the current gun
                const displayMesh = currentWeaponMesh.getObjectByName("ammoDisplay");

                if (displayMesh && displayMesh.material.map) {
                    const weaponInfo = weapons[gameState.currentWeapon];

                    // PERF: Skip update if ammo hasn't changed
                    if (_ammoDisplayCache.lastAmmo === gameState.currentAmmo &&
                        _ammoDisplayCache.lastReserve === gameState.reserveAmmo) {
                        return;
                    }

                    // PERF: Reuse existing texture, just update canvas content
                    const result = createHoloTexture(gameState.currentAmmo, weaponInfo.maxAmmo, gameState.reserveAmmo, gameState.currentWeapon);

                    // Dispose old texture to prevent memory leak
                    if (displayMesh.material.map && displayMesh.material.map !== result.texture) {
                        displayMesh.material.map.dispose();
                    }

                    // Apply new texture
                    displayMesh.material.map = result.texture;
                    displayMesh.material.needsUpdate = true;

                    _ammoDisplayCache.lastAmmo = gameState.currentAmmo;
                    _ammoDisplayCache.lastReserve = gameState.reserveAmmo;
                }
            }

            // Switch weapon model - uses animated GLB models with fallback to procedural
            function switchWeaponModel(weaponType) {
                // Weapon overlay not ready yet (some calls happen before initGame)
                if (!weaponCamera) {
                    _pendingWeaponType = weaponType;
                    console.warn('⚠️ weaponCamera not ready; deferring weapon switch:', weaponType);
                    return;
                }
                // Remove current weapon
                if (currentWeaponMesh) {
                    weaponCamera.remove(currentWeaponMesh);
                    currentWeaponMesh = null;
                }

                // Clear animation mixer
                weaponAnimationMixer = null;
                weaponAnimations = {};

                // Try to load animated model first
                loadAnimatedWeapon(weaponType, function (model, animations) {
                    if (model) {
                        // Use animated model
                        currentWeaponMesh = model;

                        // Setup animation mixer
                        weaponAnimationMixer = new THREE.AnimationMixer(model);
                        if (animations && animations.length > 0) {
                            animations.forEach((clip) => {
                                weaponAnimations[clip.name] = clip;
                                console.log('🎬 Registered animation:', clip.name);
                            });
                        }

                        console.log('✅ Using animated weapon model:', weaponType);
                    } else {
                        // Fallback to procedural models
                        console.log('⚠️ Falling back to procedural weapon:', weaponType);
                        switch (weaponType) {
                            case 'rifle':
                                currentWeaponMesh = createAK47();
                                break;
                            case 'sniper':
                                currentWeaponMesh = createAWP();
                                break;
                            case 'pistol':
                                currentWeaponMesh = createDesertEagle();
                                break;
                        }
                    }

                    // Check if weapon mesh was created successfully
                    if (!currentWeaponMesh) {
                        console.error('Failed to create weapon mesh for:', weaponType);
                        return;
                    }

                    // Store base position (check if userData exists)
                    if (!currentWeaponMesh.userData) {
                        currentWeaponMesh.userData = {};
                    }
                    currentWeaponMesh.userData.baseZ = currentWeaponMesh.position.z;

                    // Add to weapon camera (camera-relative positioning)
                    weaponCamera.add(currentWeaponMesh);

                    // Add the Holographic Display relative to weapon shape
                    const weaponInfo = weapons[weaponType];
                    if (weaponInfo) {
                        weaponAmmoSprite = createWeaponAmmoDisplay(gameState.currentAmmo, gameState.reserveAmmo, weaponType, weaponInfo.maxAmmo);

                        // Position specific to the gun model
                        // For animated GLB rifle, positions need to account for model's local space
                        if (weaponType === 'rifle') {
                            // Position above the rifle receiver - adjusted for animated model scale
                            weaponAmmoSprite.position.set(0.02, 1.52, 0.25);
                            weaponAmmoSprite.rotation.set(-0.2, Math.PI, 0); // Rotated to face player
                            weaponAmmoSprite.scale.set(0.9, 0.9, 0.9); // Bigger for visibility
                        } else if (weaponType === 'pistol') {
                            weaponAmmoSprite.position.set(0, 0.05, 0.06);
                            weaponAmmoSprite.scale.set(0.5, 0.5, 0.5);
                        } else if (weaponType === 'sniper') {
                            weaponAmmoSprite.position.set(-0.05, 0.04, 0.07);
                            weaponAmmoSprite.rotation.y = 0.3;
                        } else if (weaponType === 'smg') {
                            weaponAmmoSprite.position.set(-0.02, 0.03, -0.02);
                            weaponAmmoSprite.rotation.set(-0.1, 0.1, 0);
                        }

                        currentWeaponMesh.add(weaponAmmoSprite);
                        console.log('📊 Ammo display added to weapon at:', weaponAmmoSprite.position);
                    }

                    // FIX: Initialize weapon position immediately after loading
                    // This fixes the bug where weapon appears at wrong position until first shot
                    const isGLBModel = weaponAnimationMixer !== null;
                    if (isGLBModel && weaponType === 'rifle') {
                        currentWeaponMesh.position.set(0.13, -1.52, 0.03);
                        currentWeaponMesh.rotation.set(0, 3.1, 0);
                    } else if (weaponType === 'sniper') {
                        currentWeaponMesh.position.set(0.15, -0.15, -0.3);
                    } else if (weaponType === 'pistol') {
                        currentWeaponMesh.position.set(0.1, -0.1, -0.2);
                    } else {
                        currentWeaponMesh.position.set(0.12, -0.12, -0.25);
                    }
                    console.log('🔫 Weapon position initialized:', currentWeaponMesh.position);

                    console.log('🔫 Weapon added to weaponCamera:', weaponType);
                });
            }

            // (Debug test cube removed - was for testing only)

            // Initialize with rifle (async - weapon loads in background)
            switchWeaponModel('rifle');

            // Load XP orb textures
            loadOrbTextures();
            console.log('✨ XP Orb system initialized');

            // Note: Weapon loads asynchronously, debug info will show after load completes
            console.log('Weapon loading initiated (async)...');

            // Complete loading sequence
            if (window.LoadingScreen) {
                setTimeout(() => {
                    console.log('✅ UI ready');
                    LoadingScreen.assetLoaded('ui_ready');
                    LoadingScreen.setStatus('DEPLOYMENT COMPLETE');
                    setTimeout(() => {
                        LoadingScreen.complete();
                    }, 500);
                }, 300);
            }

            // Mouse Controls - Using Euler angles for proper rotation
            const euler = new THREE.Euler(0, 0, 0, 'YXZ');
            const PI_2 = Math.PI / 2;
            const sensitivity = 0.002; // Adjust this value: lower = slower, higher = faster

            // Pointer Lock handling
            let isPointerLocked = false;

            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = document.pointerLockElement === renderer.domElement;

                // If pointer lock is lost and we're not already paused/unpausing
                if (!isPointerLocked && gameState.started && !gameState.isDying && !isUnpausing) {
                    // Don't pause if position selector is open
                    if (!pauseMenuVisible && !positionSelectorActive) {
                        console.log('🎮 Pointer lock lost - showing pause menu');
                        // Pointer lock was lost (probably ESC key), show pause menu
                        setTimeout(() => {
                            if (!document.pointerLockElement && !pauseMenuVisible) {
                                showPauseMenu();
                            }
                        }, 50);
                    }
                }
            });

            document.addEventListener('pointerlockerror', () => {
                // Only log occasionally to avoid spam
                console.warn('⚠️ Pointer lock request failed');
            });

            document.addEventListener('mousemove', (e) => {
                // Skip camera control if position selector is open or pointer not locked
                if (!gameState.started || gameState.paused || !isPointerLocked || gameState.isDying || positionSelectorActive) return;

                const movementX = e.movementX || 0;
                const movementY = e.movementY || 0;

                // Track weapon sway from mouse movement (for weapon physics)
                weaponPhysics.sway.x = movementX;
                weaponPhysics.sway.y = movementY;

                // KINETIC BLEND: Accumulate mouse input for deadzone crosshair
                kineticState.mouseAccumX -= movementX * 0.002;
                kineticState.mouseAccumY -= movementY * 0.002;
                // Clamp pitch accumulator
                kineticState.mouseAccumY = Math.max(-1.5, Math.min(1.5, kineticState.mouseAccumY));

                euler.setFromQuaternion(camera.quaternion);

                euler.y -= movementX * sensitivity;
                euler.x -= movementY * sensitivity;

                // Clamp vertical rotation to prevent flipping
                euler.x = Math.max(-PI_2 + 0.1, Math.min(PI_2 - 0.1, euler.x));

                camera.quaternion.setFromEuler(euler);
            });

            // Health HUD 3D Inverse Tilt Effect - Using movement deltas for pointer lock
            let hudTiltX = 0;
            let hudTiltY = 0;
            let hudTiltTargetX = 0;
            let hudTiltTargetY = 0;
            const hudTiltIntensity = 6; // Max degrees of tilt
            const hudTiltDecay = 0.92; // How fast tilt returns to center

            // Track mouse movement for HUD tilt (works with pointer lock)
            document.addEventListener('mousemove', (e) => {
                // Use movement deltas - these work during pointer lock!
                const movementX = e.movementX || 0;
                const movementY = e.movementY || 0;

                // Accumulate tilt based on mouse movement (clamped)
                hudTiltTargetY -= movementX * 0.15; // Inverse: move right -> tilt left
                hudTiltTargetX -= movementY * 0.15; // Inverse: move down -> tilt up

                // Clamp to max intensity
                hudTiltTargetX = Math.max(-hudTiltIntensity, Math.min(hudTiltIntensity, hudTiltTargetX));
                hudTiltTargetY = Math.max(-hudTiltIntensity, Math.min(hudTiltIntensity, hudTiltTargetY));
            });

            // Update HUD tilt - call from animate loop
            function updateHUDTilt() {
                // Smooth interpolation towards target
                hudTiltX += (hudTiltTargetX - hudTiltX) * 0.15;
                hudTiltY += (hudTiltTargetY - hudTiltY) * 0.15;

                // Decay target back to center
                hudTiltTargetX *= hudTiltDecay;
                hudTiltTargetY *= hudTiltDecay;

                // Apply 3D tilt to ENTIRE HUD
                const hudElement = document.getElementById('hud');
                if (hudElement) {
                    hudElement.style.transform = `perspective(1000px) rotateX(${hudTiltX * 0.5}deg) rotateY(${hudTiltY * 0.5}deg) translateZ(20px)`;
                }

                // Apply to XP Bar (MC Style) - MUST PRESERVE translateX(-50%) for centering!
                const xpElement = document.getElementById('mcXpHud');
                if (xpElement) {
                    // Stronger tilt (2.5x) and Centered
                    xpElement.style.transform = `perspective(1000px) translateX(-50%) rotateX(${hudTiltX * 2.5}deg) rotateY(${hudTiltY * 2.5}deg) translateZ(20px)`;
                }

                // Apply to Squad/Player List - Stronger tilt (2.0x)
                const statsElement = document.getElementById('game-stats-hud');
                if (statsElement) {
                    statsElement.style.transform = `perspective(1000px) rotateX(${hudTiltX * 2.0}deg) rotateY(${hudTiltY * 2.0}deg) translateZ(15px)`;
                }

                // Apply to health container with stronger effect
                const healthContainer = document.querySelector('.health-container');
                if (healthContainer) {
                    healthContainer.style.transform = `perspective(800px) rotateX(${hudTiltX}deg) rotateY(${hudTiltY}deg) translateZ(30px)`;
                }

                // Apply to ammo display
                const ammoDisplay = document.querySelector('.ammo-display');
                if (ammoDisplay) {
                    ammoDisplay.style.transform = `perspective(800px) rotateX(${hudTiltX * 0.8}deg) rotateY(${hudTiltY * 0.8}deg) translateZ(25px)`;
                }

                // Apply to crosshair with subtle parallax shift
                if (typeof crosshairState !== 'undefined') {
                    crosshairState.parallaxX = hudTiltY * 0.5;
                    crosshairState.parallaxY = -hudTiltX * 0.5;
                }
            }

            // Keyboard Controls - Using currentKeybinds from localStorage
            let spacePressed = false;
            let ctrlPressed = false;
            document.addEventListener('keydown', (e) => {
                if (!gameState.started || gameState.isDying) return;

                if (e.code === currentKeybinds.moveForward) moveForward = true;
                else if (e.code === currentKeybinds.moveBackward) moveBackward = true;
                else if (e.code === currentKeybinds.moveLeft) moveLeft = true;
                else if (e.code === currentKeybinds.moveRight) moveRight = true;
                else if (e.code === currentKeybinds.jump) spacePressed = true;
                else if (e.code === currentKeybinds.sprint) gameState.isSprinting = true;
                else if (e.code === currentKeybinds.slide) {
                    ctrlPressed = true;
                    // Allow slide if any movement key is pressed or player has momentum
                    const hasMovementInput = moveForward || moveBackward || moveLeft || moveRight;
                    const hasMomentum = gameState.movementSpeed > 0.3;
                    if (gameState.onGround && !gameState.isSliding && gameState.slideCooldown <= 0 && (hasMovementInput || hasMomentum)) {
                        startSlide();
                    }
                }
                else if (e.code === currentKeybinds.leanLeft) gameState.leanTarget = 1;
                else if (e.code === currentKeybinds.leanRight) gameState.leanTarget = -1;
                else if (e.code === currentKeybinds.reload) reload();
                else if (e.code === currentKeybinds.pause) togglePause();
                else if (e.code === currentKeybinds.weapon1) switchWeapon('rifle');
                else if (e.code === currentKeybinds.weapon2) switchWeapon('pistol');
                else if (e.code === currentKeybinds.weapon3) switchWeapon('sniper');
                else if (e.code === 'Digit4') switchWeapon('smg'); // Key 4 for MP5
                else if (e.code === currentKeybinds.toggleDOF) {
                    postProcessMaterial.uniforms.enableDOF.value = postProcessMaterial.uniforms.enableDOF.value > 0.5 ? 0.0 : 1.0;
                    console.log('Depth of Field:', postProcessMaterial.uniforms.enableDOF.value > 0.5 ? 'ON' : 'OFF');
                }
                else if (e.code === 'F11' && !e.ctrlKey && !e.altKey) {
                    // F11 key for fullscreen toggle (standard key, avoids conflict with DOF toggle on F)
                    e.preventDefault();
                    toggleFullscreen();
                }
            });

            document.addEventListener('keyup', (e) => {
                if (e.code === currentKeybinds.moveForward) moveForward = false;
                else if (e.code === currentKeybinds.moveBackward) moveBackward = false;
                else if (e.code === currentKeybinds.moveLeft) moveLeft = false;
                else if (e.code === currentKeybinds.moveRight) moveRight = false;
                else if (e.code === currentKeybinds.jump) spacePressed = false;
                else if (e.code === currentKeybinds.sprint) gameState.isSprinting = false;
                else if (e.code === currentKeybinds.slide) ctrlPressed = false;
                else if (e.code === currentKeybinds.leanLeft) {
                    if (gameState.leanTarget === 1) gameState.leanTarget = 0;
                }
                else if (e.code === currentKeybinds.leanRight) {
                    if (gameState.leanTarget === -1) gameState.leanTarget = 0;
                }
            });

            // Shooting - Gun Spam System (continuous fire while mouse held)
            let isMouseDown = false;
            let sprayRecoilMultiplier = 1.0; // Accumulates while holding fire

            document.addEventListener('mousedown', (e) => {
                if (e.button === 0 && gameState.started && !gameState.paused && !gameState.isDying) {
                    isMouseDown = true;
                    sprayRecoilMultiplier = 1.0; // Reset spray recoil on new burst
                    shoot();
                }
            });

            document.addEventListener('mouseup', (e) => {
                if (e.button === 0) {
                    isMouseDown = false;
                    sprayRecoilMultiplier = 1.0; // Reset spray recoil when releasing
                }
            });

            // Create enemy/other player based on mode (defer until scene exists)
            runWhenSceneReady(() => {
                console.log('Creating enemy/player, isMultiplayer:', isMultiplayer);
                if (isMultiplayer) {
                    // Don't create otherPlayer here - wait for connection to establish
                    // This prevents duplicate creation
                    console.log('Multiplayer mode - otherPlayer will be created when connection is established');
                    enemy = null; // Will be set to otherPlayer when created
                } else {
                    // Single player mode - create AI enemy (using CylinderGeometry for r128 compatibility)
                    console.log('Creating AI enemy');
                    const enemyGeometry = new THREE.CylinderGeometry(0.4, 0.4, 1.8, 8);
                    const enemyMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
                    enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
                    enemy.position.set(0, 1.7, 20); // Enemy side
                    enemy.castShadow = true;
                    scene.add(enemy);

                    // Add COD-style red enemy nametag (hidden by default, shows when aimed at)
                    const randomId = Math.floor(Math.random() * 9000 + 1000); // Random 4-digit ID
                    const enemyUsernameSprite = createEnemyNametag('HEME', 'Adamo', randomId.toString());
                    enemyUsernameSprite.position.set(0, 1.3, 0); // Above head
                    enemy.add(enemyUsernameSprite);
                    enemy.usernameSprite = enemyUsernameSprite;
                    console.log('🔴 COD-style enemy nametag created (shows when aimed at)');
                }
            });

            // Expose functions and variables globally for lobby name sync
            window.sendToOther = sendToOther;
            window.dataChannel = dataChannel;
            window.gameState = gameState;

            // Expose dynamic variables using getters/setters to ensure they are always up to date
            Object.defineProperty(window, 'isHost', { get: () => isHost, set: (v) => isHost = v });
            Object.defineProperty(window, 'isMultiplayer', { get: () => isMultiplayer, set: (v) => isMultiplayer = v });
            Object.defineProperty(window, 'gameMode', { get: () => gameMode, set: (v) => gameMode = v });
            Object.defineProperty(window, 'roomPlayers', { get: () => roomPlayers, set: (v) => roomPlayers = v });
            Object.defineProperty(window, 'squadData', { get: () => squadData, set: (v) => squadData = v });
            Object.defineProperty(window, 'myTeam', { get: () => myTeam, set: (v) => myTeam = v });

            // Function to create other player if not already created (for late multiplayer init)
            window.createMultiplayerOpponent = function () {
                // Remove any existing otherPlayer/enemy duplicates first
                if (otherPlayer && scene) {
                    scene.remove(otherPlayer);
                }
                if (enemy && scene && enemy !== otherPlayer && isMultiplayer) {
                    // Remove duplicate enemy in multiplayer mode
                    scene.remove(enemy);
                    enemy = null;
                }

                if (!otherPlayer && scene) {
                    console.log('✅ Creating other player mesh (late init)');
                    // Other player always spawns on enemy side (opposite from you)
                    // If you're host (spawned at z=-20), otherPlayer spawns at z=20
                    // If you're client (spawned at z=20), otherPlayer spawns at z=-20
                    const otherPlayerSpawnZ = isHost ? 20 : -20; // Opposite side from player
                    otherPlayer = createOtherPlayerMesh(otherPlayerSpawnZ > 0);
                    window.otherPlayer = otherPlayer; // Expose for voice chat distance calculation
                    enemy = otherPlayer; // Set enemy reference
                    scene.add(otherPlayer);

                    // Initialize target position to current position
                    targetOtherPlayerPosition.copy(otherPlayer.position);

                    // Make sure it's visible
                    otherPlayer.visible = true;
                    otherPlayer.castShadow = true;
                    otherPlayer.receiveShadow = true;

                    console.log('✅ Other player added to scene at:', otherPlayer.position);
                    console.log('✅ Player position:', camera.position.x.toFixed(2), camera.position.y.toFixed(2), camera.position.z.toFixed(2));
                    console.log('✅ otherPlayer in scene:', scene.children.includes(otherPlayer));
                } else if (otherPlayer && scene && !scene.children.includes(otherPlayer)) {
                    console.log('⚠️ otherPlayer exists but not in scene, adding...');
                    scene.add(otherPlayer);
                }
            };

            // Function to start game from lobby (called by host or when receiving startGame message)
            window.startGameFromLobby = function () {
                console.log('🎮 Starting game from lobby!');

                // Initialize voice chat for multiplayer
                if (isMultiplayer && window.VoiceChat) {
                    console.log('🎤 Starting voice chat for multiplayer game...');
                    VoiceChat.startVoice().then((success) => {
                        if (success && isHost && otherPlayerId) {
                            // Host calls the other player after a short delay
                            setTimeout(() => {
                                VoiceChat.callPeer(otherPlayerId);
                            }, 1000);
                        }
                    });
                }

                // Apply spawn position for client if stored (1v1 mode)
                if (gameMode === '1v1' && window.clientSpawnPosition) {
                    camera.position.set(
                        window.clientSpawnPosition.x,
                        window.clientSpawnPosition.y,
                        window.clientSpawnPosition.z
                    );
                    console.log('✅ Client: Applied spawn position:', camera.position);
                }

                // Create other player (only for 1v1 - 2v2 players are already created)
                if (gameMode === '1v1' && window.createMultiplayerOpponent) {
                    window.createMultiplayerOpponent();
                }

                // Start game
                document.getElementById('startScreen').style.display = 'none';
                document.getElementById('levelDisplay').style.display = 'flex';
                // Hide music player and stop music when game starts
                if (window.MusicPlayer && typeof window.MusicPlayer.handleGameStart === 'function') {
                    window.MusicPlayer.handleGameStart();
                } else {
                    try { if (window.MusicPlayer && window.MusicPlayer.audio) window.MusicPlayer.audio.pause(); } catch (_) {}
                    const musicPlayerEl = document.getElementById('musicPlayer');
                    if (musicPlayerEl) musicPlayerEl.style.display = 'none';
                }
                // Show Minecraft XP HUD
                const mcXpHud = document.getElementById('mcXpHud');
                if (mcXpHud) mcXpHud.classList.add('visible');
                // Hide lobby squad list when game starts
                const lobbySquadList = document.getElementById('lobbySquadList');
                if (lobbySquadList) lobbySquadList.style.display = 'none';
                if (window.menuSceneController) window.menuSceneController.hide();
                gameState.started = true;

                // Show R6 Topbar
                showR6Topbar();

                renderer.domElement.requestPointerLock();
                updateHUD();
                if (!window.animateStarted) {
                    window.animateStarted = true;
                    animate();
                }

                console.log('✅ Game started from lobby!');
            };

            let enemyState = {
                position: new THREE.Vector3(0, 1.7, 20),
                targetPosition: new THREE.Vector3(0, 1.7, 20),
                lastShot: 0,
                shootDelay: 1500,
                moving: false,
                isDying: false,
                deathTimer: 0
            };

            function updateEnemy(deltaTime) {
                if (!gameState.started || gameState.paused) return;

                if (enemyState.isDying) {
                    enemyState.deathTimer += deltaTime;
                    const deathProgress = Math.min(enemyState.deathTimer / 1.5, 1);

                    enemy.rotation.x = lerp(enemy.rotation.x, -Math.PI / 2, deltaTime * 5);
                    enemy.rotation.z = lerp(enemy.rotation.z, (Math.random() - 0.5) * 2, deltaTime * 5);
                    enemy.position.y = lerp(enemy.position.y, 0.5, deltaTime * 5);

                    if (deathProgress >= 1) {
                        enemy.visible = false;
                    }
                    return;
                }

                // Skip AI logic in multiplayer mode (other player controls their own character)
                if (isMultiplayer) {
                    // In multiplayer, make sure we're using otherPlayer, not a duplicate enemy
                    if (enemy && enemy !== otherPlayer && scene) {
                        // Remove duplicate enemy
                        scene.remove(enemy);
                        enemy = otherPlayer;
                    }
                    return;
                }

                // Only run AI logic if enemy exists and is not the otherPlayer
                if (!enemy || enemy === otherPlayer) return;

                // AI Movement
                if (!enemyState.moving || enemy.position.distanceTo(enemyState.targetPosition) < 0.5) {
                    // Choose new random position (near cover if boxes exist, otherwise random)
                    if (boxes.length > 0) {
                        const randomBox = boxes[Math.floor(Math.random() * boxes.length)];
                        if (randomBox && randomBox.position) {
                            enemyState.targetPosition.set(
                                randomBox.position.x + (Math.random() - 0.5) * 5,
                                1.7,
                                randomBox.position.z + (Math.random() - 0.5) * 5
                            );
                        } else {
                            // Fallback to random position
                            enemyState.targetPosition.set(
                                (Math.random() - 0.5) * 40,
                                1.7,
                                (Math.random() - 0.5) * 40
                            );
                        }
                    } else {
                        // No boxes - random position within map bounds
                        enemyState.targetPosition.set(
                            (Math.random() - 0.5) * 40,
                            1.7,
                            (Math.random() - 0.5) * 40
                        );
                    }
                    enemyState.moving = true;
                }

                // Move towards target - PERF: Reuse global vector instead of creating new one each frame
                _reusableVec3A.subVectors(enemyState.targetPosition, enemy.position).normalize();
                enemy.position.addScaledVector(_reusableVec3A, deltaTime * 2);
                enemy.position.y = 1.7;

                // Look at player
                enemy.lookAt(camera.position);

                // AI Shooting
                const now = Date.now();
                if (now - enemyState.lastShot > enemyState.shootDelay) {
                    const distanceToPlayer = enemy.position.distanceTo(camera.position);
                    const accuracy = Math.max(0.3, 1 - distanceToPlayer / 30);

                    if (Math.random() < accuracy * 0.3) {
                        enemyShoot();
                    }
                    enemyState.lastShot = now;
                }
            }

            function enemyShoot() {
                // Visual muzzle flash
                const flash = new THREE.PointLight(0xffff00, 2, 5);
                flash.position.copy(enemy.position);
                scene.add(flash);
                setTimeout(() => scene.remove(flash), 50);

                // Play enemy shooting sound with distance-based volume
                const shootVolume = calculateDistanceVolume(enemy.position, 60, 0.05);
                playShootSound('rifle', shootVolume);

                // Check if hit player - but only if player is not already dying
                if (gameState.isDying || gameState.playerHealth <= 0) return;

                const accuracy = 0.2 + Math.random() * 0.3;
                const bulletHit = Math.random() < accuracy;
                
                if (bulletHit) {
                    // Player got hit - play bullet hit sound
                    window.playBulletHitSound?.(0.8);
                    
                    const damage = 15 + Math.floor(Math.random() * 15);
                    gameState.playerHealth -= damage;
                    updateHUD();
                    showDamage();

                    if (gameState.playerHealth <= 0) {
                        playerDied();
                    }
                } else {
                    // Bullet missed but passed close - play bullet whiz sound
                    // Volume based on distance (closer enemy = louder whiz)
                    const distanceToEnemy = enemy.position.distanceTo(camera.position);
                    const whizVolume = Math.max(0.3, Math.min(1.0, 1 - distanceToEnemy / 50));
                    window.playBulletWhizSound?.(whizVolume);
                }
            }

            function switchWeapon(weaponType) {
                if (gameState.isReloading) return;

                const weapon = weapons[weaponType];
                gameState.currentWeapon = weaponType;
                gameState.currentAmmo = weapon.maxAmmo;
                gameState.reserveAmmo = weapon.reserveAmmo;
                gameState.maxAmmo = weapon.maxAmmo;

                // Switch 3D weapon model
                switchWeaponModel(weaponType);

                updateHUD();
            }

            // ==========================================
            // VIDEO MUZZLE FLASH SYSTEM
            // Uses shotfire.mp4 with additive blending (black = transparent)
            // ==========================================
            // PERF: Pre-allocated vectors for muzzle flash positioning
            const _flashPos = new THREE.Vector3();
            const _flashOffset = new THREE.Vector3();
            
            function createMuzzleFlash() {
                // Get barrel position from camera direction - PERF: Reuse vectors
                _flashPos.copy(camera.position);

                // === POSITIONING (X=Right, Y=Up, Z=Forward) ===
                // Adjust these values to position the flash freely!
                const offsetX = 0.2;  // +Right / -Left
                const offsetY = -0.12; // +Up / -Down
                const offsetZ = 0.6;  // +Forward

                // Calculate offset relative to camera view - PERF: Reuse vector
                _flashOffset.set(offsetX, offsetY, -offsetZ); // Forward is -Z in local
                _flashOffset.applyQuaternion(camera.quaternion);
                _flashPos.add(_flashOffset);

                // === PERFORMANCE: USE PRE-LOADED ASSETS ===
                // Find a free asset or pick random if all busy
                let asset = flashAssets.find(a => !a.busy);
                if (!asset) {
                    asset = flashAssets[Math.floor(Math.random() * flashAssets.length)];
                }

                asset.busy = true;
                const video = asset.video;

                // Random rotation/scale
                const randomRotation = Math.random() * Math.PI * 2;
                const randomScale = 0.5 + Math.random() * 0.2;

                // Clone material for independent opacity fading
                // (Texture is shared from pre-load, very cheap to clone material)
                const flashMaterial = asset.material.clone();

                // === SPRITE ===
                const flashSprite = new THREE.Sprite(flashMaterial);
                flashSprite.scale.set(randomScale, randomScale, 1);
                flashSprite.position.copy(_flashPos);
                flashSprite.material.rotation = randomRotation;
                scene.add(flashSprite);

                // === POINT LIGHT ===
                const flashColors = [0xffaa00, 0xffcc33, 0xff8800, 0xffdd66];
                const mainColor = flashColors[Math.floor(Math.random() * flashColors.length)];
                const flashIntensity = 4 + Math.random() * 3;

                // Create light (PointLights are cheap-ish, but check performance)
                const flash = new THREE.PointLight(mainColor, flashIntensity, 10);
                flash.position.copy(_flashPos);
                scene.add(flash);

                // === RESET & PLAY VIDEO ===
                video.currentTime = 0;
                video.play().catch(e => { }); // Ignore interruption errors

                // === ANIMATE & CLEANUP ===
                const startTime = performance.now();

                function animateMuzzleFlash() {
                    const elapsed = performance.now() - startTime;

                    // Update texture (needed for video)
                    if (video.readyState >= video.HAVE_CURRENT_DATA) {
                        asset.texture.needsUpdate = true;
                    }

                    // Fade light
                    const t = Math.min(elapsed / 80, 1); // Fast fade
                    flash.intensity = flashIntensity * (1 - t);

                    // Fade sprite opacity
                    flashMaterial.opacity = 3.0 * (1 - (elapsed / 150)); // Fade out over 150ms

                    // Cleanup condition
                    if (elapsed > 150) { // Short duration for muzzle flash
                        // Cleanup
                        scene.remove(flashSprite);
                        scene.remove(flash);

                        // Dispose CLONED material only
                        flashMaterial.dispose();
                        flash.dispose(); // Dispose light

                        // Mark asset free
                        asset.busy = false;
                    } else {
                        requestAnimationFrame(animateMuzzleFlash);
                    }
                }

                animateMuzzleFlash();
            }

            function distanceSqPointToSegment(point, a, b) {
                if (!_whizSeg || !_whizToPoint || !_whizClosestPoint) return Infinity;
                _whizSeg.subVectors(b, a);
                const segLenSq = _whizSeg.lengthSq();
                if (segLenSq <= 1e-8) return point.distanceToSquared(a);

                _whizToPoint.subVectors(point, a);
                let t = _whizToPoint.dot(_whizSeg) / segLenSq;
                if (t < 0) t = 0;
                else if (t > 1) t = 1;

                _whizClosestPoint.copy(a).addScaledVector(_whizSeg, t);
                return point.distanceToSquared(_whizClosestPoint);
            }

            function shoot() {
                const _dbgShootT0 = (window.StutterDebug && window.StutterDebug.state && window.StutterDebug.state.enabled) ? performance.now() : 0;
                if (!gameState.canShoot || gameState.isReloading || gameState.currentAmmo <= 0 || isUnpausing) {
                    return;
                }
                // Stutter debug correlation point
                stutterEvent('shoot');

                const weapon = weapons[gameState.currentWeapon];

                gameState.currentAmmo--;
                updateHUD();
                updateWeaponAmmoSprite();
                gameState.canShoot = false;
                updateHUD();

                // Play weapon sound
                playShootSound(weapon.type);

                // Play weapon shoot animation if available
                if (!playWeaponAnimation('shoot')) {
                    if (!playWeaponAnimation('fire')) {
                        playWeaponAnimation('attack');
                    }
                }

                // Weapon Physics Recoil (from test file)
                weaponPhysics.recoil.kick += 0.05;
                weaponPhysics.recoil.rot += 0.04;
                // NO camera shake - screen stays stable

                // Enhanced Camera Shake and Weapon Recoil based on weapon (Realistic values)
                let shakeIntensity = 0;
                let recoilAmount = 0;
                let shakePattern = 'default';

                if (weapon.type === 'rifle') {
                    shakeIntensity = 0.08;
                    recoilAmount = 0.06;
                    shakePattern = 'rifle';
                } else if (weapon.type === 'pistol') {
                    shakeIntensity = 0.06;
                    recoilAmount = 0.04;
                    shakePattern = 'pistol';
                } else if (weapon.type === 'sniper') {
                    shakeIntensity = 0.15;
                    recoilAmount = 0.12;
                    shakePattern = 'sniper';
                } else if (weapon.type === 'smg') {
                    shakeIntensity = 0.05;
                    recoilAmount = 0.03;
                    shakePattern = 'rifle';
                }

                applyCameraShake(shakeIntensity, shakePattern);
                applyWeaponRecoil(recoilAmount);

                // Apply crosshair recoil impulse for realistic dot kick
                if (typeof applyCrosshairRecoil === 'function') {
                    applyCrosshairRecoil(recoilAmount);
                }

                // ==========================================
                // ADVANCED MUZZLE FLASH - Realistic Gun Fire
                // ==========================================
                createMuzzleFlash();

                // Eject shell casing with physics
                createShellCasing();

                // Weapon-specific recoil with spray pattern (accumulates while holding fire)
                let recoilX = 0, recoilY = 0;
                if (weapon.type === 'rifle') {
                    recoilX = (Math.random() * 0.015 + 0.01) * sprayRecoilMultiplier;
                    recoilY = (Math.random() - 0.5) * 0.008 * sprayRecoilMultiplier;
                } else if (weapon.type === 'pistol') {
                    recoilX = (Math.random() * 0.018 + 0.012) * sprayRecoilMultiplier;
                    recoilY = (Math.random() - 0.5) * 0.01 * sprayRecoilMultiplier;
                } else if (weapon.type === 'sniper') {
                    recoilX = (Math.random() * 0.025 + 0.02) * sprayRecoilMultiplier;
                    recoilY = (Math.random() - 0.5) * 0.015 * sprayRecoilMultiplier;
                }

                // NO camera recoil - screen stays stable, only crosshair reacts
                // euler.x -= recoilX;  // REMOVED - was tilting screen down
                // euler.y += recoilY;  // REMOVED - was turning screen sideways
                // camera.quaternion.setFromEuler(euler);

                // PERF: Use pre-allocated raycaster and vector instead of creating new ones each shot
                _shootRaycaster.setFromCamera(_shootVec2Center, camera);

                // PERF: Reuse raycast target array to avoid per-shot allocations
                _shootObjectsToIntersect.length = 0;
                for (let i = 0; i < boxes.length; i++) {
                    _shootObjectsToIntersect.push(boxes[i]);
                }

                // Add enemies to intersection check
                if (gameMode === '2v2' && isMultiplayer) {
                    // 2v2: add all enemy players (opposite team)
                    otherPlayers.forEach((playerData) => {
                        if (playerData && playerData.mesh && playerData.team !== myTeam) {
                            _shootObjectsToIntersect.push(playerData.mesh);
                        }
                    });
                } else if (enemy) {
                    // 1v1 or AI: add single enemy
                    _shootObjectsToIntersect.push(enemy);
                }

                const intersects = _shootRaycaster.intersectObjects(_shootObjectsToIntersect, true);

                // PERF: Reuse pre-allocated vectors instead of cloning
                _shootBulletStart.copy(camera.position);

                if (intersects.length > 0) {
                    _shootBulletEnd.copy(intersects[0].point);
                } else {
                    // No hit - bullet goes to max range
                    camera.getWorldDirection(_shootDirection);
                    _shootBulletEnd.copy(_shootBulletStart).addScaledVector(_shootDirection, 100);
                }

                // Send shoot event in multiplayer (include endpoints so everyone sees tracers/smoke)
                if (isMultiplayer) {
                    sendToOther({
                        type: 'shoot',
                        sx: _shootBulletStart.x,
                        sy: _shootBulletStart.y,
                        sz: _shootBulletStart.z,
                        ex: _shootBulletEnd.x,
                        ey: _shootBulletEnd.y,
                        ez: _shootBulletEnd.z
                    });
                }

                // Create bullet tracer - pass references, tracer function will copy as needed
                createBulletTracer(_shootBulletStart, _shootBulletEnd);

                let didHitEnemy = false;

                if (intersects.length > 0) {
                    let hitEnemy = false;
                    let hitPlayerId = null;
                    let hitPlayerMesh = null;

                    // Check if we hit a surface (not an enemy) - create impact sparks
                    const firstHit = intersects[0];
                    const hitPoint = firstHit.point;
                    // PERF: Reuse pre-allocated normal vector (matches old behavior: local-space face.normal)
                    if (firstHit.face) {
                        _shootHitNormal.copy(firstHit.face.normal);
                    } else {
                        _shootHitNormal.set(0, 1, 0);
                    }
                    const hitNormal = _shootHitNormal;

                    // Check which enemy was hit
                    if (gameMode === '2v2' && isMultiplayer) {
                        // 2v2: check all enemy players
                        for (const intersect of intersects) {
                            let currentObject = intersect.object;
                            while (currentObject) {
                                const playerData = otherPlayers.find(p => p && p.mesh === currentObject);
                                if (playerData && playerData.team !== myTeam) {
                                    hitEnemy = true;
                                    hitPlayerId = playerData.playerId;
                                    hitPlayerMesh = playerData.mesh;
                                    break;
                                }
                                currentObject = currentObject.parent;
                            }
                            if (hitEnemy) break;
                        }
                    } else if (enemy) {
                        // 1v1 or AI: check single enemy
                        let currentObject = intersects[0].object;
                        while (currentObject) {
                            if (currentObject === enemy) {
                                hitEnemy = true;
                                hitPlayerId = otherPlayerId;
                                hitPlayerMesh = enemy;
                                break;
                            }
                            currentObject = currentObject.parent;
                        }
                    }

                    if (hitEnemy) {
                        didHitEnemy = true;
                        // Don't register hits on already dead enemies
                        const isTargetDead = hitPlayerMesh && (hitPlayerMesh.isDying || !hitPlayerMesh.visible);
                        const isAIDead = !isMultiplayer && enemyState && enemyState.isDying;

                        if (isTargetDead || isAIDead) {
                            console.log('🎯 Hit ignored - target is already dead');
                        } else {
                            // Detect headshot based on hit point Y position relative to enemy
                            // Enemy mesh is at y=1.7 (center), head is roughly y > 2.3
                            let isHeadshot = false;
                            const hitPoint = intersects[0].point;
                            const enemyY = hitPlayerMesh ? hitPlayerMesh.position.y : (enemy ? enemy.position.y : 1.7);
                            const hitRelativeY = hitPoint.y - enemyY;

                            // Head region is approximately top 30% of the character (above 0.6 relative to center)
                            if (hitRelativeY > 0.6) {
                                isHeadshot = true;
                                headshotsThisKill++; // Track for orb type
                                console.log('🎯 HEADSHOT! Hit Y:', hitPoint.y, 'Enemy Y:', enemyY, 'Relative:', hitRelativeY);
                            } else {
                                bodyShotsThisKill++; // Track for orb type
                            }

                            // Hit enemy - apply headshot multiplier
                            let damage = weapon.damage + Math.floor(Math.random() * 10);
                            if (isHeadshot) {
                                damage = Math.floor(damage * 1.5); // 50% bonus damage for headshots
                            }

                            // Store headshot state for kill sound
                            lastKillWasHeadshot = isHeadshot;

                            // Determine hit direction for death animation - PERF: Use reusable vectors
                            let hitDirection = 'front';
                            if (hitPlayerMesh) {
                                _reusableVec3A.copy(camera.position);
                                _reusableVec3B.copy(hitPlayerMesh.position);
                                _reusableVec3C.set(0, 0, -1).applyQuaternion(hitPlayerMesh.quaternion);
                                _reusableVec3A.sub(_reusableVec3B).normalize();
                                _reusableVec3A.y = 0; // Only horizontal direction
                                _reusableVec3C.y = 0;

                                const dot = _reusableVec3C.dot(_reusableVec3A);
                                _reusableVec3D.crossVectors(_reusableVec3C, _reusableVec3A);

                                if (dot > 0.5) {
                                    hitDirection = 'front'; // Shot from front
                                } else if (dot < -0.5) {
                                    hitDirection = 'back'; // Shot from back
                                } else if (_reusableVec3D.y > 0) {
                                    hitDirection = 'right'; // Shot from right
                                } else {
                                    hitDirection = 'front'; // Default to front for left shots
                                }
                            }

                            // In multiplayer, send hit to other player(s)
                            if (isMultiplayer) {
                                if (gameMode === '2v2') {
                                    // 2v2: send hit to specific player
                                    sendToOther({
                                        type: 'hit',
                                        damage: damage,
                                        target: hitPlayerId,
                                        team: myTeam,
                                        isHeadshot: isHeadshot,
                                        hitDirection: hitDirection
                                    });
                                } else {
                                    // 1v1: send hit to other player
                                    sendToOther({
                                        type: 'hit',
                                        damage: damage,
                                        target: otherPlayerId,
                                        isHeadshot: isHeadshot,
                                        hitDirection: hitDirection
                                    });
                                }
                            } else {
                                // AI mode
                                gameState.enemyHealth -= damage;
                            }

                            showHitMarker();
                            
                            // BF1-style hit feed HUD
                            if (window.bf1Hud) {
                                bf1Hud.addEvent("ENEMY HIT", damage, 'normal');
                                if (isHeadshot) {
                                    bf1Hud.addEvent("HEADSHOT BONUS", 15, 'crit');
                                }
                            }

                            // Blood splatter effect on hit
                            _reusableVec3E.copy(hitPoint);
                            createBloodSplatter(_reusableVec3E, 1, isHeadshot);

                            const hitVolume = calculateDistanceVolume(hitPlayerMesh ? hitPlayerMesh.position : enemy.position);
                            playHitSound(hitVolume);

                            if (!isMultiplayer && gameState.enemyHealth <= 0) {
                                enemyDied(isHeadshot);
                            }
                        }
                    } else {
                        // Hit a surface, not an enemy - create bullet hole and sparks
                        createBulletHole(hitPoint, hitNormal);
                        createImpactSparks(hitPoint, hitNormal, 6);
                        createDebrisParticles(hitPoint, 3);
                    }
                }

                // Multiplayer: if you miss close to an enemy, tell them to play a whiz sound locally
                if (isMultiplayer && !didHitEnemy && _whizLastSentAtByTarget) {
                    const nowMs = performance.now();

                    if (gameMode === '2v2') {
                        for (let i = 0; i < otherPlayers.length; i++) {
                            const playerData = otherPlayers[i];
                            if (!playerData || !playerData.mesh || playerData.team === myTeam) continue;
                            const targetId = playerData.playerId;
                            if (!targetId) continue;

                            if (playerData.mesh.isDying || playerData.mesh.visible === false) continue;

                            const lastSent = _whizLastSentAtByTarget.get(targetId) || 0;
                            if ((nowMs - lastSent) < BULLET_WHIZ_SEND_COOLDOWN_MS) continue;

                            const targetRef = playerData.mesh.hitboxMesh || playerData.mesh;
                            targetRef.getWorldPosition(_whizTargetPos);

                            const distSqBody = distanceSqPointToSegment(_whizTargetPos, _shootBulletStart, _shootBulletEnd);
                            _whizHeadPos.copy(_whizTargetPos);
                            _whizHeadPos.y += BULLET_WHIZ_HEAD_OFFSET_Y;
                            const distSqHead = distanceSqPointToSegment(_whizHeadPos, _shootBulletStart, _shootBulletEnd);
                            const distSq = Math.min(distSqBody, distSqHead);

                            if (distSq < (BULLET_WHIZ_NEAR_RADIUS * BULLET_WHIZ_NEAR_RADIUS)) {
                                const dist = Math.sqrt(distSq);
                                const v = 0.15 + 0.85 * (1 - (dist / BULLET_WHIZ_NEAR_RADIUS));
                                sendToOther({ type: 'whiz', target: targetId, volume: clamp01(v) });
                                _whizLastSentAtByTarget.set(targetId, nowMs);
                            }
                        }
                    } else if (otherPlayer && otherPlayerId) {
                        if (!otherPlayer.isDying && otherPlayer.visible !== false) {
                            const lastSent = _whizLastSentAtByTarget.get(otherPlayerId) || 0;
                            if ((nowMs - lastSent) >= BULLET_WHIZ_SEND_COOLDOWN_MS) {
                                const targetRef = otherPlayer.hitboxMesh || otherPlayer;
                                targetRef.getWorldPosition(_whizTargetPos);

                                const distSqBody = distanceSqPointToSegment(_whizTargetPos, _shootBulletStart, _shootBulletEnd);
                                _whizHeadPos.copy(_whizTargetPos);
                                _whizHeadPos.y += BULLET_WHIZ_HEAD_OFFSET_Y;
                                const distSqHead = distanceSqPointToSegment(_whizHeadPos, _shootBulletStart, _shootBulletEnd);
                                const distSq = Math.min(distSqBody, distSqHead);

                                if (distSq < (BULLET_WHIZ_NEAR_RADIUS * BULLET_WHIZ_NEAR_RADIUS)) {
                                    const dist = Math.sqrt(distSq);
                                    const v = 0.15 + 0.85 * (1 - (dist / BULLET_WHIZ_NEAR_RADIUS));
                                    sendToOther({ type: 'whiz', target: otherPlayerId, volume: clamp01(v) });
                                    _whizLastSentAtByTarget.set(otherPlayerId, nowMs);
                                }
                            }
                        }
                    }
                }

                // Increase combat intensity when shooting (for heartbeat sound)
                increaseCombatIntensity(0.2);

                // Shoot cooldown based on weapon fire rate
                // Increase spray recoil for sustained fire
                sprayRecoilMultiplier = Math.min(sprayRecoilMultiplier + 0.15, 2.5); // Max 2.5x recoil

                setTimeout(() => {
                    gameState.canShoot = true;
                    // Continue shooting if mouse still held (Gun Spam)
                    if (isMouseDown && gameState.started && !gameState.paused && !gameState.isDying && gameState.currentAmmo > 0) {
                        shoot();
                    } else {
                        // Reset spray recoil when shooting stops
                        sprayRecoilMultiplier = 1.0;
                    }
                }, weapon.fireRate);

                // Attribute stalls that happen inside the input handler itself
                if (_dbgShootT0) {
                    const _dbgShootMs = performance.now() - _dbgShootT0;
                    if (_dbgShootMs > 2) {
                        stutterEvent('shoot.handler', { ms: +_dbgShootMs.toFixed(2) });
                    }
                }
            }

            function reload() {
                if (gameState.isReloading || gameState.currentAmmo === gameState.maxAmmo || gameState.reserveAmmo === 0) {
                    return;
                }

                const weapon = weapons[gameState.currentWeapon];
                gameState.isReloading = true;

                // Show reload indicator
                document.getElementById('reloadIndicator').style.display = 'block';

                // Play reload sound
                playReloadSound();

                // Play weapon reload animation if available
                playWeaponAnimation('reload');

                setTimeout(() => {
                    const ammoNeeded = gameState.maxAmmo - gameState.currentAmmo;
                    const ammoToReload = Math.min(ammoNeeded, gameState.reserveAmmo);

                    gameState.currentAmmo += ammoToReload;
                    gameState.reserveAmmo -= ammoToReload;
                    gameState.isReloading = false;

                    // Hide reload indicator
                    document.getElementById('reloadIndicator').style.display = 'none';

                    updateHUD();
                    updateWeaponAmmoSprite();
                }, weapon.reloadTime);
            }

            function showHitMarker() {
                const marker = document.getElementById('hitMarker');
                marker.style.display = 'block';
                setTimeout(() => {
                    marker.style.display = 'none';
                }, 100);
            }

            // Uncharted 3 Near-Death Effect - triggered when taking damage
            showDamage = function () {
                // Flash the CSS damage overlay briefly (red edges)
                const overlay = document.getElementById('damageOverlay');
                overlay.style.opacity = '1';
                setTimeout(() => {
                    overlay.style.opacity = '0';
                }, 150);
                
                // Set healing delay - player must wait before health/trauma recovers
                gameState.healingDelay = 3.0; // 3 seconds before healing starts
                
                // Calculate trauma target based on current health
                // Lower health = more trauma (desaturation + blood vignette)
                gameState.traumaTarget = (100 - gameState.playerHealth) / 100;
                
                // Trigger trauma audio (shell shock / numb sound effect with more intensity)
                const audioIntensity = Math.max(0.5, gameState.traumaTarget * 1.2);
                triggerTraumaAudio(audioIntensity);
            }

            function respawnEnemy() {
                enemyState.isDying = false;
                gameState.enemyHealth = 100;
                enemy.visible = true;
                enemy.position.set(
                    (Math.random() - 0.5) * 20,
                    1.7,
                    15 + Math.random() * 10
                );
                enemy.rotation.set(0, 0, 0);



                // Stop other player death sound if active
                if (activeOtherPlayerDeathSound.gainNode && audioContext) { // Check if a sound is active and audio initialized
                    activeOtherPlayerDeathSound.gainNode.gain.cancelScheduledValues(audioContext.currentTime);
                    activeOtherPlayerDeathSound.gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
                    activeOtherPlayerDeathSound.source.stop(audioContext.currentTime + 0.1); // Explicitly stop the source immediately
                    activeOtherPlayerDeathSound = { source: null, gainNode: null }; // Nullify immediately
                }

                // Reset body shot sequence on enemy respawn
                currentBodyShotIndex = 0;
            }

            function enemyDied(isHeadshot = false) {
                if (enemyState.isDying) return;

                gameState.playerScore++;
                enemyState.isDying = true;
                enemyState.deathTimer = 0;

                // Record kill in level system (with headshot tracking)
                LevelSystem.recordKill(isHeadshot);

                // Determine kill type for XP orbs
                const killType = getKillType(isHeadshot);

                // Spawn XP orbs at enemy position (Minecraft style!)
                if (enemy && enemy.position) {
                    // PERF: Pass position directly - spawnXPOrbs copies it internally
                    spawnXPOrbs(enemy.position, killType);
                }

                // Reset kill tracking for next engagement
                resetKillTracking();

                // Get enemy name and avatar for kill feed
                const enemyName = gameState.otherPlayerUsername || 'ENEMY';
                const enemyAvatarSrc = generateDefaultAvatar(enemyName, true);

                // Play appropriate kill sound based on headshot
                if (isHeadshot) {
                    playHeadshotKillSound(1.0);
                    addKillFeedMessage('🎯 HEADSHOT! You eliminated Enemy');
                    console.log('💀 Enemy killed with HEADSHOT!');
                    // BF1 kill feed with enemy name and avatar
                    if (window.bf1Hud) {
                        bf1Hud.addEvent(enemyName, 100, 'kill', enemyAvatarSrc);
                        bf1Hud.addEvent("HEADSHOT BONUS", 25, 'kill');
                    }
                } else {
                    playKillSound(1.0);
                    addKillFeedMessage('You eliminated Enemy');
                    console.log('💀 Enemy killed with body shot');
                    // BF1 kill feed with enemy name and avatar
                    if (window.bf1Hud) {
                        bf1Hud.addEvent(enemyName, 100, 'kill', enemyAvatarSrc);
                    }
                }

                // Reset body shot sequence after kill
                currentBodyShotIndex = 0;

                updateHUD();

                if (gameState.playerScore >= 10) {
                    endGame(true);
                } else {
                    setTimeout(respawnEnemy, 5000); // 5 seconds delay (was 3 seconds)
                }
            }

            function respawn() {
                console.log('🔄 respawn called. Current time:', audioContext ? audioContext.currentTime : 'N/A');
                const deathScreen = document.getElementById('deathScreen');
                deathScreen.style.opacity = 0;
                deathScreen.style.background = 'rgba(0,0,0,0)';

                gameState.playerHealth = 100;
                gameState.isDying = false;
                gameState.weaponVisible = true; // Explicitly show weapon on respawn
                gameState.deathTimer = 0; // Reset death timer
                
                // Reset Uncharted 3 near-death effect
                gameState.trauma = 0;
                gameState.traumaTarget = 0;
                gameState.healingDelay = 0;

                // Don't stop death sound immediately - let it continue playing
                // The sound will naturally fade out based on its original schedule
                console.log('Death sound continues playing after respawn (if active)');

                // Only hide the speaker icon overlay when respawning
                const speakerIcon = document.getElementById('speakerIconOverlay');
                if (speakerIcon) speakerIcon.style.display = 'none';

                // Respawn player - position based on team and map
                let newX, newY, newZ;
                const isPlayerSide = (gameMode === '2v2') ? (myTeam === 1) : true;
                const baseSpawn = getSpawnPosition(isPlayerSide);

                // Add some randomization to spawn position
                const spawnSpread = (selectedMap === 'map1') ? 3 : 10; // Smaller spread for arena map
                newX = baseSpawn.x + (Math.random() - 0.5) * spawnSpread;
                newY = baseSpawn.y;
                newZ = baseSpawn.z + (Math.random() - 0.5) * (spawnSpread / 2);

                camera.position.set(newX, newY, newZ);
                camera.rotation.set(0, 0, 0);
                console.log('🎮 Respawned at:', newX, newY, newZ, 'Map:', selectedMap);

                // CRITICAL: Send respawn notification to other players in multiplayer
                if (isMultiplayer) {
                    console.log('📤 Sending respawn notification to other players');
                    sendToOther({
                        type: 'respawn',
                        team: myTeam,
                        x: newX,
                        y: newY,
                        z: newZ
                    });

                    // Update own squad data
                    if (myPlayerId) {
                        const mySquadInfo = squadData.get(myPlayerId) || { health: 100, weapon: 'rifle', isDying: false };
                        mySquadInfo.health = 100;
                        mySquadInfo.isDying = false;
                        squadData.set(myPlayerId, mySquadInfo);
                    }
                }

                // Reset death camera tracking
                gameState.deathCameraTarget = null;
                gameState.killerGlowMeshes = null;
                gameState.killerGlowSource = null;

                // Hide killer info
                document.getElementById('killerInfo').style.display = 'none';

                // Remove glow from killer (handle 2v2 mode)
                let killerMesh = null;
                if (gameMode === '2v2' && isMultiplayer) {
                    // Find nearest enemy for glow removal
                    otherPlayers.forEach((playerData) => {
                        if (playerData && playerData.mesh && playerData.team !== myTeam) {
                            killerMesh = playerData.mesh;
                        }
                    });
                } else {
                    killerMesh = isMultiplayer ? otherPlayer : enemy;
                }
                if (killerMesh) {
                    killerMesh.traverse((child) => {
                        if (child.isMesh && child.material && child.userData.originalEmissive) {
                            child.material.emissive.copy(child.userData.originalEmissive);
                            child.material.emissiveIntensity = child.userData.originalEmissiveIntensity || 0;
                            if (child.userData.originalColorHex !== undefined && child.material.color) {
                                child.material.color.setHex(child.userData.originalColorHex);
                                delete child.userData.originalColorHex;
                            }
                            delete child.userData.originalEmissive;
                            delete child.userData.originalEmissiveIntensity;
                            delete child.userData.materialCloned;
                        }
                    });
                }


                // Reset movement state to prevent carrying momentum after respawn
                moveForward = false;
                moveBackward = false;
                moveLeft = false;
                moveRight = false;

                updateHUD();
            }

            playerDied = function () {
                if (gameState.isDying) return;

                console.log('playerDied called. Current time:', audioContext ? audioContext.currentTime : 'N/A');
                gameState.enemyScore++;
                gameState.isDying = true;
                gameState.weaponVisible = false; // Hide weapon during death cam
                gameState.deathTimer = 0;
                gameState.killerGlowMeshes = null;
                gameState.killerGlowSource = null;

                // Record death in level system
                LevelSystem.recordDeath();

                // Store death position for corpse camera
                gameState.deathPosition = camera.position.clone();
                gameState.deathPosition.y = 0.8; // Corpse eye level

                // Store killer info and position
                let killerName = 'Enemy';
                let killerWeapon = 'AK-47';
                let killerHP = 100;

                if (gameMode === '2v2' && isMultiplayer) {
                    // 2v2 mode: find the nearest enemy player as the likely killer
                    let nearestEnemy = null;
                    let nearestDistance = Infinity;
                    otherPlayers.forEach((playerData) => {
                        if (playerData && playerData.mesh && playerData.team !== myTeam) {
                            const dist = camera.position.distanceTo(playerData.mesh.position);
                            if (dist < nearestDistance) {
                                nearestDistance = dist;
                                nearestEnemy = playerData;
                            }
                        }
                    });
                    if (nearestEnemy && nearestEnemy.mesh) {
                        gameState.killerPosition = nearestEnemy.mesh.position.clone();
                        const squadInfo = squadData.get(nearestEnemy.playerId);
                        killerName = squadInfo?.username || 'Enemy';
                        killerHP = squadInfo?.health || 100;
                        killerWeapon = squadInfo?.weapon || 'AK-47';
                    }
                } else if (enemy) {
                    gameState.killerPosition = enemy.position.clone();
                    killerName = 'Enemy';
                    killerHP = 100; // AI always full HP
                    killerWeapon = 'AK-47';
                } else if (isMultiplayer && otherPlayer) {
                    gameState.killerPosition = otherPlayer.position.clone();
                    killerName = gameState.otherPlayerUsername || 'Player';
                    killerHP = 100; // Get from network if available
                    killerWeapon = 'AK-47'; // Get from network if available
                }

                // Show killer info
                const killerInfo = document.getElementById('killerInfo');
                document.getElementById('killerName').textContent = killerName;
                document.getElementById('killerHpText').textContent = killerHP;
                document.getElementById('killerHpBar').style.width = killerHP + '%';
                document.getElementById('killerWeapon').textContent = killerWeapon;
                killerInfo.style.display = 'block';

                const deathScreen = document.getElementById('deathScreen');
                deathScreen.style.opacity = 1;
                deathScreen.style.background = 'rgba(0,0,0,0.8)';

                // Clear any pending fade timeouts from previous deaths
                if (gameState.pendingFadeTimeout) {
                    clearTimeout(gameState.pendingFadeTimeout);
                    gameState.pendingFadeTimeout = null;
                }

                // Test function for rapid death simulation
                window.testRapidDeaths = function () {
                    console.log('🧪 Testing rapid deaths...');
                    playerDied();
                    setTimeout(() => {
                        console.log('🧪 Second death after 500ms');
                        playerDied();
                    }, 500);
                    setTimeout(() => {
                        console.log('🧪 Third death after 1000ms');
                        playerDied();
                    }, 1000);
                };

                // Stop any existing death sound before playing new one
                if (activeDeathSound && activeDeathSound.source) {
                    try {
                        activeDeathSound.source.stop();
                        activeDeathSound.source.disconnect();
                        activeDeathSound.gainNode.disconnect();
                    } catch (e) {
                        console.log('Error stopping previous death sound:', e);
                    }
                    activeDeathSound = { source: null, gainNode: null };
                }

                // Play death sound with offset, duration, and fade out
                if (deathSoundMedia) {
                    deathSoundMedia.play(1, 1);

                    // Show speaker icon overlay
                    const speakerIcon = document.getElementById('speakerIconOverlay');
                    if (speakerIcon) {
                        speakerIcon.style.display = 'block';
                        speakerIcon.style.opacity = '1';
                        speakerIcon.style.transition = '';
                    }

                    // Fade speaker icon similar to buffer path
                    if (speakerIcon) {
                        gameState.pendingFadeTimeout = setTimeout(() => {
                            if (speakerIcon.style.display === 'block') {
                                speakerIcon.style.transition = 'opacity 3s ease-out';
                                speakerIcon.style.opacity = '0';
                            }
                        }, 5000);
                    }
                } else if (deathSoundBuffer && audioContext) {
                    const soundDuration = 8; // Extended duration - sound continues much longer after respawn
                    const fadeOutTime = 3.0; // Fade out starts after 5 seconds, takes 3 seconds to complete
                    const { source, gainNode } = playSound(deathSoundBuffer, 1, 1); // Play from 1s
                    activeDeathSound = { source, gainNode }; // Store both
                    console.log('Death sound started. Source:', source, 'GainNode:', gainNode);

                    // Show speaker icon overlay
                    const speakerIcon = document.getElementById('speakerIconOverlay');
                    if (speakerIcon) {
                        speakerIcon.style.display = 'block';
                        speakerIcon.style.opacity = '1';
                        speakerIcon.style.transition = ''; // Clear any previous transitions
                    }

                    gainNode.gain.setValueAtTime(gainNode.gain.value, audioContext.currentTime); // Set initial gain
                    gainNode.gain.setValueAtTime(gainNode.gain.value, audioContext.currentTime + 5); // Keep full volume for 5 seconds
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + soundDuration); // Fade out over last 3 seconds
                    source.stop(audioContext.currentTime + soundDuration);

                    // Fade speaker icon with the sound
                    if (speakerIcon) {
                        // Keep icon visible for 5 seconds, then fade over 3 seconds
                        gameState.pendingFadeTimeout = setTimeout(() => {
                            if (speakerIcon.style.display === 'block') {
                                speakerIcon.style.transition = 'opacity 3s ease-out';
                                speakerIcon.style.opacity = '0';
                            }
                        }, 5000);
                    }

                    // Also, ensure the source disconnects when it ends
                    source.onended = () => {
                        console.log('Death sound onended fired. Source:', source, 'GainNode:', gainNode);
                        source.disconnect();
                        gainNode.disconnect();
                        if (activeDeathSound.source === source) { // Only nullify if it's still the active one
                            activeDeathSound = { source: null, gainNode: null };
                            console.log('activeDeathSound nullified by onended.');
                            // Hide speaker icon overlay after fade completes (only if still current)
                            if (speakerIcon && !gameState.isDead) {
                                speakerIcon.style.display = 'none';
                                speakerIcon.style.transition = '';
                                speakerIcon.style.opacity = '1';
                            }
                        }
                    };
                }

                addKillFeedMessage('Enemy eliminated You');
                updateHUD();

                if (gameState.enemyScore >= 10) {
                    endGame(false);
                } else {
                    setTimeout(respawn, 3000); // Fixed respawn timer - independent of sound duration
                }
                if (audioContext) {
                    console.log('Respawn scheduled for:', audioContext.currentTime + 5);
                }
            }

            // Smooth Kill Feed - Professional style with killer/weapon/victim format
            addKillFeedMessage = function (message, isHeadshot = false) {
                const feed = document.getElementById('killFeed');
                const msg = document.createElement('div');
                msg.className = 'kill-message';

                // Parse the message to extract killer, victim, and determine if it's the player
                let killer = '';
                let victim = '';
                let isMe = false;
                let weaponIcon = '✕'; // Default crosshair

                if (message.includes('You eliminated')) {
                    killer = gameState.playerUsername || 'You';
                    victim = message.includes('Enemy') ? 'Enemy' : message.split('eliminated ')[1];
                    isMe = true;
                } else if (message.includes('eliminated You')) {
                    killer = message.split(' eliminated')[0];
                    victim = gameState.playerUsername || 'You';
                    isMe = false;
                } else if (message.includes('Eliminated')) {
                    killer = gameState.playerUsername || 'You';
                    victim = message.split('Eliminated ')[1];
                    isMe = true;
                } else {
                    // Fallback: just show the message
                    msg.innerHTML = `<span class="k-name">${message}</span>`;
                    feed.insertBefore(msg, feed.firstChild);
                    setTimeout(() => msg.remove(), 5000);
                    return;
                }

                // Weapon icon based on current weapon or headshot
                if (isHeadshot || message.includes('HEADSHOT')) {
                    weaponIcon = '🎯';
                    msg.classList.add('headshot');
                } else {
                    // Use current weapon icon
                    const weapon = gameState.currentWeapon || 'rifle';
                    const weaponIcons = {
                        'rifle': '⊕',
                        'pistol': '◎',
                        'sniper': '⊛',
                        'shotgun': '⊗',
                        'smg': '⊙'
                    };
                    weaponIcon = weaponIcons[weapon] || '✕';
                }

                if (isMe) {
                    msg.classList.add('is-me');
                }

                msg.innerHTML = `
                <span class="k-name">${killer}</span>
                <span class="w-icon">${weaponIcon}</span>
                <span class="v-name">${victim}</span>
            `;

                feed.insertBefore(msg, feed.firstChild);

                setTimeout(() => {
                    msg.remove();
                }, 5000);
            }

            // ========== BF1-STYLE HIT FEED HUD SYSTEM ==========
            class BF1HudFeed {
                constructor() {
                    this.container = document.getElementById('bf1HitHud');
                    this.listEl = document.getElementById('bf1FeedList');
                    this.totalEl = document.getElementById('bf1FeedTotal');
                    this.activeRows = {};
                    this.targetScore = 0;
                    this.currentScore = 0;
                    this.hideTimer = null;
                }

                addEvent(name, score, type, avatarSrc = null) {
                    if (!this.container) return;
                    this.container.style.opacity = '1';
                    this.targetScore += score;
                    const shouldStack = (type !== 'kill'); // Hits stack, kills make new lines

                    if (this.activeRows[name] && shouldStack) {
                        // Stack existing row
                        const rowObj = this.activeRows[name];
                        rowObj.scoreTarget += score;
                        // Subtle pop animation
                        const dom = rowObj.dom;
                        dom.style.transform = "scale(1.1)";
                        setTimeout(() => dom.style.transform = "scale(1)", 100);
                    } else {
                        // Create new line
                        const row = document.createElement('div');
                        row.className = 'bf1-feed-item';
                        if (type === 'crit') row.classList.add('is-crit');
                        if (type === 'kill') row.classList.add('is-kill');

                        // Build row content: avatar (if kill), name, and score
                        let content = `<span>${name}</span><span class="bf1-feed-val">${score}</span>`;
                        if (type === 'kill' && avatarSrc) {
                            content = `<img class="bf1-feed-avatar" src="${avatarSrc}" alt="${name}"/><span>${name}</span><span class="bf1-feed-val">${score}</span>`;
                        }
                        row.innerHTML = content;
                        this.listEl.insertBefore(row, this.listEl.firstChild); // Newest on top

                        if (shouldStack) {
                            this.activeRows[name] = {
                                dom: row,
                                valSpan: row.querySelector('.bf1-feed-val'),
                                scoreCurrent: score,
                                scoreTarget: score
                            };
                        }
                    }

                    if (this.hideTimer) clearTimeout(this.hideTimer);
                    this.hideTimer = setTimeout(() => this.fadeOut(), 2500);
                }

                update() {
                    // Lerp total score (15% closer each frame)
                    if (Math.abs(this.targetScore - this.currentScore) > 0.5) {
                        this.currentScore += (this.targetScore - this.currentScore) * 0.15;
                        if (this.totalEl) this.totalEl.innerText = "+" + Math.floor(this.currentScore);
                    } else if (Math.floor(this.currentScore) !== this.targetScore) {
                        this.currentScore = this.targetScore;
                        if (this.totalEl) this.totalEl.innerText = "+" + Math.floor(this.currentScore);
                    }

                    // Lerp individual stacked rows
                    for (let key in this.activeRows) {
                        const item = this.activeRows[key];
                        if (item.scoreTarget > item.scoreCurrent) {
                            item.scoreCurrent += (item.scoreTarget - item.scoreCurrent) * 0.2;
                            if (item.valSpan) item.valSpan.innerText = Math.floor(item.scoreCurrent);
                        }
                    }
                }

                fadeOut() {
                    if (this.container) this.container.style.opacity = '0';
                    setTimeout(() => {
                        this.targetScore = 0;
                        this.currentScore = 0;
                        if (this.listEl) this.listEl.innerHTML = '';
                        this.activeRows = {};
                        if (this.totalEl) this.totalEl.innerText = "+0";
                    }, 500);
                }
            }

            // Create global BF1 HUD instance
            const bf1Hud = new BF1HudFeed();
            window.bf1Hud = bf1Hud;

            // ========== AI HIT PLAYER FUNCTION (for testing) ==========
            window.aiHitPlayer = function() {
                if (!gameState || !gameState.started || gameState.isDying) {
                    console.log('Cannot hit player - game not active');
                    return;
                }
                
                // Play bullet hit sound
                window.playBulletHitSound?.(0.8);
                
                // Random damage between 15-35
                const damage = 15 + Math.floor(Math.random() * 20);
                const isHeadshot = Math.random() < 0.2; // 20% chance headshot
                const actualDamage = isHeadshot ? damage * 2 : damage;
                
                // Apply damage (clamp to prevent negative health)
                gameState.playerHealth = Math.max(0, gameState.playerHealth - actualDamage);
                
                // Update HUD
                updateHUD();
                
                // Trigger damage visual effects
                showDamage();
                
                if (isHeadshot) {
                    bf1Hud.addEvent("HEADSHOT!", 0, 'kill');
                }
                
                console.log(`🎯 AI Hit: ${actualDamage} damage (Headshot: ${isHeadshot}), Health: ${gameState.playerHealth}`);
                
                // Check for death
                if (gameState.playerHealth <= 0) {
                    playerDied();
                }
            };

            // Micro Float HUD - Minimal Floating Squad List (Right-aligned)
            function renderGameStatsHUD() {
                const statsHud = document.getElementById('game-stats-hud');
                if (!statsHud) return;

                // Only show during active gameplay
                if (!gameState || !gameState.started) {
                    statsHud.style.display = 'none';
                    return;
                }

                statsHud.style.display = 'flex';

                // Get player's profile picture
                const playerAvatar = window.ProfilePicture ? window.ProfilePicture.get() : null;
                const playerName = gameState.playerUsername || 'PLAYER';
                const playerLevel = (window.LevelSystem && window.LevelSystem.data) ? window.LevelSystem.data.level : 1;

                // Collect all players
                const players = [];

                // Add local player
                const playerHealth = gameState.playerHealth || 100;
                const playerIsDead = gameState.isDying || playerHealth <= 0;
                players.push({
                    name: playerName.toUpperCase(),
                    ping: Math.floor(Math.random() * 20) + 5,
                    health: playerHealth,
                    maxHealth: 100,
                    isMe: true,
                    isDead: playerIsDead,
                    level: playerLevel,
                    avatarUrl: playerAvatar,
                    avatarSeed: playerName
                });

                // Add enemies from otherPlayers (multiplayer)
                if (otherPlayers && otherPlayers.length > 0) {
                    otherPlayers.forEach((playerData, index) => {
                        if (playerData && playerData.mesh) {
                            const squadInfo = squadData.get(playerData.playerId) || {};
                            const enemyAvatar = gameState.otherPlayerAvatar || null;
                            const isDead = playerData.mesh.isDying || false;
                            const enemyName = squadInfo.username || `ENEMY`;
                            players.push({
                                name: enemyName.toUpperCase(),
                                ping: Math.floor(Math.random() * 50) + 10,
                                health: squadInfo.health || 100,
                                maxHealth: 100,
                                isMe: false,
                                isDead: isDead,
                                level: squadInfo.level || Math.floor(Math.random() * 20) + 1,
                                avatarUrl: enemyAvatar,
                                avatarSeed: enemyName
                            });
                        }
                    });
                }

                // If no other players (singleplayer), show single enemy bot status
                if (players.length === 1 && typeof enemy !== 'undefined' && enemy && typeof enemyState !== 'undefined') {
                    const isDead = enemyState.isDying || gameState.enemyHealth <= 0;
                    players.push({
                        name: 'BOT',
                        ping: Math.floor(Math.random() * 30) + 5,
                        health: isDead ? 0 : (gameState.enemyHealth || 100),
                        maxHealth: 100,
                        isMe: false,
                        isDead: isDead,
                        level: 5,
                        avatarUrl: null,
                        avatarSeed: 'Bot'
                    });
                }

                // Build HTML - Order: PING → AVATAR → INFO (left-aligned, under FPS counter)
                let html = '';
                players.forEach(player => {
                    // Ping color class
                    let pingClass = 'p-good';
                    if (player.ping > 50) pingClass = 'p-mid';
                    if (player.ping > 100) pingClass = 'p-bad';

                    const healthPct = Math.max(0, Math.min(100, (player.health / player.maxHealth) * 100));

                    let rowClass = 'player-row';
                    if (player.isMe) rowClass += ' me';
                    if (player.isDead) rowClass += ' dead';

                    // Avatar: use uploaded image or DiceBear API
                    let avatarSrc;
                    if (player.avatarUrl) {
                        avatarSrc = player.avatarUrl;
                    } else {
                        avatarSrc = `https://api.dicebear.com/7.x/notionists/svg?seed=${player.avatarSeed}`;
                    }

                    html += `
                    <div class="${rowClass}">
                        <!-- PING -->
                        <div class="ping-display ${pingClass}">${player.ping}ms</div>
                        
                        <!-- AVATAR -->
                        <div class="avatar-wrap">
                            <img class="avatar-img" src="${avatarSrc}" alt="">
                            <div class="rank-num">${player.level}</div>
                        </div>
                        
                        <!-- INFO COL -->
                        <div class="info-col">
                            <div class="name-row">${player.name}</div>
                            ${!player.isDead ? `
                                <div class="hp-rail">
                                    <div class="hp-fill" style="width: ${healthPct}%"></div>
                                </div>
                            ` : `<div class="weap-row">K.I.A.</div>`}
                        </div>
                    </div>
                `;
                });

                statsHud.innerHTML = html;
            }

            // Update Squad List with real game data - DISABLED for cleaner gameplay
            function updateSquadList() {
                const squadListEl = document.getElementById('squad-list');
                if (!squadListEl) return;

                // Squad list is disabled during gameplay - always hide it
                squadListEl.style.display = 'none';
                return;

                // Original code below (disabled)
                /*
                // Show when game is started
                if (!gameState || !gameState.started) {
                    squadListEl.style.display = 'none';
                    return;
                }
                
                // Show in both 1v1 and 2v2 modes
                if (gameMode !== '2v2' && gameMode !== '1v1') {
                    squadListEl.style.display = 'none';
                    return;
                }
                
                squadListEl.style.display = 'flex';
                squadListEl.innerHTML = '';
                
                // Get ALL players (teammates and enemies)
                const allPlayers = [];
                
                // Add local player
                if (myPlayerId) {
                    allPlayers.push({
                        playerId: myPlayerId,
                        isYou: true,
                        health: gameState.playerHealth || 100,
                        weapon: gameState.currentWeapon || 'rifle',
                        isDying: gameState.isDying || (gameState.playerHealth || 100) <= 0,
                        username: gameState.playerUsername || 'Player',
                        team: myTeam || 1,
                        isTeammate: true
                    });
                }
                
                // Add all other players from otherPlayers array
                if (otherPlayers && otherPlayers.length > 0) {
                    otherPlayers.forEach((playerData) => {
                        if (playerData && playerData.playerId) {
                            const squadInfo = squadData.get(playerData.playerId) || {
                                health: 100,
                                weapon: 'rifle',
                                isDying: false,
                                username: `Player ${playerData.playerId ? playerData.playerId.substring(0, 4) : '???'}`
                            };
                            
                            // Update from mesh state if available
                            if (playerData.mesh) {
                                squadInfo.isDying = playerData.mesh.isDying || false;
                            }
                            
                            const isTeammate = playerData.team === myTeam;
                            
                            allPlayers.push({
                                playerId: playerData.playerId,
                                isYou: false,
                                health: squadInfo.health,
                                weapon: squadInfo.weapon,
                                isDying: squadInfo.isDying,
                                username: squadInfo.username,
                                team: playerData.team,
                                isTeammate: isTeammate
                            });
                        }
                    });
                }
                
                // In 1v1 mode, also add the other player if they exist
                if (gameMode === '1v1' && otherPlayerId && !allPlayers.find(p => p.playerId === otherPlayerId)) {
                    const squadInfo = squadData.get(otherPlayerId) || {
                        health: 100,
                        weapon: 'rifle',
                        isDying: false,
                        username: gameState.otherPlayerUsername || `Player ${otherPlayerId.substring(0, 4)}`
                    };
                    
                    allPlayers.push({
                        playerId: otherPlayerId,
                        isYou: false,
                        health: squadInfo.health,
                        weapon: squadInfo.weapon,
                        isDying: squadInfo.isDying,
                        username: squadInfo.username,
                        team: myTeam === 1 ? 2 : 1,
                        isTeammate: false
                    });
                }
                
                // If no players, don't show
                if (allPlayers.length === 0) {
                    squadListEl.style.display = 'none';
                    return;
                }
                
                // Sort: you first, then teammates, then enemies
                allPlayers.sort((a, b) => {
                    if (a.isYou) return -1;
                    if (b.isYou) return 1;
                    if (a.isTeammate && !b.isTeammate) return -1;
                    if (!a.isTeammate && b.isTeammate) return 1;
                    return (a.playerId || '').localeCompare(b.playerId || '');
                });
                
                // Render all players
                allPlayers.forEach((member, index) => {
                    const memberEl = document.createElement('div');
                    const isTeammate = member.isTeammate || member.isYou;
                    memberEl.className = `squad-member ${member.isYou ? 'you' : (isTeammate ? 'teammate' : 'enemy')}`;
                    
                    // Determine status - green for teammates, red for enemies
                    let statusClass = '';
                    let statusText = '';
                    
                    if (member.isDying || member.health <= 0) {
                        statusClass = 'kia';
                        statusText = '<span class="squad-member-tag kia">KIA</span>';
                    } else if (member.health < 50) {
                        statusClass = isTeammate ? 'injured' : 'enemy injured';
                    } else {
                        statusClass = isTeammate ? 'healthy' : 'enemy';
                    }
                    
                    // Get weapon tag
                    let weaponTag = '';
                    if (!member.isDying && member.weapon && weapons && weapons[member.weapon]) {
                        const weaponName = weapons[member.weapon].name || member.weapon.toUpperCase();
                        if (weaponName === 'AWP' || weaponName.includes('SNIPER')) {
                            weaponTag = '<span class="squad-member-tag weapon">DMR</span>';
                        } else if (weaponName === 'DEAGLE' || weaponName.includes('PISTOL')) {
                            weaponTag = '<span class="squad-member-tag weapon">PISTOL</span>';
                        }
                    }
                    
                    // Use actual username
                    let displayName = member.username || `Player ${member.playerId ? member.playerId.substring(0, 4) : '???'}`;
                    if (member.isYou) {
                        displayName = `${displayName} (YOU)`;
                    }
                    
                    memberEl.innerHTML = `
                        <div class="squad-status-indicator ${statusClass}"></div>
                        <div class="squad-member-name">${displayName}</div>
                        ${weaponTag}
                        ${statusText}
                    `;
                    
                    squadListEl.appendChild(memberEl);
                });
                */
            }

            // CS2-Style Scoreboard Update Function (DISABLED - replaced by R6 Topbar)
            function updateCS2Scoreboard() {
                const scoreboard = document.getElementById('cs2Scoreboard');
                if (!scoreboard) return;

                // ALWAYS hide - replaced by R6 Topbar
                scoreboard.style.display = 'none';
                return;

                // Show scoreboard during gameplay
                if (gameState.started) {
                    scoreboard.style.display = 'flex';
                } else {
                    scoreboard.style.display = 'none';
                    return;
                }

                // Get player info
                const myName = gameState.playerUsername || 'PLAYER';
                const enemyName = gameState.otherPlayerUsername || 'ENEMY';

                // Get avatars - use ProfilePicture from global scope
                let myAvatar = null;
                let enemyAvatar = gameState.otherPlayerAvatar || null;

                // Try to get player's avatar from ProfilePicture system
                if (typeof ProfilePicture !== 'undefined' && ProfilePicture.get) {
                    myAvatar = ProfilePicture.get();
                }

                // Update names
                document.getElementById('cs2NameLeft').textContent = myName;
                document.getElementById('cs2NameRight').textContent = enemyName;

                // Update avatars
                const leftImg = document.getElementById('cs2AvatarImgLeft');
                const rightImg = document.getElementById('cs2AvatarImgRight');

                // Generate clean default avatar
                // Set player avatar (left side)
                if (myAvatar) {
                    leftImg.src = myAvatar;
                } else {
                    leftImg.src = generateDefaultAvatar(myName, false);
                }
                leftImg.style.display = 'block';

                // Set enemy avatar (right side)
                if (enemyAvatar) {
                    rightImg.src = enemyAvatar;
                } else {
                    rightImg.src = generateDefaultAvatar(enemyName, true);
                }
                rightImg.style.display = 'block';

                // Update scores
                document.getElementById('cs2ScoreLeft').textContent = gameState.playerScore;
                document.getElementById('cs2ScoreRight').textContent = gameState.enemyScore;
            }

            updateHUD = function () {
                const health = Math.max(0, gameState.playerHealth);

                // Update Postal 2 style health display
                const postalHealthNumber = document.getElementById('postal-health-number');
                const postalHeart = document.getElementById('postal-heart');

                if (postalHealthNumber) {
                    postalHealthNumber.textContent = health;
                    postalHealthNumber.classList.remove('critical', 'warning');
                    if (health <= 25) {
                        postalHealthNumber.classList.add('critical');
                    } else if (health <= 50) {
                        postalHealthNumber.classList.add('warning');
                    }
                }

                if (postalHeart) {
                    postalHeart.classList.remove('critical', 'warning', 'dead');
                    if (health <= 0) {
                        postalHeart.classList.add('dead');
                    } else if (health <= 25) {
                        postalHeart.classList.add('critical');
                        // Faster heartbeat at low health
                        postalHeart.style.animationDuration = `${0.2 + (health / 25) * 0.2}s`;
                    } else if (health <= 50) {
                        postalHeart.classList.add('warning');
                        postalHeart.style.animationDuration = `${0.4 + (health - 25) / 25 * 0.3}s`;
                    } else {
                        // Normal heartbeat, slower when healthier
                        postalHeart.style.animationDuration = `${0.8 + (health - 50) / 50 * 0.4}s`;
                    }
                }

                // Legacy support - also update old elements if they exist
                const healthElement = document.getElementById('health');
                if (healthElement) {
                    healthElement.textContent = health;
                }

                // Update score display based on game mode
                if (gameMode === '2v2') {
                    // 2v2: Show team scores
                    const team1Score = myTeam === 1 ? gameState.playerScore : gameState.enemyScore;
                    const team2Score = myTeam === 2 ? gameState.playerScore : gameState.enemyScore;
                    document.getElementById('score').textContent = `Team ${myTeam}: ${team1Score}`;
                    document.getElementById('enemyScore').textContent = `Team ${myTeam === 1 ? 2 : 1}: ${team2Score}`;
                } else {
                    // 1v1: Show individual scores
                    document.getElementById('score').textContent = gameState.playerScore;
                    document.getElementById('enemyScore').textContent = gameState.enemyScore;
                }

                // Update CS2 Scoreboard
                updateCS2Scoreboard();

                document.getElementById('currentAmmo').textContent = gameState.currentAmmo;
                document.getElementById('reserveAmmo').textContent = gameState.reserveAmmo;
                document.getElementById('weaponName').textContent = weapons[gameState.currentWeapon].name;

                // Update squad list (always call, it handles visibility internally)
                if (typeof updateSquadList === 'function') {
                    updateSquadList();
                }

                // Update micro float game stats HUD
                if (typeof renderGameStatsHUD === 'function') {
                    renderGameStatsHUD();
                }


                // Update connection status in multiplayer
                if (isMultiplayer) {
                    const statusDiv = document.getElementById('connectionStatus');
                    const statusIcon = document.getElementById('connectionIcon');
                    const statusText = document.getElementById('connectionText');

                    statusDiv.style.display = 'block';

                    if (socket && socket.connected) {
                        switch (connectionQuality) {
                            case 'good':
                                statusIcon.textContent = '🟢';
                                statusText.textContent = 'Connected (Good)';
                                statusText.style.color = '#4CAF50';
                                break;
                            case 'medium':
                                statusIcon.textContent = '🟡';
                                statusText.textContent = 'Connected (Medium)';
                                statusText.style.color = '#FFC107';
                                break;
                            case 'poor':
                                statusIcon.textContent = '🔴';
                                statusText.textContent = 'Connected (Poor)';
                                statusText.style.color = '#F44336';
                                break;
                            default:
                                statusIcon.textContent = '🌐';
                                statusText.textContent = 'Connected';
                                statusText.style.color = '#2196F3';
                        }
                    } else {
                        statusIcon.textContent = '🔴';
                        statusText.textContent = 'Disconnected';
                        statusText.style.color = '#F44336';
                    }
                } else {
                    document.getElementById('connectionStatus').style.display = 'none';
                }

                // Update R6 Topbar
                updateR6Topbar();
            }

            // ==================== R6-STYLE TOPBAR SYSTEM ====================
            let roundTimeLeft = 180; // 3 minutes per round
            let roundTimerInterval = null;
            let currentRound = 1;

            function startRoundTimer() {
                // Clear existing timer
                if (roundTimerInterval) {
                    clearInterval(roundTimerInterval);
                }

                roundTimeLeft = 180; // Reset to 3 minutes
                updateR6Timer();

                roundTimerInterval = setInterval(() => {
                    if (gameState.started && !gameState.paused) {
                        roundTimeLeft--;
                        if (roundTimeLeft <= 0) {
                            roundTimeLeft = 0;
                            // Time's up - could trigger round end
                        }
                        updateR6Timer();
                    }
                }, 1000);
            }

            function stopRoundTimer() {
                if (roundTimerInterval) {
                    clearInterval(roundTimerInterval);
                    roundTimerInterval = null;
                }
            }

            function updateR6Timer() {
                const timerEl = document.getElementById('r6Timer');
                if (!timerEl) return;

                const minutes = Math.floor(roundTimeLeft / 60);
                const seconds = roundTimeLeft % 60;
                const timeStr = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
                timerEl.textContent = timeStr;

                // Critical time warning (under 30 seconds)
                if (roundTimeLeft <= 30) {
                    timerEl.classList.add('critical');
                } else {
                    timerEl.classList.remove('critical');
                }
            }

            function updateR6Topbar() {
                // Update scores
                const blueScore = document.getElementById('r6BlueScore');
                const orangeScore = document.getElementById('r6OrangeScore');
                if (blueScore) blueScore.textContent = gameState.playerScore;
                if (orangeScore) orangeScore.textContent = gameState.enemyScore;

                // Update round text
                const roundText = document.getElementById('r6RoundText');
                if (roundText) {
                    currentRound = gameState.playerScore + gameState.enemyScore + 1;
                    roundText.textContent = `ROUND ${currentRound}`;
                }

                // Update player HP bar
                const playerHp = document.getElementById('r6PlayerHp');
                if (playerHp) {
                    const hpPercent = Math.max(0, gameState.playerHealth);
                    playerHp.style.width = `${hpPercent}%`;
                    playerHp.classList.remove('critical', 'warning');
                    if (hpPercent <= 25) {
                        playerHp.classList.add('critical');
                    } else if (hpPercent <= 50) {
                        playerHp.classList.add('warning');
                    }
                }

                // Update enemy HP bar
                const enemyHp = document.getElementById('r6EnemyHp');
                if (enemyHp) {
                    const hpPercent = Math.max(0, gameState.enemyHealth);
                    enemyHp.style.width = `${hpPercent}%`;
                    enemyHp.classList.remove('critical', 'warning');
                    if (hpPercent <= 25) {
                        enemyHp.classList.add('critical');
                    } else if (hpPercent <= 50) {
                        enemyHp.classList.add('warning');
                    }
                }

                // Update player card (dead state)
                const playerCard = document.getElementById('r6PlayerCard');
                if (playerCard) {
                    if (gameState.playerHealth <= 0 || gameState.isDying) {
                        playerCard.classList.add('is-dead');
                    } else {
                        playerCard.classList.remove('is-dead');
                    }
                }

                // Update enemy card (dead state)
                const enemyCard = document.getElementById('r6EnemyCard');
                if (enemyCard) {
                    if (gameState.enemyHealth <= 0) {
                        enemyCard.classList.add('is-dead');
                    } else {
                        enemyCard.classList.remove('is-dead');
                    }
                }

                // Update levels
                updateR6Levels();

                // Update avatars with profile pictures
                updateR6Avatars();
            }

            function getLevelTierClass(level) {
                if (level >= 50) return 'level-diamond';
                if (level >= 30) return 'level-platinum';
                if (level >= 20) return 'level-gold';
                if (level >= 10) return 'level-silver';
                return 'level-bronze';
            }

            function updateR6Levels() {
                // Player level from LevelSystem
                const playerLevelEl = document.getElementById('r6PlayerLevel');
                if (playerLevelEl) {
                    const playerLevel = (typeof LevelSystem !== 'undefined' && LevelSystem.data)
                        ? LevelSystem.data.level
                        : 1;
                    playerLevelEl.textContent = playerLevel;
                    playerLevelEl.className = 'r6-level-badge ' + getLevelTierClass(playerLevel);
                }

                // Enemy level from gameState
                const enemyLevelEl = document.getElementById('r6EnemyLevel');
                if (enemyLevelEl) {
                    const enemyLevel = gameState.otherPlayerLevel || 1;
                    enemyLevelEl.textContent = enemyLevel;
                    enemyLevelEl.className = 'r6-level-badge r6-level-enemy ' + getLevelTierClass(enemyLevel);
                }
            }

            function updateR6Avatars() {
                // Player avatar - use ProfilePicture system or generate from username
                const playerAvatar = document.getElementById('r6PlayerAvatar');
                if (playerAvatar) {
                    // Try to get custom profile picture first
                    const customAvatar = (typeof ProfilePicture !== 'undefined' && ProfilePicture.get)
                        ? ProfilePicture.get()
                        : null;

                    if (customAvatar) {
                        playerAvatar.src = customAvatar;
                    } else {
                        // Fall back to generated avatar with initials
                        const playerName = gameState.playerUsername || 'Player';
                        const initials = playerName.substring(0, 2).toUpperCase();
                        playerAvatar.src = `https://ui-avatars.com/api/?name=${encodeURIComponent(initials)}&background=1a3a5c&color=fff&length=2&size=88&bold=true`;
                    }
                }

                // Enemy avatar - use received avatar or generate from username
                const enemyAvatar = document.getElementById('r6EnemyAvatar');
                if (enemyAvatar) {
                    // Try to get enemy's custom avatar (received via multiplayer)
                    const customEnemyAvatar = gameState.otherPlayerAvatar || null;

                    if (customEnemyAvatar) {
                        enemyAvatar.src = customEnemyAvatar;
                    } else {
                        // Fall back to generated avatar with initials
                        const enemyName = gameState.otherPlayerUsername || 'Enemy';
                        const initials = enemyName.substring(0, 2).toUpperCase();
                        enemyAvatar.src = `https://ui-avatars.com/api/?name=${encodeURIComponent(initials)}&background=5c1a1a&color=fff&length=2&size=88&bold=true`;
                    }
                }
            }

            function showR6Topbar() {
                const topbar = document.getElementById('r6Topbar');
                if (topbar) {
                    topbar.style.display = 'flex';
                }
                updateR6Avatars();
                startRoundTimer();
            }

            function hideR6Topbar() {
                const topbar = document.getElementById('r6Topbar');
                if (topbar) {
                    topbar.style.display = 'none';
                }
                stopRoundTimer();
            }

            endGame = function (playerWon) {
                console.log('🏁 Game ended:', playerWon ? 'VICTORY' : 'DEFEAT');
                gameState.started = false;
                gameState.isDying = false; // Reset death state
                gameState.deathTimer = 0;
                gameState.weaponVisible = true;

                // Stop round timer
                stopRoundTimer();

                // Hide death screen if visible
                const deathScreen = document.getElementById('deathScreen');
                if (deathScreen) {
                    deathScreen.style.opacity = 0;
                    deathScreen.style.background = 'rgba(0,0,0,0)';
                }

                // Hide killer info
                const killerInfo = document.getElementById('killerInfo');
                if (killerInfo) killerInfo.style.display = 'none';

                // Hide speaker icon
                const speakerIcon = document.getElementById('speakerIconOverlay');
                if (speakerIcon) speakerIcon.style.display = 'none';

                // Stop any active death sounds
                if (activeDeathSound && activeDeathSound.source) {
                    try {
                        activeDeathSound.source.stop();
                        activeDeathSound.source.disconnect();
                        activeDeathSound.gainNode.disconnect();
                    } catch (e) { }
                    activeDeathSound = { source: null, gainNode: null };
                }

                const gameOverDiv = document.getElementById('gameOver');
                const gameOverText = document.getElementById('gameOverText');
                const finalScore = document.getElementById('finalScore');

                // Record match end in level system
                LevelSystem.recordMatchEnd(playerWon);

                gameOverText.textContent = playerWon ? 'VICTORY!' : 'DEFEAT!';
                finalScore.textContent = `Final Score: ${gameState.playerScore} - ${gameState.enemyScore}`;
                gameOverDiv.style.display = 'block';

                // Hide level display and CS2 scoreboard when game ends
                document.getElementById('levelDisplay').style.display = 'none';
                const cs2Scoreboard = document.getElementById('cs2Scoreboard');
                if (cs2Scoreboard) cs2Scoreboard.style.display = 'none';
            }

            let isUnpausing = false;
            let pauseMenuVisible = false;
            const pauseMenu = document.getElementById('pauseMenu');

            function showPauseMenu() {
                console.log('📋 SHOWING PAUSE MENU');
                pauseMenuVisible = true;
                gameState.paused = true;
                pauseMenu.style.display = 'flex';

                // Make sure pointer lock is released
                if (document.pointerLockElement) {
                    document.exitPointerLock();
                }
            }

            function hidePauseMenu() {
                console.log('✅ HIDING PAUSE MENU');
                pauseMenuVisible = false;
                gameState.paused = false;
                pauseMenu.style.display = 'none';
            }

            let pointerLockRetryCount = 0;
            let pointerLockRetryInterval = null;

            function forcePointerLock() {
                // Only log first attempt and success
                if (pointerLockRetryCount === 0) {
                    console.log('🔒 Attempting to lock pointer...');
                }

                renderer.domElement.requestPointerLock().then(() => {
                    console.log('✅ Pointer lock acquired!');
                    pointerLockRetryCount = 0;
                    if (pointerLockRetryInterval) {
                        clearInterval(pointerLockRetryInterval);
                        pointerLockRetryInterval = null;
                    }
                }).catch(err => {
                    pointerLockRetryCount++;

                    // Keep trying for up to 5 seconds (25 attempts at 200ms intervals)
                    if (pointerLockRetryCount >= 25) {
                        console.log('❌ Pointer lock failed after max retries. Click on screen to lock.');
                        if (pointerLockRetryInterval) {
                            clearInterval(pointerLockRetryInterval);
                            pointerLockRetryInterval = null;
                        }
                        pointerLockRetryCount = 0;
                    }
                });
            }

            function resumeGame() {
                console.log('▶️ Resuming game...');
                hidePauseMenu();
                isUnpausing = true;
                pointerLockRetryCount = 0;

                // Clear any existing retry interval
                if (pointerLockRetryInterval) {
                    clearInterval(pointerLockRetryInterval);
                }

                // First attempt after small delay (browser needs time to process user gesture)
                setTimeout(() => forcePointerLock(), 100);

                // Set up retry interval - try every 200ms until success (less aggressive)
                pointerLockRetryInterval = setInterval(() => {
                    if (!document.pointerLockElement && !pauseMenuVisible) {
                        forcePointerLock();
                    } else {
                        // Success! Clear interval
                        clearInterval(pointerLockRetryInterval);
                        pointerLockRetryInterval = null;
                        pointerLockRetryCount = 0;
                    }
                }, 200);

                // Re-enter fullscreen if we were in it before (browser exits on ESC)
                if (wasInFullscreen) {
                    setTimeout(() => {
                        if (!document.fullscreenElement) {
                            toggleFullscreen();
                        }
                    }, 150);
                }

                // Clear unpause flag
                setTimeout(() => {
                    isUnpausing = false;
                    console.log('✅ Resume transition complete');
                }, 600);
            }

            // wasInFullscreen is defined in early script block

            // === POSITION SELECTOR FUNCTIONS ===
            let positionSelectorActive = false;
            let positionSelectorMode = 'ready';

            function togglePositionSelector() {
                const selector = document.getElementById('positionSelector');
                positionSelectorActive = !positionSelectorActive;
                selector.style.display = positionSelectorActive ? 'block' : 'none';

                // Exit pointer lock when opening selector to allow UI interaction
                if (positionSelectorActive && document.pointerLockElement) {
                    document.exitPointerLock();
                }
                // Re-lock pointer when closing selector (if game is running)
                else if (!positionSelectorActive && gameState.started && !gameState.paused) {
                    renderer.domElement.requestPointerLock().catch(() => {
                        console.log('Could not re-acquire pointer lock');
                    });
                }
            }

            function updatePositionDisplay() {
                const scale = parseFloat(document.getElementById('scaleNumber').value);
                const posX = parseFloat(document.getElementById('posXNumber').value);
                const posY = parseFloat(document.getElementById('posYNumber').value);
                const posZ = parseFloat(document.getElementById('posZNumber').value);
                const rotX = parseFloat(document.getElementById('rotXNumber').value);
                const rotY = parseFloat(document.getElementById('rotYNumber').value);
                const rotZ = parseFloat(document.getElementById('rotZNumber').value);

                // Update display values
                document.getElementById('scaleValue').textContent = scale.toFixed(2);
                document.getElementById('posXValue').textContent = posX.toFixed(2);
                document.getElementById('posYValue').textContent = posY.toFixed(2);
                document.getElementById('posZValue').textContent = posZ.toFixed(2);
                document.getElementById('rotXValue').textContent = rotX.toFixed(2);
                document.getElementById('rotYValue').textContent = rotY.toFixed(2);
                document.getElementById('rotZValue').textContent = rotZ.toFixed(2);

                // Apply to weapon mesh in real-time
                if (currentWeaponMesh) {
                    currentWeaponMesh.scale.set(scale, scale, scale);
                    currentWeaponMesh.position.set(posX, posY, posZ);
                    currentWeaponMesh.rotation.set(rotX, rotY, rotZ);
                }

                // Update config output
                const config = {
                    scale: parseFloat(scale.toFixed(2)),
                    position: {
                        x: parseFloat(posX.toFixed(2)),
                        y: parseFloat(posY.toFixed(2)),
                        z: parseFloat(posZ.toFixed(2))
                    },
                    rotation: {
                        x: parseFloat(rotX.toFixed(2)),
                        y: parseFloat(rotY.toFixed(2)),
                        z: parseFloat(rotZ.toFixed(2))
                    }
                };

                const configOutput = document.getElementById('configOutput');
                configOutput.textContent = JSON.stringify(config, null, 2);
            }

            function resetPositionSelector() {
                // Reset to perfect user-configured defaults
                document.getElementById('scaleNumber').value = '0.55';
                document.getElementById('scaleInput').value = '0.55';
                document.getElementById('posXNumber').value = '0.13';
                document.getElementById('posXInput').value = '0.13';
                document.getElementById('posYNumber').value = '-0.52';
                document.getElementById('posYInput').value = '-0.52';
                document.getElementById('posZNumber').value = '0.03';
                document.getElementById('posZInput').value = '0.03';
                document.getElementById('rotXNumber').value = '0';
                document.getElementById('rotXInput').value = '0';
                document.getElementById('rotYNumber').value = '3.1';
                document.getElementById('rotYInput').value = '3.1';
                document.getElementById('rotZNumber').value = '0';
                document.getElementById('rotZInput').value = '0';
                updatePositionDisplay();
            }

            function copyPositionConfig() {
                const configOutput = document.getElementById('configOutput');
                configOutput.select();
                document.execCommand('copy');

                // Visual feedback
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = '✓ COPIED!';
                btn.style.background = '#0f0';
                btn.style.color = '#000';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '#0ff';
                    btn.style.color = '#000';
                }, 1500);
            }

            // Add event listeners for all input controls
            const positionInputs = [
                'scaleInput', 'scaleNumber', 'posXInput', 'posXNumber', 'posYInput', 'posYNumber',
                'posZInput', 'posZNumber', 'rotXInput', 'rotXNumber', 'rotYInput', 'rotYNumber',
                'rotZInput', 'rotZNumber'
            ];

            positionInputs.forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input) {
                    input.addEventListener('input', (e) => {
                        // Sync slider with number input
                        const baseName = inputId.replace('Input', '').replace('Number', '');
                        const sliderInput = document.getElementById(baseName + 'Input');
                        const numberInput = document.getElementById(baseName + 'Number');

                        if (inputId.includes('Input')) {
                            numberInput.value = sliderInput.value;
                        } else {
                            sliderInput.value = numberInput.value;
                        }

                        updatePositionDisplay();
                    });
                }
            });

            // Keyboard shortcut: Press 'W' to toggle position selector
            document.addEventListener('keydown', (e) => {
                if (e.code === 'KeyW' && e.ctrlKey && e.shiftKey) {
                    e.preventDefault();
                    togglePositionSelector();
                }
            });

            function togglePause() {
                console.log('=== TOGGLE PAUSE CALLED (ESC KEY) ===');
                console.log('Current paused state:', gameState.paused);
                console.log('Pause menu visible:', pauseMenuVisible);
                console.log('Current pointer lock:', document.pointerLockElement);

                // ESC only pauses, never resumes
                if (!pauseMenuVisible) {
                    // Currently playing, pause
                    console.log('🎮 ESC pressed while playing - PAUSING');
                    showPauseMenu();
                } else {
                    // Already paused, ESC does nothing
                    console.log('⚠️ ESC pressed while paused - IGNORED (use Resume button)');
                }

                console.log('=========================');
            }

            // Pause menu button handlers
            document.getElementById('resumeButton').addEventListener('click', () => {
                console.log('🖱️ Resume button clicked');
                if (pauseMenuVisible) {
                    resumeGame();
                }
            });

            // Fullscreen functionality via F key (pause menu button removed)
            // Listen for fullscreen changes
            document.addEventListener('fullscreenchange', () => {
                const isFullscreen = document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
                if (isFullscreen) {
                    wasInFullscreen = true;
                }
            });
            document.addEventListener('webkitfullscreenchange', () => {
                const isFullscreen = document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
                if (isFullscreen) {
                    wasInFullscreen = true;
                }
            });
            document.addEventListener('msfullscreenchange', () => {
                const isFullscreen = document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
                if (isFullscreen) {
                    wasInFullscreen = true;
                }
            });

            document.getElementById('exitToMenuButton').addEventListener('click', () => {
                console.log('🖱️ Exit to menu button clicked');
                location.reload();
            });

            // PERF: Pre-allocated vectors for slide calculation
            const _slideForward = new THREE.Vector3();
            const _slideRight = new THREE.Vector3();
            const _slideDir = new THREE.Vector3();
            const _slideUpVec = new THREE.Vector3(0, 1, 0);
            
            // COD/Apex-style Slide Function - Smooth and Responsive
            function startSlide() {
                if (!gameState.onGround || gameState.isSliding || gameState.slideCooldown > 0) return;

                // Get current movement direction - PERF: Reuse vectors
                camera.getWorldDirection(_slideForward);
                _slideForward.y = 0;
                _slideForward.normalize();
                _slideRight.crossVectors(_slideForward, _slideUpVec).normalize();

                // Calculate slide direction based on current input
                _slideDir.set(0, 0, 0);
                if (moveForward) _slideDir.add(_slideForward);
                if (moveBackward) _slideDir.sub(_slideForward);
                if (moveRight) _slideDir.add(_slideRight);
                if (moveLeft) _slideDir.sub(_slideRight);

                // If no input, slide forward by default
                if (_slideDir.length() === 0) {
                    _slideDir.copy(_slideForward);
                }

                _slideDir.normalize();
                gameState.slideDirection.copy(_slideDir);
                gameState.isSliding = true;
                gameState.slideTimer = 0;
                gameState.slideStartHeight = camera.position.y;
                gameState.targetSlideHeight = 0.5;
                gameState.slideCameraTilt = 0;
                gameState.slideHeadBob = 0;

                // Store initial momentum - sprinting gives a speed boost
                // More realistic: momentum builds from current speed
                const sprintBonus = gameState.isSprinting ? 1.5 : 1.0;
                const momentumBonus = Math.max(gameState.movementSpeed, 0.6);
                gameState.slideVelocity = gameState.slideSpeed * sprintBonus * momentumBonus;
                gameState.preSlideMomentum = gameState.movementSpeed;

                // Initial camera drop impulse for impact feel
                gameState.velocityY = -2;

                // Play slide sound
                playSlideSound();
            }

            // Enhanced Movement Update with smooth animations
            function updateMovement(deltaTime) {
                if (!gameState.started || gameState.paused) return;


                // --- Slide Cooldown ---
                if (gameState.slideCooldown > 0) {
                    gameState.slideCooldown -= deltaTime;
                }

                // --- Sliding Mechanic (Smooth COD/Apex Style) ---
                if (gameState.isSliding) {
                    gameState.slideTimer += deltaTime;
                    const slideProgress = gameState.slideTimer / gameState.slideDuration;

                    // Smooth deceleration - not too much friction
                    const friction = 0.985; // Gentler friction

                    // Apply friction to velocity each frame
                    gameState.slideVelocity *= Math.pow(friction, deltaTime * 60);

                    const currentSpeed = gameState.slideVelocity;

                    // End slide based on time only - smooth transition
                    if (slideProgress >= 1.0) {
                        // Smooth transition out of slide - keep moving!
                        gameState.isSliding = false;
                        gameState.slideCooldown = 0.2;
                        gameState.isRecoveringFromSlide = true;
                        gameState.slideRecoveryTimer = 0;
                        gameState.slideRecoveryStartHeight = camera.position.y;
                        // Keep high momentum so player continues running smoothly
                        gameState.movementSpeed = 1.0;
                        gameState.preSlideMomentum = 1.0;
                        gameState.isSprinting = true; // Auto-sprint out of slide
                    } else {
                        // Apply slide movement - PERF: reuse vectors
                        _reusableVec3A.copy(gameState.slideDirection);
                        _reusableVec3A.normalize().multiplyScalar(currentSpeed * deltaTime);

                        _reusableVec3B.copy(camera.position).add(_reusableVec3A);
                        const collision = checkCollision(_reusableVec3B);

                        if (!collision) {
                            camera.position.copy(_reusableVec3B);
                        } else {
                            // Hit wall - end slide
                            gameState.isSliding = false;
                            gameState.slideCooldown = 0.15;
                            gameState.isRecoveringFromSlide = true;
                            gameState.slideRecoveryTimer = 0;
                            gameState.slideRecoveryStartHeight = camera.position.y;
                            gameState.movementSpeed = 0.5;
                        }

                        // Smooth camera drop
                        const dropProgress = Math.min(gameState.slideTimer * 8, 1.0);
                        const dropEase = 1 - Math.pow(1 - dropProgress, 3);
                        const heightDiff = gameState.slideStartHeight - gameState.targetSlideHeight;
                        const targetY = gameState.slideStartHeight - heightDiff * dropEase;
                        camera.position.y = lerp(camera.position.y, targetY, deltaTime * 20);

                        // Camera tilt
                        euler.setFromQuaternion(camera.quaternion);
                        const speedRatio = currentSpeed / gameState.slideSpeed;
                        const targetTilt = 0.1 * Math.min(speedRatio, 1);
                        gameState.slideCameraTilt = lerp(gameState.slideCameraTilt, targetTilt, deltaTime * 8);
                        euler.z = gameState.slideCameraTilt;
                        camera.quaternion.setFromEuler(euler);

                        // FOV increase
                        const targetFov = 75 + (12 * Math.min(speedRatio, 1));
                        camera.fov = lerp(camera.fov, targetFov, deltaTime * 10);
                        camera.updateProjectionMatrix();

                        return; // Skip normal movement during slide
                    }
                }

                // --- Slide Recovery (ULTRA REALISTIC stand up animation) ---
                if (gameState.isRecoveringFromSlide) {
                    gameState.slideRecoveryTimer += deltaTime;
                    const recoveryDuration = 0.45; // 450ms - quick but realistic
                    const t = Math.min(gameState.slideRecoveryTimer / recoveryDuration, 1.0);

                    const targetHeight = gameState.baseHeight;
                    const startHeight = gameState.slideRecoveryStartHeight;
                    const heightDiff = targetHeight - startHeight;

                    // PHASE-BASED REALISTIC STAND UP
                    // Mimics actual human biomechanics when rising from a slide

                    let heightProgress;
                    let cameraPitch; // Forward/back head tilt
                    let cameraRoll;  // Side tilt
                    let fovAdjust;
                    let bobOffset = 0;

                    if (t < 0.15) {
                        // PHASE 1: Initial push (0-15%) - Gather momentum, slight dip
                        const phase = t / 0.15;
                        heightProgress = -0.02 * Math.sin(phase * Math.PI); // Tiny dip before rising
                        cameraPitch = 0.04 * phase; // Head tilts forward (looking at ground)
                        cameraRoll = gameState.slideCameraTilt * (1 - phase * 0.3);
                        fovAdjust = 2;

                    } else if (t < 0.5) {
                        // PHASE 2: Main rise (15-50%) - Fast upward motion with forward lean
                        const phase = (t - 0.15) / 0.35;
                        const riseEase = 1 - Math.pow(1 - phase, 2.5); // Fast ease-out
                        heightProgress = riseEase * 0.75;
                        cameraPitch = 0.04 * (1 - phase * 0.5); // Gradually straighten
                        cameraRoll = gameState.slideCameraTilt * (0.7 - phase * 0.6);
                        fovAdjust = 2 - phase * 3;
                        // Slight bob from legs pushing up
                        bobOffset = Math.sin(phase * Math.PI) * 0.03;

                    } else if (t < 0.75) {
                        // PHASE 3: Overshoot & correct (50-75%) - Momentum carries slightly past
                        const phase = (t - 0.5) / 0.25;
                        const overshootAmount = 0.04;
                        heightProgress = 0.75 + phase * 0.25 + Math.sin(phase * Math.PI) * overshootAmount;
                        cameraPitch = 0.02 * (1 - phase); // Almost level
                        cameraRoll = gameState.slideCameraTilt * (0.1 - phase * 0.1);
                        fovAdjust = -1 + phase * 0.5;
                        // Upper body sway
                        bobOffset = Math.sin(phase * Math.PI * 1.5) * 0.015;

                    } else {
                        // PHASE 4: Stabilize (75-100%) - Settle into standing position
                        const phase = (t - 0.75) / 0.25;
                        const settleEase = 1 - Math.pow(1 - phase, 3);
                        // Slight oscillation as body finds balance
                        const settle = Math.cos(phase * Math.PI * 2) * (1 - phase) * 0.01;
                        heightProgress = 1.0 + settle;
                        cameraPitch = -0.01 * (1 - settleEase); // Tiny head raise
                        cameraRoll = 0;
                        fovAdjust = -0.5 * (1 - settleEase);
                        bobOffset = settle;
                    }

                    // Apply camera height
                    camera.position.y = startHeight + heightDiff * Math.max(0, heightProgress) + bobOffset;

                    // Apply camera rotation
                    euler.setFromQuaternion(camera.quaternion);
                    euler.x = lerp(euler.x, cameraPitch, deltaTime * 15);
                    euler.z = lerp(euler.z, cameraRoll, deltaTime * 12);
                    camera.quaternion.setFromEuler(euler);

                    // Apply FOV
                    camera.fov = lerp(camera.fov, 75 + fovAdjust, deltaTime * 15);
                    camera.updateProjectionMatrix();

                    if (t >= 1.0) {
                        gameState.isRecoveringFromSlide = false;
                        camera.position.y = targetHeight;
                        euler.z = 0;
                        euler.x = 0;
                        camera.quaternion.setFromEuler(euler);
                        gameState.slideCameraTilt = 0;
                    }

                    // Keep momentum - seamless transition to running
                    gameState.movementSpeed = Math.max(gameState.movementSpeed, 0.9);
                }


                gameState.lean = lerp(gameState.lean, gameState.leanTarget, deltaTime * 10);
                const baseSpeed = gameState.isSprinting ? 12 : 8;
                const targetFov = gameState.isSprinting ? 85 : 75;
                camera.fov = lerp(camera.fov, targetFov, deltaTime * 8);
                camera.updateProjectionMatrix();

                // PERF: Reuse pre-allocated vectors instead of creating new ones
                const forward = _reusableVec3A;
                const right = _reusableVec3B;
                camera.getWorldDirection(forward);
                forward.y = 0;
                forward.normalize();
                right.crossVectors(forward, _reusableVec3C.set(0, 1, 0)).normalize();

                const moveDirection = _reusableVec3D.set(0, 0, 0);
                if (moveForward) moveDirection.add(forward);
                if (moveBackward) moveDirection.sub(forward);
                if (moveRight) moveDirection.add(right);
                if (moveLeft) moveDirection.sub(right);

                gameState.wasMoving = gameState.isMoving;
                gameState.isMoving = moveDirection.length() > 0;

                if (gameState.isMoving) {
                    gameState.targetMovementSpeed = 1.0;
                } else {
                    gameState.targetMovementSpeed = 0.0;
                }

                const speedLerpSpeed = gameState.isMoving ? 8 : 12;
                gameState.movementSpeed = lerp(gameState.movementSpeed, gameState.targetMovementSpeed, deltaTime * speedLerpSpeed);

                // Update particle systems
                updateFootstepDust(deltaTime);

                // Spawn footstep dust while moving
                if (gameState.isMoving && !gameState.jumpVelocity && camera.position.y < 3.0) { // Moving on ground
                    if (!gameState.walkDustTimer) gameState.walkDustTimer = 0;
                    gameState.walkDustTimer += deltaTime;

                    const stepInterval = gameState.isSprinting ? 0.25 : 0.4; // Faster steps when sprinting

                    if (gameState.walkDustTimer > stepInterval) {
                        gameState.walkDustTimer = 0;

                        // Spawn dust slightly behind player - PERF: reuse vectors
                        _reusableVec3C.copy(camera.position);
                        _reusableVec3C.y = 0.2; // Ground level
                        // Offset behind movement direction
                        _reusableVec3D.copy(moveDirection).normalize().negate();
                        _reusableVec3C.add(_reusableVec3D.multiplyScalar(0.5));

                        createFootstepDust(_reusableVec3C);
                    }
                }
                if (gameState.isMoving) {
                    moveDirection.normalize();
                    const actualSpeed = baseSpeed * gameState.movementSpeed * deltaTime;
                    // PERF: reuse vectors for collision checking
                    _reusableVec3A.copy(camera.position);
                    _reusableVec3A.add(moveDirection.multiplyScalar(actualSpeed));
                    const collision = checkCollision(_reusableVec3A);

                    if (!collision) {
                        camera.position.copy(_reusableVec3A);
                    } else {
                        // Try X-only movement
                        _reusableVec3B.copy(camera.position);
                        _reusableVec3B.x = _reusableVec3A.x;
                        if (!checkCollision(_reusableVec3B)) {
                            camera.position.x = _reusableVec3A.x;
                        }
                        // Try Z-only movement
                        _reusableVec3C.copy(camera.position);
                        _reusableVec3C.z = _reusableVec3A.z;
                        if (!checkCollision(_reusableVec3C)) {
                            camera.position.z = _reusableVec3A.z;
                        }
                    }
                }

                if (gameState.onGround && spacePressed) {
                    gameState.velocityY = 8;
                    gameState.onGround = false;
                    gameState.isJumping = true; // Mark as jumping for animation
                }

                if (!gameState.onGround) {
                    gameState.velocityY -= 20 * deltaTime;
                } else {
                    // Landed - no longer jumping
                    gameState.isJumping = false;
                }

                camera.position.y += gameState.velocityY * deltaTime;

                let verticalBob = 0;
                if (gameState.isMoving && gameState.onGround) {
                    const sprintMultiplier = gameState.isSprinting ? 1.5 : 1;
                    gameState.headBobPhase += deltaTime * 10 * gameState.movementSpeed * sprintMultiplier;
                    verticalBob = Math.sin(gameState.headBobPhase) * 0.06 * gameState.movementSpeed;
                } else {
                    gameState.headBobPhase = lerp(gameState.headBobPhase, 0, deltaTime * 5);
                }

                // Update dynamic crosshair
                if (typeof updateCrosshair === 'function') {
                    updateCrosshair();
                }

                // Update Kinetic Blend Motion System
                if (typeof updateKineticBlend === 'function') {
                    updateKineticBlend(deltaTime);
                }

                // Update 3D HUD Tilt
                if (typeof updateHUDTilt === 'function') {
                    updateHUDTilt();
                }

                // Dynamic ground height for OBJ maps (stairs, ramps, etc.)
                let currentGroundHeight = 0;
                if (objCollisionMeshes.length > 0) {
                    currentGroundHeight = getGroundHeight(camera.position);
                }
                const effectiveBaseHeight = gameState.baseHeight + currentGroundHeight;

                // Get kinetic blend offset (smooth bobbing from preview)
                const kineticY = (typeof kineticState !== 'undefined') ? kineticState.posOffsetY : 0;

                // Don't clamp camera Y during slide recovery - let the stand-up animation play
                if (!gameState.isRecoveringFromSlide) {
                    if (camera.position.y <= effectiveBaseHeight + verticalBob + kineticY) {
                        camera.position.y = effectiveBaseHeight + verticalBob + kineticY;
                        gameState.onGround = true;
                        gameState.velocityY = 0;
                    } else {
                        gameState.onGround = false;
                    }
                } else {
                    // During recovery, still consider on ground but don't force height
                    gameState.onGround = true;
                    gameState.velocityY = 0;
                }

                if (gameState.isMoving && gameState.onGround) {
                    const sprintMultiplier = gameState.isSprinting ? 1.5 : 1;
                    if (gameState.movementSpeed > 0.1) {
                        // Add VERY SUBTLE kinetic blend rotation (from preview)
                        const kineticRotZ = (typeof kineticState !== 'undefined') ? kineticState.rotOffsetZ : 0;
                        const kineticRotX = (typeof kineticState !== 'undefined') ? kineticState.rotOffsetX : 0;

                        euler.setFromQuaternion(camera.quaternion);
                        euler.z = lerp(euler.z, gameState.lean * 0.3 + kineticRotZ, deltaTime * 8);
                        // Subtle pitch dip on footsteps (from preview)
                        euler.x += kineticRotX * deltaTime * 10;
                        camera.quaternion.setFromEuler(euler);
                    } else {
                        euler.setFromQuaternion(camera.quaternion);
                        euler.z = lerp(euler.z, gameState.lean * 0.3, deltaTime * 8);
                        camera.quaternion.setFromEuler(euler);
                    }

                    if (!gameState.wasMoving && gameState.movementSpeed < 0.1) {
                        gameState.landingTimer = 0.2;
                        // No camera shake
                    }
                } else {
                    gameState.headBobPhase = lerp(gameState.headBobPhase, 0, deltaTime * 5);

                    // NO screen tilt during reload - only lean
                    euler.setFromQuaternion(camera.quaternion);
                    euler.z = lerp(euler.z, gameState.lean * 0.3, deltaTime * 8);
                    camera.quaternion.setFromEuler(euler);

                    if (gameState.wasMoving && gameState.movementSpeed > 0.5) {
                        gameState.landingTimer = 0.15;
                        // No camera shake
                    }
                }

                if (gameState.landingTimer > 0) {
                    gameState.landingTimer -= deltaTime;
                    if (gameState.landingTimer < 0) gameState.landingTimer = 0;
                }

                updateWeaponPosition(deltaTime);
                camera.position.x = Math.max(-28, Math.min(28, camera.position.x));
                camera.position.z = Math.max(-28, Math.min(28, camera.position.z));
            }

            // PERF: Pre-allocated reusable objects to avoid GC spikes
            _reusableVec3A = new THREE.Vector3();
            _reusableVec3B = new THREE.Vector3();
            _reusableVec3C = new THREE.Vector3();
            _reusableVec3D = new THREE.Vector3();
            _reusableVec3E = new THREE.Vector3();
            _reusableVec3F = new THREE.Vector3();
            _reusableEuler = new THREE.Euler();
            _reusableQuaternion = new THREE.Quaternion();
            _reusableRaycaster = new THREE.Raycaster();
            _reusableVec2Zero = new THREE.Vector2(0, 0);
            let _shadowUpdateCounter = 0;
            const SHADOW_UPDATE_INTERVAL = 30; // Update shadows every 30 frames
            
            // PERF: DOF raycast throttling - only run every 3rd frame
            let _dofUpdateCounter = 0;
            let _dofTargetDistance = 15; // Default focus distance
            
            // PERF: Pre-allocated objects for shoot() function - prevents GC stutter on each shot
            _shootRaycaster = new THREE.Raycaster();
            _shootVec2Center = new THREE.Vector2(0, 0);
            _shootBulletStart = new THREE.Vector3();
            _shootBulletEnd = new THREE.Vector3();
            _shootDirection = new THREE.Vector3();
            _shootHitNormal = new THREE.Vector3(0, 1, 0);
            _shootObjectsToIntersect = [];

            // PERF: Pre-allocated objects for multiplayer near-miss ("whiz") detection
            _whizSeg = new THREE.Vector3();
            _whizToPoint = new THREE.Vector3();
            _whizClosestPoint = new THREE.Vector3();
            _whizTargetPos = new THREE.Vector3();
            _whizHeadPos = new THREE.Vector3();
            _whizLastSentAtByTarget = new Map();
            
            // PERF: Pre-allocated objects for smoke trail creation - CRITICAL for shooting performance
            _smokeCamDirTrail = new THREE.Vector3();
            _smokeCamRightTrail = new THREE.Vector3();
            _smokeMuzzleStart = new THREE.Vector3();
            _smokeVec = new THREE.Vector3();
            _smokeDirection = new THREE.Vector3();
            _smokePerpUp = new THREE.Vector3();
            _smokeRight = new THREE.Vector3();
            _smokeUpVec = new THREE.Vector3(0, 1, 0);
            
            // PERF: Pre-allocated objects for tracer creation
            _tracerDirection = new THREE.Vector3();
            _tracerMidPoint = new THREE.Vector3();

            // PERF: Reusable objects for XP orb updates
            _xpToPlayer = new THREE.Vector3();

            // PERF: Reusable objects for death-cam tracking (avoids per-frame allocations)
            _deathKillerPos = new THREE.Vector3();
            _deathLookAtMat = new THREE.Matrix4();
            _deathTargetQuat = new THREE.Quaternion();
            _deathGlowColor = new THREE.Color(0xff4444);

            // PERF: Reusable arrays/vectors for smoke trail point generation
            _smokePoints = [];
            _smokePointVecs = [];
            
            // PERF: Pre-allocated network position data object - avoids creating new object every 33ms
            _netPositionData = {
                type: 'position',
                x: 0, y: 0, z: 0,
                rx: 0, ry: 0, rz: 0,
                anim: {
                    vx: 0, vz: 0,
                    crouch: false,
                    sprint: false,
                    jump: false,
                    jumpPhase: null,
                    aim: false
                }
            };
            // PERF: Pre-stringify the unchanging parts once
            _netPositionPrefix = null; // Will be set after first use
            
            // PERF: Frame budget system for particle cleanup - prevents all particles being cleaned in one frame
            let _particleCleanupIndex = 0;
            const PARTICLE_CLEANUP_BATCH_SIZE = 10; // Only clean up 10 particles per frame max

            // ==================== STUTTER DEBUGGER / PROFILER ====================
            // Advanced always-available profiler that is effectively zero-cost when disabled.
            // Toggle: F8 (on/off). Export report: F9.
            const StutterDebug = (() => {
                const state = {
                    enabled: false,
                    thresholdMs: 28,
                    maxFrames: 240,
                    maxSpikes: 50,
                    frameIndex: 0,
                    lastOverlayUpdate: 0,
                    overlayHz: 5,
                    frameBeginTs: 0,
                    sections: Object.create(null),
                    sectionStarts: Object.create(null),
                    lastFrameMs: 0,
                    frames: [],
                    spikes: [],
                    events: [],
                    longTasks: [],
                    longTaskObserver: null,
                    ui: null
                };

                const SECTION_NAMES = [
                    'weaponAnims', 'crosshair',
                    'particles', 'bulletSmoke', 'footsteps', 'dustSpawn',
                    'blood', 'combat', 'adrenaline', 'xpOrbs',
                    'deathCam', 'movement', 'enemy', 'cameraShake',
                    'multiplayer', 'audio', 'netSend',
                    'dofFocus', 'shadows',
                    'renderMain', 'renderDepth', 'renderPost', 'renderDirect', 'renderWeapon',
                    'telemetry'
                ];

                function now() { return performance.now(); }

                function ensureUI() {
                    if (state.ui) return state.ui;
                    const root = document.createElement('div');
                    root.id = 'stutter-debug-overlay';
                    root.style.cssText = [
                        'position:fixed',
                        'top:10px',
                        'left:10px',
                        'z-index:999999',
                        'font:12px/1.25 monospace',
                        'color:#fff',
                        'background:rgba(0,0,0,0.65)',
                        'padding:8px 10px',
                        'border-radius:6px',
                        'pointer-events:none',
                        'white-space:pre',
                        'display:none',
                        'max-width:460px'
                    ].join(';');
                    document.body.appendChild(root);
                    state.ui = root;
                    return root;
                }

                function formatTopSections(sectionTotals) {
                    const entries = [];
                    for (let i = 0; i < SECTION_NAMES.length; i++) {
                        const k = SECTION_NAMES[i];
                        const v = sectionTotals[k] || 0;
                        if (v > 0.05) entries.push([k, v]);
                    }
                    entries.sort((a, b) => b[1] - a[1]);
                    const top = entries.slice(0, 6);
                    let out = '';
                    for (let i = 0; i < top.length; i++) {
                        out += `${top[i][0].padEnd(12)} ${top[i][1].toFixed(2).padStart(7)} ms\n`;
                    }
                    return out || 'no section samples\n';
                }

                function pushRing(arr, item, max) {
                    arr.push(item);
                    if (arr.length > max) arr.shift();
                }

                function snapshotCounters() {
                    // Avoid heavy reads unless we're already in a spike.
                    const info = renderer && renderer.info ? renderer.info : null;
                    return {
                        particles: activeParticles ? activeParticles.length : 0,
                        tracers: activeTracers ? activeTracers.length : 0,
                        casings: activeCasings ? activeCasings.length : 0,
                        bloodDrips: bloodDrips ? bloodDrips.length : 0,
                        bloodPools: permanentBloodPools ? permanentBloodPools.length : 0,
                        bulletHoles: bulletHoles ? bulletHoles.length : 0,
                        calls: info ? info.render.calls : 0,
                        tris: info ? info.render.triangles : 0,
                        geoms: info ? info.memory.geometries : 0,
                        tex: info ? info.memory.textures : 0
                    };
                }

                function frameBegin(ts) {
                    state.frameBeginTs = ts;
                    state.frameIndex++;
                    // reset per-frame totals
                    const totals = state.sections;
                    for (let i = 0; i < SECTION_NAMES.length; i++) totals[SECTION_NAMES[i]] = 0;
                }

                function start(name) {
                    state.sectionStarts[name] = now();
                }

                function end(name) {
                    const st = state.sectionStarts[name];
                    if (st === undefined) return;
                    const dt = now() - st;
                    state.sections[name] = (state.sections[name] || 0) + dt;
                    state.sectionStarts[name] = undefined;
                }

                function recordEvent(name, data) {
                    // data can include e.g. { ms: 12.3, extra: ... }
                    if (data && typeof data === 'object') {
                        pushRing(state.events, { t: now(), f: state.frameIndex, name, ...data }, 200);
                    } else {
                        pushRing(state.events, { t: now(), f: state.frameIndex, name }, 200);
                    }
                }

                function startLongTaskObserver() {
                    if (!('PerformanceObserver' in window)) return;
                    try {
                        if (state.longTaskObserver) return;
                        const obs = new PerformanceObserver((list) => {
                            const entries = list.getEntries();
                            for (let i = 0; i < entries.length; i++) {
                                const e = entries[i];
                                // Long tasks are usually GC, layout, or main-thread stalls.
                                pushRing(state.longTasks, {
                                    startTime: e.startTime,
                                    duration: e.duration
                                }, 100);
                            }
                        });
                        obs.observe({ entryTypes: ['longtask'] });
                        state.longTaskObserver = obs;
                    } catch {
                        // ignore
                    }
                }

                function stopLongTaskObserver() {
                    if (state.longTaskObserver) {
                        try { state.longTaskObserver.disconnect(); } catch {}
                        state.longTaskObserver = null;
                    }
                }

                function maybeUpdateOverlay(ts) {
                    const ui = ensureUI();
                    const minInterval = 1000 / state.overlayHz;
                    if (ts - state.lastOverlayUpdate < minInterval) return;
                    state.lastOverlayUpdate = ts;

                    const approxFps = state.lastFrameMs > 0 ? (1000 / state.lastFrameMs) : 0;
                    const lastSpike = state.spikes.length ? state.spikes[state.spikes.length - 1] : null;
                    const counters = lastSpike ? lastSpike.counters : null;

                    let text = '';
                    text += `STUTTER DEBUG  (${state.enabled ? 'ON' : 'OFF'})  threshold=${state.thresholdMs.toFixed(1)}ms\n`;
                    text += `frame=${state.frameIndex}  last=${state.lastFrameMs.toFixed(2)}ms  ~${approxFps.toFixed(0)} fps\n`;
                    text += `top sections (last frame):\n`;
                    text += formatTopSections(state.sections);

                    if (lastSpike) {
                        text += `\nLAST SPIKE: ${lastSpike.frameMs.toFixed(2)}ms @ f=${lastSpike.frameIndex}\n`;
                        text += formatTopSections(lastSpike.sections);
                        if (counters) {
                            text += `counts: P=${counters.particles} T=${counters.tracers} C=${counters.casings} `;
                            text += `BD=${counters.bloodDrips} BP=${counters.bloodPools} BH=${counters.bulletHoles}\n`;
                            text += `gpu-ish: calls=${counters.calls} tris=${counters.tris} geoms=${counters.geoms} tex=${counters.tex}\n`;
                        }
                        if (state.longTasks.length) {
                            const lt = state.longTasks[state.longTasks.length - 1];
                            text += `longtask(last): ${lt.duration.toFixed(2)}ms\n`;
                        }
                    } else {
                        text += `\nLAST SPIKE: (none yet)\n`;
                    }

                    ui.textContent = text;
                }

                function frameEnd(frameMs, deltaTime) {
                    state.lastFrameMs = frameMs;

                    // Keep a rolling window of frames (for post-mortem)
                    pushRing(state.frames, {
                        t: now(),
                        frameIndex: state.frameIndex,
                        frameMs,
                        deltaTime,
                        sections: { ...state.sections }
                    }, state.maxFrames);

                    if (frameMs >= state.thresholdMs) {
                        const spike = {
                            t: now(),
                            frameIndex: state.frameIndex,
                            frameMs,
                            deltaTime,
                            sections: { ...state.sections },
                            counters: snapshotCounters(),
                            events: state.events.slice(-20),
                            longTasks: state.longTasks.slice(-10)
                        };
                        pushRing(state.spikes, spike, state.maxSpikes);
                    }

                    maybeUpdateOverlay(now());
                }

                function clear() {
                    state.frames.length = 0;
                    state.spikes.length = 0;
                    state.events.length = 0;
                    state.longTasks.length = 0;
                }

                function exportReport() {
                    const report = {
                        generatedAt: new Date().toISOString(),
                        thresholdMs: state.thresholdMs,
                        frames: state.frames,
                        spikes: state.spikes,
                        longTasks: state.longTasks
                    };

                    const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `stutter-report-${Date.now()}.json`;
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                    setTimeout(() => URL.revokeObjectURL(url), 1000);
                }

                function enable(on) {
                    state.enabled = !!on;
                    const ui = ensureUI();
                    ui.style.display = state.enabled ? 'block' : 'none';
                    if (state.enabled) startLongTaskObserver();
                    else stopLongTaskObserver();
                }

                function toggle() { enable(!state.enabled); }
                function setThresholdMs(ms) { state.thresholdMs = Math.max(1, +ms || 28); }

                return {
                    state,
                    enable,
                    toggle,
                    clear,
                    export: exportReport,
                    setThresholdMs,
                    frameBegin,
                    frameEnd,
                    start,
                    end,
                    event: recordEvent
                };
            })();

            window.StutterDebug = StutterDebug;
            window.exportStutterDebug = () => StutterDebug.export();
            window.setStutterDebugEnabled = (on) => setStutterDebugEnabled(on);

            // PERF: swap-in no-op wrappers when disabled
            let dbgFrameBegin = function () { };
            let dbgFrameEnd = function () { };
            let dbgStart = function () { };
            let dbgEnd = function () { };
            let stutterEvent = function () { };

            function setStutterDebugEnabled(on) {
                StutterDebug.enable(!!on);
                if (StutterDebug.state.enabled) {
                    dbgFrameBegin = (ts) => StutterDebug.frameBegin(ts);
                    dbgFrameEnd = (frameMs, dt) => StutterDebug.frameEnd(frameMs, dt);
                    dbgStart = (name) => StutterDebug.start(name);
                    dbgEnd = (name) => StutterDebug.end(name);
                    stutterEvent = (name, data) => StutterDebug.event(name, data);
                } else {
                    dbgFrameBegin = function () { };
                    dbgFrameEnd = function () { };
                    dbgStart = function () { };
                    dbgEnd = function () { };
                    stutterEvent = function () { };
                }
            }

            // Hotkeys: F8 toggle, F9 export
            window.addEventListener('keydown', (e) => {
                if (e.code === 'F8') {
                    setStutterDebugEnabled(!StutterDebug.state.enabled);
                } else if (e.code === 'F9') {
                    if (!StutterDebug.state.enabled) setStutterDebugEnabled(true);
                    StutterDebug.export();
                } else if (e.code === 'KeyH' && gameState.started && !gameState.paused) {
                    aiHitPlayer();
                }
            }, { passive: true });

            // Animation Loop
            let lastTime = performance.now();

            animate = function () {
                requestAnimationFrame(animate);

                const currentTime = performance.now();
                const deltaTime = (currentTime - lastTime) / 1000;

                // FPS Limiting (do this BEFORE heavy work)
                if (fpsLimit > 0) {
                    const targetFrameTime = 1000 / fpsLimit;
                    const timeSinceLastFrame = currentTime - lastFrameTime;

                    if (timeSinceLastFrame < targetFrameTime) {
                        return; // Skip this frame entirely
                    }
                    lastFrameTime = currentTime;
                }

                dbgFrameBegin(currentTime);

                // Update weapon animations
                dbgStart('weaponAnims');
                updateWeaponAnimations();
                dbgEnd('weaponAnims');

                // Update dynamic crosshair position
                dbgStart('crosshair');
                updateCrosshair();
                dbgEnd('crosshair');

                // Update 10x gameplay enhancement systems
                dbgStart('particles');
                updateParticles(deltaTime);
                dbgEnd('particles');

                dbgStart('bulletSmoke');
                updateBulletSmokeParticles(deltaTime); // Realistic bullet smoke trails
                dbgEnd('bulletSmoke');

                dbgStart('footsteps');
                updateFootsteps(deltaTime);
                dbgEnd('footsteps');

                dbgStart('dustSpawn');
                createDustParticle(); // Spawn dust while moving
                dbgEnd('dustSpawn');

                // Update unique features
                dbgStart('blood');
                updateBloodDrips(deltaTime);
                dbgEnd('blood');

                dbgStart('combat');
                updateCombatIntensity(deltaTime);
                dbgEnd('combat');

                dbgStart('adrenaline');
                updateAdrenaline(deltaTime);
                dbgEnd('adrenaline');

                // ========== UNCHARTED 3 NEAR-DEATH EFFECT UPDATE ==========
                dbgStart('trauma');
                {
                    // Calculate trauma target based on health (100 health = 0 trauma, 0 health = 1 trauma)
                    gameState.traumaTarget = (100 - Math.max(0, gameState.playerHealth)) / 100;
                    
                    // Smooth interpolation toward target trauma
                    gameState.trauma += (gameState.traumaTarget - gameState.trauma) * 2.5 * deltaTime;
                    gameState.trauma = Math.max(0, Math.min(1, gameState.trauma)); // Clamp 0-1
                    
                    // Health regeneration after delay (like Uncharted)
                    if (gameState.healingDelay > 0) {
                        gameState.healingDelay -= deltaTime;
                    } else if (gameState.playerHealth < 100 && !gameState.isDying) {
                        // Slow health regeneration
                        gameState.playerHealth += 15 * deltaTime; // ~6.5 seconds to full heal
                        gameState.playerHealth = Math.min(100, gameState.playerHealth);
                        updateHUD();
                    }
                    
                    // Update shader uniforms
                    if (postProcessMaterial && postProcessMaterial.uniforms) {
                        postProcessMaterial.uniforms.uTrauma.value = gameState.trauma;
                        postProcessMaterial.uniforms.uTime.value = currentTime * 0.001; // Convert to seconds
                    }
                    
                    // Update trauma audio (shell shock / numb sound effect)
                    updateTraumaAudio(deltaTime);
                    
                    // Update fog density based on trauma (slight visibility reduction when hurt)
                    // DO NOT change fog color - the shader handles the visual desaturation
                    if (scene && scene.fog) {
                        // Only reduce fog distance slightly when hurt (tunnel vision)
                        scene.fog.far = THREE.MathUtils.lerp(150, 100, gameState.trauma * 0.5);
                    }
                }
                dbgEnd('trauma');

                // Update BF1-style hit feed HUD
                if (window.bf1Hud) {
                    bf1Hud.update();
                }

                // Update enemy nametag visibility (COD-style - shows when aiming)
                if (enemy && enemy.usernameSprite && !isMultiplayer) {
                    updateEnemyNametagVisibility(camera, enemy, deltaTime);
                }

                // === TELEMETRY SYSTEM UPDATE ===
                dbgStart('telemetry');
                updateTelemetrySystem(currentTime, renderer, camera);
                dbgEnd('telemetry');

                lastTime = currentTime;

                // Update XP orbs (Minecraft-style pickup system)
                dbgStart('xpOrbs');
                updateXPOrbs(deltaTime);
                dbgEnd('xpOrbs');

                if (gameState.isDying) {
                    dbgStart('deathCam');
                    gameState.deathTimer += deltaTime;
                    const deathProgress = Math.min(gameState.deathTimer / 3.0, 1); // 3 second death cam

                    // === CORPSE TRACKING CAMERA ===
                    // Lock camera to corpse position
                    camera.position.copy(gameState.deathPosition);

                    // Get killer's current REAL-TIME position (updates every frame)
                    const killerPos = _deathKillerPos;
                    let killerFound = false;

                    // Check for AI enemy
                    if (enemy && enemy.visible && !isMultiplayer) {
                        killerPos.copy(enemy.position);
                        killerPos.y = 1.7; // Look at killer's head height
                        killerFound = true;
                    }
                    // Check for multiplayer opponent
                    else if (isMultiplayer && otherPlayer && otherPlayer.visible) {
                        // Use targetOtherPlayerPosition for real-time tracking, not interpolated position
                        if (targetOtherPlayerPosition) {
                            killerPos.copy(targetOtherPlayerPosition);
                        } else {
                            killerPos.copy(otherPlayer.position);
                        }
                        killerPos.y = 1.7; // Look at killer's head height
                        killerFound = true;
                    }
                    // Fallback to stored position
                    else if (gameState.killerPosition) {
                        killerPos.copy(gameState.killerPosition);
                        killerPos.y = 1.7;
                        killerFound = true;
                    }

                    if (killerFound) {
                        // SMOOTH CAMERA TRACKING - Slowly turns to follow killer

                        // Compute target quaternion without allocating a temporary camera
                        _deathLookAtMat.lookAt(camera.position, killerPos, camera.up);
                        _deathTargetQuat.setFromRotationMatrix(_deathLookAtMat);

                        // Smoothly interpolate (slerp) from current rotation to target rotation
                        const rotationSpeed = Math.min(1, deltaTime * 2.5); // Clamp to valid slerp factor
                        camera.quaternion.slerp(_deathTargetQuat, rotationSpeed);

                        // ADD SMOOTH GLOW EFFECT TO KILLER
                        const killerMesh = isMultiplayer ? otherPlayer : enemy;
                        if (killerMesh) {
                            // Pulsing glow intensity (stronger)
                            const glowIntensity = 1.0 + Math.sin(gameState.deathTimer * 3) * 0.5;

                            // Cache glow meshes once per death (avoids per-frame traverse)
                            if (gameState.killerGlowSource !== killerMesh || !gameState.killerGlowMeshes) {
                                gameState.killerGlowSource = killerMesh;
                                gameState.killerGlowMeshes = [];

                                killerMesh.traverse((child) => {
                                    if (!child.isMesh || !child.material) return;
                                    if (!child.material.emissive) return;

                                    // Store original values once
                                    if (!child.userData.originalEmissive) {
                                        child.userData.originalEmissive = child.material.emissive.clone();
                                        child.userData.originalEmissiveIntensity = child.material.emissiveIntensity || 0;
                                    }
                                    if (child.userData.originalColorHex === undefined && child.material.color) {
                                        child.userData.originalColorHex = child.material.color.getHex();
                                    }

                                    // Clone material if shared to avoid affecting other objects
                                    if (!child.userData.materialCloned) {
                                        child.material = child.material.clone();
                                        child.userData.materialCloned = true;
                                    }

                                    // Apply strong red glow
                                    child.material.emissive.setHex(0xff0000);
                                    if (child.material.color) {
                                        child.material.color.lerp(_deathGlowColor, 0.3);
                                    }
                                    gameState.killerGlowMeshes.push(child);
                                });
                            }

                            const glowMeshes = gameState.killerGlowMeshes;
                            if (glowMeshes) {
                                for (let j = 0; j < glowMeshes.length; j++) {
                                    const child = glowMeshes[j];
                                    if (child && child.material && child.material.emissive) {
                                        child.material.emissiveIntensity = glowIntensity;
                                    }
                                }
                            }
                        }
                    } else {
                        // Avoid spamming console every frame during death cam
                    }

                    // Slight zoom effect toward killer
                    const targetFov = Math.max(60, 75 - (deathProgress * 10)); // Zoom in slightly
                    camera.fov = lerp(camera.fov, targetFov, deltaTime * 1);
                    camera.updateProjectionMatrix();

                    // CRITICAL: Keep enemy AI running during death cam so they keep moving
                    dbgStart('enemy');
                    updateEnemy(deltaTime);
                    dbgEnd('enemy');

                    // CRITICAL: Update multiplayer opponent position during death cam
                    if (isMultiplayer && otherPlayer && targetOtherPlayerPosition) {
                        dbgStart('multiplayer');
                        // Use simple exponential smoothing
                        const smoothSpeed = 15;
                        const lerpFactor = 1 - Math.exp(-smoothSpeed * deltaTime);
                        otherPlayer.position.lerp(targetOtherPlayerPosition, lerpFactor);

                        if (targetOtherPlayerRotation) {
                            // Body: only Y rotation
                            otherPlayer.rotation.y = otherPlayer.rotation.y + (targetOtherPlayerRotation.y - otherPlayer.rotation.y) * lerpFactor;
                        }

                        // Update mixer FIRST during death cam (before head rotation override)
                        if (otherPlayer.mixer) {
                            otherPlayer.mixer.update(deltaTime);
                        }
                        if (window.SkeletonAnimationSystem) {
                            SkeletonAnimationSystem.update(deltaTime);
                        }

                        // HEAD ROTATION: Apply AFTER animation update - INSTANT AND ACCURATE!
                        if (targetOtherPlayerRotation && otherPlayer.headBone) {
                            // INVERT the pitch - negative for correct up/down direction!
                            const headTargetPitch = -targetOtherPlayerRotation.x; // INVERTED!

                            // INSTANT - no smoothing!
                            otherPlayer.headBone.rotation.x = headTargetPitch;

                            // Also apply to neck
                            if (otherPlayer.neckBone) {
                                otherPlayer.neckBone.rotation.x = headTargetPitch * 0.3;
                            }

                            // Spine for extreme angles
                            if (otherPlayer.spineBone) {
                                otherPlayer.spineBone.rotation.x = headTargetPitch * 0.2;
                            }
                        }

                        otherPlayer.visible = true;
                        dbgEnd('multiplayer');
                    }
                    dbgEnd('deathCam');
                } else if (gameState.started && !gameState.paused) {
                    dbgStart('movement');
                    updateMovement(deltaTime);
                    dbgEnd('movement');

                    dbgStart('enemy');
                    updateEnemy(deltaTime);
                    dbgEnd('enemy');

                    dbgStart('cameraShake');
                    updateCameraShake(deltaTime);
                    dbgEnd('cameraShake');

                    // Interpolate other player positions smoothly (every frame)
                    if (isMultiplayer) {
                        dbgStart('multiplayer');
                        if (gameMode === '2v2') {
                            // 2v2 mode: interpolate all other players - PERF: Use for loop instead of forEach
                            for (let p = 0; p < otherPlayers.length; p++) {
                                const playerData = otherPlayers[p];
                                if (!playerData || !playerData.mesh) continue;
                                const playerMesh = playerData.mesh;

                                if (playerMesh.isDying) {
                                    playerMesh.deathTimer += deltaTime;

                                    // For SKELETON: Let the death animation play, just update mixer
                                    if (playerMesh.skinName === 'skeleton' && window.SkeletonAnimationSystem) {
                                        // Update animation mixer to play death animation
                                        if (playerMesh.mixer) {
                                            playerMesh.mixer.update(deltaTime);
                                        }
                                        SkeletonAnimationSystem.update(deltaTime);

                                        // Hide after animation completes (~2.5 seconds for death anims)
                                        if (playerMesh.deathTimer >= 2.5) {
                                            playerMesh.visible = false;
                                        }
                                    } else {
                                        // For NON-SKELETON: Use the old manual rotation/fall
                                        playerMesh.rotation.x = lerp(playerMesh.rotation.x, -Math.PI / 2, deltaTime * 5);
                                        playerMesh.rotation.z = lerp(playerMesh.rotation.z, (Math.random() - 0.5) * 0.1, deltaTime * 5);
                                        playerMesh.position.y = lerp(playerMesh.position.y, 0.5, deltaTime * 5);

                                        if (playerMesh.deathTimer >= 1.5) {
                                            playerMesh.visible = false;
                                        }
                                    }
                                } else {
                                    const lerpSpeed = 0.15; // Fixed smooth lerp

                                    // Interpolate position
                                    if (playerMesh.targetPosition) {
                                        playerMesh.position.lerp(playerMesh.targetPosition, lerpSpeed);
                                    }

                                    // Interpolate rotation (slightly faster for responsiveness)
                                    if (playerMesh.targetRotation) {
                                        const targetQuaternion = playerMesh.userData._targetQuat || (playerMesh.userData._targetQuat = new THREE.Quaternion());
                                        targetQuaternion.setFromEuler(playerMesh.targetRotation);
                                        playerMesh.quaternion.slerp(targetQuaternion, lerpSpeed * 1.5);
                                    }

                                    // Update animation mixer if exists
                                    if (playerMesh.mixer) {
                                        playerMesh.mixer.update(deltaTime);
                                    }

                                    // Ensure visibility and in scene
                                    playerMesh.visible = true;
                                    if (scene && playerMesh.parent !== scene) {
                                        scene.add(playerMesh);
                                    }
                                }
                            }
                        } else {
                            // 1v1 mode: single otherPlayer
                            if (otherPlayer) {
                                if (otherPlayer.isDying) {
                                    otherPlayer.deathTimer += deltaTime;

                                    // For SKELETON: Let the death animation play, just update mixer
                                    if (otherPlayer.skinName === 'skeleton' && window.SkeletonAnimationSystem) {
                                        // Update animation mixer to play death animation
                                        if (otherPlayer.mixer) {
                                            otherPlayer.mixer.update(deltaTime);
                                        }
                                        SkeletonAnimationSystem.update(deltaTime);

                                        // Hide after animation completes (~2.5 seconds for death anims)
                                        if (otherPlayer.deathTimer >= 2.5) {
                                            otherPlayer.visible = false;
                                        }
                                    } else {
                                        // For NON-SKELETON: Use the old manual rotation/fall
                                        otherPlayer.rotation.x = lerp(otherPlayer.rotation.x, -Math.PI / 2, deltaTime * 5);
                                        otherPlayer.rotation.z = lerp(otherPlayer.rotation.z, (Math.random() - 0.5) * 0.1, deltaTime * 5);
                                        otherPlayer.position.y = lerp(otherPlayer.position.y, 0.5, deltaTime * 5);

                                        if (otherPlayer.deathTimer >= 1.5) {
                                            otherPlayer.visible = false;
                                        }
                                    }
                                } else {
                                    // SIMPLE EXPONENTIAL SMOOTHING
                                    // Use frame-rate independent lerp: 1 - e^(-speed * deltaTime)
                                    // Higher speed = faster catch-up, lower = smoother but more lag
                                    const smoothSpeed = 15; // Adjust this: 10=smooth, 20=snappy
                                    const lerpFactor = 1 - Math.exp(-smoothSpeed * deltaTime);

                                    // Smoothly move towards target position
                                    otherPlayer.position.lerp(targetOtherPlayerPosition, lerpFactor);

                                    // BODY ROTATION: Only apply Y rotation (turning left/right) to body
                                    // This keeps the body upright while only rotating horizontally
                                    const bodyTargetY = targetOtherPlayerRotation.y;
                                    otherPlayer.rotation.y = otherPlayer.rotation.y + (bodyTargetY - otherPlayer.rotation.y) * lerpFactor;

                                    // Update animation mixer FIRST (before head rotation override)
                                    if (otherPlayer.mixer) {
                                        otherPlayer.mixer.update(deltaTime);
                                    }

                                    // Update skeleton animation system FIRST
                                    if (window.SkeletonAnimationSystem) {
                                        SkeletonAnimationSystem.update(deltaTime);
                                    }

                                    // HEAD ROTATION: Apply pitch (up/down) to head bone AFTER animation update
                                    // This AGGRESSIVELY overrides whatever the animation did - 100% ACCURATE!
                                    if (otherPlayer.headBone) {
                                        // INVERT the pitch - negative for correct up/down direction!
                                        const headTargetPitch = -targetOtherPlayerRotation.x; // INVERTED!

                                        // INSTANT head rotation - no smoothing, just set it directly!
                                        otherPlayer.headBone.rotation.x = headTargetPitch;

                                        // Also apply to neck for more pronounced effect
                                        if (otherPlayer.neckBone) {
                                            otherPlayer.neckBone.rotation.x = headTargetPitch * 0.3;
                                        }

                                        // For extreme pitch angles, also rotate spine
                                        if (otherPlayer.spineBone) {
                                            const spineAmount = headTargetPitch * 0.2;
                                            otherPlayer.spineBone.rotation.x = spineAmount;
                                        }
                                    } else if (otherPlayer.skinnedMesh) {
                                        // Try to find head bone if not already found
                                        otherPlayer.skinnedMesh.traverse((child) => {
                                            if (child.isBone) {
                                                const name = child.name.toLowerCase();
                                                if (name.includes('head') && !name.includes('headtop') && !name.includes('end')) {
                                                    otherPlayer.headBone = child;
                                                }
                                                if (name.includes('spine') && !otherPlayer.spineBone) {
                                                    otherPlayer.spineBone = child;
                                                }
                                            }
                                        });
                                    }

                                    // Ensure visibility and in scene
                                    otherPlayer.visible = true;
                                    if (scene && otherPlayer.parent !== scene) {
                                        scene.add(otherPlayer);
                                    }
                                }
                            }
                        }
                        dbgEnd('multiplayer');
                    }

                    // Make enemy speaker icon always face the camera
                    if (enemySpeakerIcon && enemySpeakerIcon.visible) {
                        enemySpeakerIcon.lookAt(camera.position);
                    }

                    // Update enemy sound volumes based on distance in real-time
                    dbgStart('audio');
                    updateEnemySoundVolumes();

                    // Update voice chat volume based on distance to other player
                    if (otherPlayer) {
                        VoiceChat.updateVoiceDistance();
                    }

                    // Update death sound volume based on distance in real-time
                    if (activeOtherPlayerDeathSound && activeOtherPlayerDeathSound.gainNode && otherPlayer) {
                        const distance = camera.position.distanceTo(otherPlayer.position);
                        const maxDistance = 25; // Reduced max distance for death sounds
                        const minVolume = 0.02; // Lower minimum volume for very distant sounds
                        // Use more aggressive exponential falloff for death sounds
                        const falloffRate = 3.0; // Even higher falloff rate for death sounds
                        let volume = Math.exp(-(distance / maxDistance) * falloffRate);
                        volume = Math.max(minVolume, Math.min(1, volume)); // Clamp volume between minVolume and 1

                        // Update the gain node with the new volume
                        if (audioContext) activeOtherPlayerDeathSound.gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
                    }
                    dbgEnd('audio');

                    // Send position data
                    if (isMultiplayer) {
                        dbgStart('netSend');
                        // Check connection state
                        let isWebRTCReady = false;
                        if (useWebRTC) {
                            if (gameMode === '2v2' && isHost) {
                                // Host in 2v2: check if we have any active connections
                                isWebRTCReady = playerConnections && playerConnections.size > 0;
                            } else if (dataChannel) {
                                // Client or 1v1: check dataChannel
                                isWebRTCReady = (dataChannel.open === true) || (dataChannel.readyState === 'open' || dataChannel.readyState === 'OPEN');
                            }
                        }
                        const isSocketReady = socket && socket.connected;

                        if (isWebRTCReady || isSocketReady) {
                            // Get current camera position and rotation (after movement, before shake)
                            // Note: camera shake is applied after this, so we get the base position
                            // PERF: Read position directly instead of cloning
                            const camPos = camera.position;

                            // PERF: Reuse euler for transmission
                            _reusableEuler.setFromQuaternion(camera.quaternion, 'YXZ');

                            // Calculate velocity for animation state
                            // Use actual movement speed, not just key states
                            const baseSpeed = gameState.isSprinting ? 12 : (gameState.isSliding ? 3 : 8);
                            const velocityX = ((moveRight ? 1 : 0) - (moveLeft ? 1 : 0)) * baseSpeed;
                            const velocityZ = ((moveBackward ? 1 : 0) - (moveForward ? 1 : 0)) * baseSpeed;

                            // PERF: Reuse pre-allocated position data object instead of creating new one every frame
                            _netPositionData.x = camPos.x;
                            _netPositionData.y = camPos.y;
                            _netPositionData.z = camPos.z;
                            _netPositionData.rx = _reusableEuler.x;
                            _netPositionData.ry = _reusableEuler.y;
                            _netPositionData.rz = _reusableEuler.z;
                            _netPositionData.anim.vx = velocityX;
                            _netPositionData.anim.vz = velocityZ;
                            _netPositionData.anim.crouch = gameState.isSliding || false;
                            _netPositionData.anim.sprint = gameState.isSprinting || false;
                            _netPositionData.anim.jump = gameState.isJumping || false;
                            _netPositionData.anim.jumpPhase = gameState.isJumping ? (gameState.velocityY > 2 ? 'up' : (gameState.velocityY < -2 ? 'down' : 'loop')) : null;

                            sendToOther(_netPositionData);
                        }
                        // Silently skip if connection not ready - no spam logging
                        dbgEnd('netSend');
                    }

                    // Apply camera shake to position and rotation (only if there's actual shake)
                    if (cameraShake.intensity > 0.001 ||
                        Math.abs(cameraShake.offsetX) > 0.0001 ||
                        Math.abs(cameraShake.offsetY) > 0.0001 ||
                        Math.abs(cameraShake.rotationX) > 0.0001 ||
                        Math.abs(cameraShake.rotationY) > 0.0001) {
                        camera.position.x += cameraShake.offsetX;
                        camera.position.y += cameraShake.offsetY;
                        camera.position.z += cameraShake.offsetZ;

                        euler.setFromQuaternion(camera.quaternion);
                        euler.x += cameraShake.rotationX;
                        euler.y += cameraShake.rotationY;
                        camera.quaternion.setFromEuler(euler);
                    }

                    // Update local player username position to follow camera
                    // if (localPlayerUsernameSprite) {
                    // localPlayerUsernameSprite.position.set(camera.position.x, camera.position.y + 0.5, camera.position.z);
                    // }
                }
                // Update depth of field focus based on what player is looking at (only if DOF enabled)
                // PERF: Only run DOF raycast every 3rd frame to reduce overhead (still smooth due to lerp)
                if (postProcessMaterial.uniforms.enableDOF.value > 0.5) {
                    _dofUpdateCounter = (_dofUpdateCounter || 0) + 1;
                    if (_dofUpdateCounter >= 3) {
                        _dofUpdateCounter = 0;
                        dbgStart('dofFocus');
                        // PERF: Reuse raycaster instead of creating new one each frame
                        _reusableRaycaster.setFromCamera(_reusableVec2Zero, camera);
                        // PERF: Only check map objects, not ALL scene children (excludes particles, effects, etc.)
                        const dofTargets = mapObjects.length > 0 ? mapObjects : scene.children;
                        const intersects = _reusableRaycaster.intersectObjects(dofTargets, true);

                        if (intersects.length > 0) {
                            // Find first object that's not too close (ignore objects closer than 2 units)
                            let targetDistance = intersects[0].distance;
                            for (let i = 0; i < intersects.length; i++) {
                                if (intersects[i].distance > 2.0) {
                                    targetDistance = intersects[i].distance;
                                    break;
                                }
                            }
                            // Clamp focus distance to reasonable range (5-50 units)
                            targetDistance = Math.max(5.0, Math.min(50.0, targetDistance));
                            _dofTargetDistance = targetDistance;
                        }
                        dbgEnd('dofFocus');
                    }
                    // PERF: Always lerp towards target (smooth even without raycast this frame)
                    if (_dofTargetDistance !== undefined) {
                        postProcessMaterial.uniforms.focusDistance.value += (_dofTargetDistance - postProcessMaterial.uniforms.focusDistance.value) * 0.1;
                    }
                }

                // PERF: Periodic shadow map updates instead of every frame
                dbgStart('shadows');
                _shadowUpdateCounter++;
                if (_shadowUpdateCounter >= SHADOW_UPDATE_INTERVAL) {
                    renderer.shadowMap.needsUpdate = true;
                    _shadowUpdateCounter = 0;
                }
                dbgEnd('shadows');

                // Sync weapon camera with main camera BEFORE rendering
                weaponCamera.position.copy(camera.position);
                weaponCamera.quaternion.copy(camera.quaternion);
                weaponCamera.fov = camera.fov;
                weaponCamera.updateProjectionMatrix();

                // DYNAMIC AMBIENCE UPDATE
                if (window.AmbienceSystem && window.AmbienceSystem.update) {
                    window.AmbienceSystem.update(camera.position);
                }

                // Always use post-processing for consistent visuals
                const dofEnabled = postProcessMaterial.uniforms.enableDOF.value > 0.5;

                // Render main scene to texture
                dbgStart('renderMain');
                renderer.setRenderTarget(renderTarget);
                renderer.autoClear = true;
                renderer.render(scene, camera);
                
                // Render weapon into the same render target so it gets post-processing effects
                if (!gameState.isDying && gameState.weaponVisible !== false && gameState.started) {
                    if (currentWeaponMesh) {
                        currentWeaponMesh.visible = true;
                    }
                    renderer.autoClear = false; // Don't clear, just add weapon
                    renderer.clearDepth(); // Only clear depth buffer
                    renderer.render(weaponScene, weaponCamera);
                }
                renderer.autoClear = true; // Reset for next pass
                dbgEnd('renderMain');

                // Render depth pass - ONLY when DOF is enabled
                if (dofEnabled) {
                    dbgStart('renderDepth');
                    scene.overrideMaterial = depthMaterial;
                    renderer.setRenderTarget(depthRenderTarget);
                    renderer.render(scene, camera);
                    scene.overrideMaterial = null;
                    dbgEnd('renderDepth');
                }

                // Apply post-processing
                postProcessMaterial.uniforms.tDiffuse.value = renderTarget.texture;
                if (dofEnabled) {
                    postProcessMaterial.uniforms.tDepth.value = depthRenderTarget.texture;
                }

                // Render post-processed scene to screen
                // IMPORTANT: Disable tone mapping for post-process pass to avoid double tone mapping
                dbgStart('renderPost');
                const savedToneMapping = renderer.toneMapping;
                renderer.toneMapping = THREE.NoToneMapping;
                renderer.setRenderTarget(null);
                renderer.autoClear = true;
                renderer.render(postProcessScene, postProcessCamera);
                renderer.toneMapping = savedToneMapping; // Restore for weapon pass
                dbgEnd('renderPost');
                weaponCamera.position.copy(camera.position);
                weaponCamera.quaternion.copy(camera.quaternion);
                weaponCamera.fov = camera.fov;
                weaponCamera.updateProjectionMatrix();

                // Feed profiler the real frame time (ms) and sim dt (s)
                const frameRealDeltaMs = deltaTime * 1000;
                dbgFrameEnd(frameRealDeltaMs, deltaTime);
            }
            // Start Game (AI Mode)
            document.getElementById('startButton').addEventListener('click', () => {
                if (window.resumeGlobalAudio) window.resumeGlobalAudio();
                // Get username from input
                const usernameInput = document.getElementById('usernameInput');
                const username = usernameInput.value.trim() || 'Player';
                gameState.playerUsername = username;

                // Initialize game first if not already done
                if (!window.gameInitialized) {
                    console.log('Initializing game for AI mode...');
                    initGame();
                }

                document.getElementById('startScreen').style.display = 'none';
                document.getElementById('levelDisplay').style.display = 'flex';
                // Hide music player and stop music when game starts
                if (window.MusicPlayer && typeof window.MusicPlayer.handleGameStart === 'function') {
                    window.MusicPlayer.handleGameStart();
                }
                // Show Minecraft XP HUD
                const mcXpHud2 = document.getElementById('mcXpHud');
                if (mcXpHud2) mcXpHud2.classList.add('visible');
                // Hide lobby squad list
                const lobbyList3 = document.getElementById('lobbySquadList');
                if (lobbyList3) lobbyList3.style.display = 'none';
                if (window.menuSceneController) window.menuSceneController.hide();
                gameState.started = true;

                // Show R6 Topbar
                showR6Topbar();
                
                // Show AI Hit Me button for testing near-death effect
                const aiHitBtn = document.getElementById('aiHitMeBtn');
                if (aiHitBtn) aiHitBtn.classList.add('visible');

                // Request pointer lock
                renderer.domElement.requestPointerLock = renderer.domElement.requestPointerLock ||
                    renderer.domElement.mozRequestPointerLock ||
                    renderer.domElement.webkitRequestPointerLock;
                renderer.domElement.requestPointerLock();

                // Create local player username display
                // createLocalPlayerUsernameDisplay(); // Not visible in first-person

                updateHUD();

                // Start animation loop only once
                if (!window.animateStarted) {
                    window.animateStarted = true;
                    animate();
                }
            });

            // Re-lock pointer on click if lost
            renderer.domElement.addEventListener('click', () => {
                if (window.resumeGlobalAudio) window.resumeGlobalAudio();
                // Resume Ambience Context
                if (window.AmbienceSystem && window.AmbienceSystem.resume) window.AmbienceSystem.resume();

                // Only log when actually trying to acquire lock (not when already locked)
                if (gameState.started && !document.pointerLockElement && !gameState.isDying) {
                    console.log('🖱️ Canvas clicked - requesting pointer lock');
                    renderer.domElement.requestPointerLock();
                    if (gameState.paused) {
                        gameState.paused = false;
                    }
                }
                // If already locked, clicking fires shoot - no need to log
            });

            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                // Update weapon camera too
                weaponCamera.aspect = window.innerWidth / window.innerHeight;
                weaponCamera.updateProjectionMatrix();

                renderer.setSize(window.innerWidth, window.innerHeight);

                // Update render targets
                renderTarget.setSize(window.innerWidth, window.innerHeight);
                depthRenderTarget.setSize(window.innerWidth, window.innerHeight);
                postProcessMaterial.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
            });

            // Initial render
            renderer.render(scene, camera);
        }
        // Setup multiplayer buttons after initGame is defined
        setupMultiplayerButtons();

        // ==================== KEYBINDS SYSTEM ====================
        const DEFAULT_KEYBINDS = {
            'moveForward': 'KeyZ',
            'moveBackward': 'KeyS',
            'moveLeft': 'KeyQ',
            'moveRight': 'KeyD',
            'jump': 'Space',
            'sprint': 'ShiftLeft',
            'slide': 'ControlLeft',
            'leanLeft': 'KeyA',
            'leanRight': 'KeyE',
            'reload': 'KeyR',
            'pause': 'Escape',
            'weapon1': 'Digit1',
            'weapon2': 'Digit2',
            'weapon3': 'Digit3',
            'toggleDOF': 'KeyF'
        };

        const KEYBIND_LABELS = {
            'moveForward': 'Move Forward',
            'moveBackward': 'Move Backward',
            'moveLeft': 'Move Left',
            'moveRight': 'Move Right',
            'jump': 'Jump',
            'sprint': 'Sprint',
            'slide': 'Slide',
            'leanLeft': 'Lean Left',
            'leanRight': 'Lean Right',
            'reload': 'Reload',
            'pause': 'Pause',
            'weapon1': 'Switch to AK-47',
            'weapon2': 'Switch to Deagle',
            'weapon3': 'Switch to AWP',
            'toggleDOF': 'Toggle Depth of Field'
        };

        let currentKeybinds = JSON.parse(localStorage.getItem('gameKeybinds')) || DEFAULT_KEYBINDS;

        function getKeyName(code) {
            const keyNames = {
                'KeyZ': 'Z', 'KeyS': 'S', 'KeyQ': 'Q', 'KeyD': 'D',
                'Space': 'SPACE', 'ShiftLeft': 'SHIFT', 'ControlLeft': 'CTRL',
                'KeyA': 'A', 'KeyE': 'E', 'KeyR': 'R', 'Escape': 'ESC',
                'Digit1': '1', 'Digit2': '2', 'Digit3': '3', 'KeyF': 'F'
            };
            return keyNames[code] || code;
        }

        function openKeybindsModal() {
            const modal = document.getElementById('keybindsModal');
            const list = document.getElementById('keybindsList');
            list.innerHTML = '';

            for (const [action, code] of Object.entries(currentKeybinds)) {
                const item = document.createElement('div');
                item.className = 'keybind-item';
                item.innerHTML = `
                <div class="keybind-label">${KEYBIND_LABELS[action]}</div>
                <div class="keybind-input" data-action="${action}" onclick="startListeningForKey('${action}')">
                    ${getKeyName(code)}
                </div>
            `;
                list.appendChild(item);
            }

            modal.classList.add('active');
        }

        function closeKeybindsModal() {
            document.getElementById('keybindsModal').classList.remove('active');
            localStorage.setItem('gameKeybinds', JSON.stringify(currentKeybinds));
        }

        function startListeningForKey(action) {
            const input = document.querySelector(`[data-action="${action}"]`);
            input.classList.add('listening');
            input.textContent = 'PRESS KEY...';

            const handler = (e) => {
                e.preventDefault();
                currentKeybinds[action] = e.code;
                input.textContent = getKeyName(e.code);
                input.classList.remove('listening');
                document.removeEventListener('keydown', handler);
            };

            document.addEventListener('keydown', handler);
        }

        function resetKeybinds() {
            if (confirm('Reset all keybinds to default?')) {
                currentKeybinds = { ...DEFAULT_KEYBINDS };
                localStorage.setItem('gameKeybinds', JSON.stringify(currentKeybinds));
                openKeybindsModal();
            }
        }
    </script>
</body>

</html>